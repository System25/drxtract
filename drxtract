#!/usr/bin/python

# Author: Abraham Macias Paredes
# E-mail: system252001@yahoo.es
# License: GNU GPL v3 (see LICENSE file for details).

#
# Script to extract contents from Macromedia Director 4.0 and 5.0 DRX files.
# Also can extract contents from "updated" Macromedia Director DRI files.
# 



import sys
import os
import struct
import re
import wave

# Default bit order for MAC
bit_order_type = 'mac'
bit_order = ">"
previous_clut = None
bmp_file_name = None

MV93_FILE_TYPE = 'MV93'
RIFX_FILE_FORMAT = 'RIFX'
IMAP_FILE_FORMAT = 'imap'
MMAP_FILE_FORMAT = 'mmap'
FREE_FILE_FORMAT = 'free'
THUM_FILE_FORMAT = 'THUM'
BITD_FILE_FORMAT = 'BITD'
CLUT_FILE_FORMAT = 'CLUT'
CAST_FILE_FORMAT = 'CASt'
SND_FILE_FORMAT = 'snd '
KEY_FILE_FORMAT = 'KEY*'
CAS_FILE_FORMAT = 'CAS*'
LSCR_FILE_FORMAT = 'Lscr'
LNAM_FILE_FORMAT = 'Lnam'


# Director 5 types
DIR5_IMAGE_TYPE = 1
DIR5_CLUT_TYPE = 4
DIR5_SND_TYPE = 6

# Director 4 types
DIR4_IMAGE_TYPE = 0x1C0000
DIR4_SND_TYPE = 0x010000


DEFAULT_MAC_16COLORS_PALETTE = (
  255, 255, 255, 0, # white
  255, 255, 0, 0,   # yellow
  255, 160, 0, 0,   # orange
  255, 0, 0, 0,     # red
  255, 0, 255, 0,   # magenta
  128, 0, 128, 0,   # purple
  0, 0, 255, 0,     # blue
  0, 255, 255, 0,   # cyan

  0, 128, 0, 0,     # green
  0, 100, 0, 0,     # dark green
  165, 42, 42, 0,   # brown
  210, 180, 140, 0, # tan
  211, 211, 211, 0, # light gray
  128, 128, 128, 0, # gray
  169, 169, 169, 0, # dark gray
  0, 0, 0, 0        # black
 )


DEFAULT_WINDOWS_16COLORS_PALETTE = (
  255, 255, 255, 0, # white
  0, 255, 255, 0,   # aqua
  255, 0, 255, 0,   # fuchsia
  0, 0, 255, 0,     # blue
  255, 255, 0, 0,   # yellow
  0, 255, 0, 0,     # lime
  255, 0, 0, 0,     # red
  128, 128, 128, 0, # gray

  192, 192, 192, 0, # silver
  0, 128, 128, 0,   # teal
  128, 0, 128, 0,   # purple
  0, 0, 128, 0,     # navy
  128, 128, 0, 0,   # olive
  0, 128, 0, 0,     # green
  128, 0, 0, 0,     # maroon
  0, 0, 0, 0        # black
 )

DEFAUL_MAC_256COLORS_PALETTE = (
 0xFF, 0xFF, 0xFF, 0x00,
 0xCC, 0xFF, 0xFF, 0x00,
 0x99, 0xFF, 0xFF, 0x00,
 0x66, 0xFF, 0xFF, 0x00,
 0x33, 0xFF, 0xFF, 0x00,
 0x00, 0xFF, 0xFF, 0x00,
 0xFF, 0xCC, 0xFF, 0x00,
 0xCC, 0xCC, 0xFF, 0x00,
 0x99, 0xCC, 0xFF, 0x00,
 0x66, 0xCC, 0xFF, 0x00,
 0x33, 0xCC, 0xFF, 0x00,
 0x00, 0xCC, 0xFF, 0x00,
 0xFF, 0x99, 0xFF, 0x00,
 0xCC, 0x99, 0xFF, 0x00,
 0x99, 0x99, 0xFF, 0x00,
 0x66, 0x99, 0xFF, 0x00,
 0x33, 0x99, 0xFF, 0x00,
 0x00, 0x99, 0xFF, 0x00,
 0xFF, 0x66, 0xFF, 0x00,
 0xCC, 0x66, 0xFF, 0x00,
 0x99, 0x66, 0xFF, 0x00,
 0x66, 0x66, 0xFF, 0x00,
 0x33, 0x66, 0xFF, 0x00,
 0x00, 0x66, 0xFF, 0x00,
 0xFF, 0x33, 0xFF, 0x00,
 0xCC, 0x33, 0xFF, 0x00,
 0x99, 0x33, 0xFF, 0x00,
 0x66, 0x33, 0xFF, 0x00,
 0x33, 0x33, 0xFF, 0x00,
 0x00, 0x33, 0xFF, 0x00,
 0xFF, 0x00, 0xFF, 0x00,
 0xCC, 0x00, 0xFF, 0x00,
 0x99, 0x00, 0xFF, 0x00,
 0x66, 0x00, 0xFF, 0x00,
 0x33, 0x00, 0xFF, 0x00,
 0x00, 0x00, 0xFF, 0x00,
 0xFF, 0xFF, 0xCC, 0x00,
 0xCC, 0xFF, 0xCC, 0x00,
 0x99, 0xFF, 0xCC, 0x00,
 0x66, 0xFF, 0xCC, 0x00,
 0x33, 0xFF, 0xCC, 0x00,
 0x00, 0xFF, 0xCC, 0x00,
 0xFF, 0xCC, 0xCC, 0x00,
 0xCC, 0xCC, 0xCC, 0x00,
 0x99, 0xCC, 0xCC, 0x00,
 0x66, 0xCC, 0xCC, 0x00,
 0x33, 0xCC, 0xCC, 0x00,
 0x00, 0xCC, 0xCC, 0x00,
 0xFF, 0x99, 0xCC, 0x00,
 0xCC, 0x99, 0xCC, 0x00,
 0x99, 0x99, 0xCC, 0x00,
 0x66, 0x99, 0xCC, 0x00,
 0x33, 0x99, 0xCC, 0x00,
 0x00, 0x99, 0xCC, 0x00,
 0xFF, 0x66, 0xCC, 0x00,
 0xCC, 0x66, 0xCC, 0x00,
 0x99, 0x66, 0xCC, 0x00,
 0x66, 0x66, 0xCC, 0x00,
 0x33, 0x66, 0xCC, 0x00,
 0x00, 0x66, 0xCC, 0x00,
 0xFF, 0x33, 0xCC, 0x00,
 0xCC, 0x33, 0xCC, 0x00,
 0x99, 0x33, 0xCC, 0x00,
 0x66, 0x33, 0xCC, 0x00,
 0x33, 0x33, 0xCC, 0x00,
 0x00, 0x33, 0xCC, 0x00,
 0xFF, 0x00, 0xCC, 0x00,
 0xCC, 0x00, 0xCC, 0x00,
 0x99, 0x00, 0xCC, 0x00,
 0x66, 0x00, 0xCC, 0x00,
 0x33, 0x00, 0xCC, 0x00,
 0x00, 0x00, 0xCC, 0x00,
 0xFF, 0xFF, 0x99, 0x00,
 0xCC, 0xFF, 0x99, 0x00,
 0x99, 0xFF, 0x99, 0x00,
 0x66, 0xFF, 0x99, 0x00,
 0x33, 0xFF, 0x99, 0x00,
 0x00, 0xFF, 0x99, 0x00,
 0xFF, 0xCC, 0x99, 0x00,
 0xCC, 0xCC, 0x99, 0x00,
 0x99, 0xCC, 0x99, 0x00,
 0x66, 0xCC, 0x99, 0x00,
 0x33, 0xCC, 0x99, 0x00,
 0x00, 0xCC, 0x99, 0x00,
 0xFF, 0x99, 0x99, 0x00,
 0xCC, 0x99, 0x99, 0x00,
 0x99, 0x99, 0x99, 0x00,
 0x66, 0x99, 0x99, 0x00,
 0x33, 0x99, 0x99, 0x00,
 0x00, 0x99, 0x99, 0x00,
 0xFF, 0x66, 0x99, 0x00,
 0xCC, 0x66, 0x99, 0x00,
 0x99, 0x66, 0x99, 0x00,
 0x66, 0x66, 0x99, 0x00,
 0x33, 0x66, 0x99, 0x00,
 0x00, 0x66, 0x99, 0x00,
 0xFF, 0x33, 0x99, 0x00,
 0xCC, 0x33, 0x99, 0x00,
 0x99, 0x33, 0x99, 0x00,
 0x66, 0x33, 0x99, 0x00,
 0x33, 0x33, 0x99, 0x00,
 0x00, 0x33, 0x99, 0x00,
 0xFF, 0x00, 0x99, 0x00,
 0xCC, 0x00, 0x99, 0x00,
 0x99, 0x00, 0x99, 0x00,
 0x66, 0x00, 0x99, 0x00,
 0x33, 0x00, 0x99, 0x00,
 0x00, 0x00, 0x99, 0x00,
 0xFF, 0xFF, 0x66, 0x00,
 0xCC, 0xFF, 0x66, 0x00,
 0x99, 0xFF, 0x66, 0x00,
 0x66, 0xFF, 0x66, 0x00,
 0x33, 0xFF, 0x66, 0x00,
 0x00, 0xFF, 0x66, 0x00,
 0xFF, 0xCC, 0x66, 0x00,
 0xCC, 0xCC, 0x66, 0x00,
 0x99, 0xCC, 0x66, 0x00,
 0x66, 0xCC, 0x66, 0x00,
 0x33, 0xCC, 0x66, 0x00,
 0x00, 0xCC, 0x66, 0x00,
 0xFF, 0x99, 0x66, 0x00,
 0xCC, 0x99, 0x66, 0x00,
 0x99, 0x99, 0x66, 0x00,
 0x66, 0x99, 0x66, 0x00,
 0x33, 0x99, 0x66, 0x00,
 0x00, 0x99, 0x66, 0x00,
 0xFF, 0x66, 0x66, 0x00,
 0xCC, 0x66, 0x66, 0x00,
 0x99, 0x66, 0x66, 0x00,
 0x66, 0x66, 0x66, 0x00,
 0x33, 0x66, 0x66, 0x00,
 0x00, 0x66, 0x66, 0x00,
 0xFF, 0x33, 0x66, 0x00,
 0xCC, 0x33, 0x66, 0x00,
 0x99, 0x33, 0x66, 0x00,
 0x66, 0x33, 0x66, 0x00,
 0x33, 0x33, 0x66, 0x00,
 0x00, 0x33, 0x66, 0x00,
 0xFF, 0x00, 0x66, 0x00,
 0xCC, 0x00, 0x66, 0x00,
 0x99, 0x00, 0x66, 0x00,
 0x66, 0x00, 0x66, 0x00,
 0x33, 0x00, 0x66, 0x00,
 0x00, 0x00, 0x66, 0x00,
 0xFF, 0xFF, 0x33, 0x00,
 0xCC, 0xFF, 0x33, 0x00,
 0x99, 0xFF, 0x33, 0x00,
 0x66, 0xFF, 0x33, 0x00,
 0x33, 0xFF, 0x33, 0x00,
 0x00, 0xFF, 0x33, 0x00,
 0xFF, 0xCC, 0x33, 0x00,
 0xCC, 0xCC, 0x33, 0x00,
 0x99, 0xCC, 0x33, 0x00,
 0x66, 0xCC, 0x33, 0x00,
 0x33, 0xCC, 0x33, 0x00,
 0x00, 0xCC, 0x33, 0x00,
 0xFF, 0x99, 0x33, 0x00,
 0xCC, 0x99, 0x33, 0x00,
 0x99, 0x99, 0x33, 0x00,
 0x66, 0x99, 0x33, 0x00,
 0x33, 0x99, 0x33, 0x00,
 0x00, 0x99, 0x33, 0x00,
 0xFF, 0x66, 0x33, 0x00,
 0xCC, 0x66, 0x33, 0x00,
 0x99, 0x66, 0x33, 0x00,
 0x66, 0x66, 0x33, 0x00,
 0x33, 0x66, 0x33, 0x00,
 0x00, 0x66, 0x33, 0x00,
 0xFF, 0x33, 0x33, 0x00,
 0xCC, 0x33, 0x33, 0x00,
 0x99, 0x33, 0x33, 0x00,
 0x66, 0x33, 0x33, 0x00,
 0x33, 0x33, 0x33, 0x00,
 0x00, 0x33, 0x33, 0x00,
 0xFF, 0x00, 0x33, 0x00,
 0xCC, 0x00, 0x33, 0x00,
 0x99, 0x00, 0x33, 0x00,
 0x66, 0x00, 0x33, 0x00,
 0x33, 0x00, 0x33, 0x00,
 0x00, 0x00, 0x33, 0x00,
 0xFF, 0xFF, 0x00, 0x00,
 0xCC, 0xFF, 0x00, 0x00,
 0x99, 0xFF, 0x00, 0x00,
 0x66, 0xFF, 0x00, 0x00,
 0x33, 0xFF, 0x00, 0x00,
 0x00, 0xFF, 0x00, 0x00,
 0xFF, 0xCC, 0x00, 0x00,
 0xCC, 0xCC, 0x00, 0x00,
 0x99, 0xCC, 0x00, 0x00,
 0x66, 0xCC, 0x00, 0x00,
 0x33, 0xCC, 0x00, 0x00,
 0x00, 0xCC, 0x00, 0x00,
 0xFF, 0x99, 0x00, 0x00,
 0xCC, 0x99, 0x00, 0x00,
 0x99, 0x99, 0x00, 0x00,
 0x66, 0x99, 0x00, 0x00,
 0x33, 0x99, 0x00, 0x00,
 0x00, 0x99, 0x00, 0x00,
 0xFF, 0x66, 0x00, 0x00,
 0xCC, 0x66, 0x00, 0x00,
 0x99, 0x66, 0x00, 0x00,
 0x66, 0x66, 0x00, 0x00,
 0x33, 0x66, 0x00, 0x00,
 0x00, 0x66, 0x00, 0x00,
 0xFF, 0x33, 0x00, 0x00,
 0xCC, 0x33, 0x00, 0x00,
 0x99, 0x33, 0x00, 0x00,
 0x66, 0x33, 0x00, 0x00,
 0x33, 0x33, 0x00, 0x00,
 0x00, 0x33, 0x00, 0x00,
 0xFF, 0x00, 0x00, 0x00,
 0xCC, 0x00, 0x00, 0x00,
 0x99, 0x00, 0x00, 0x00,
 0x66, 0x00, 0x00, 0x00,
 0x33, 0x00, 0x00, 0x00,
 0x00, 0x00, 0xEE, 0x00,
 0x00, 0x00, 0xDD, 0x00,
 0x00, 0x00, 0xBB, 0x00,
 0x00, 0x00, 0xAA, 0x00,
 0x00, 0x00, 0x88, 0x00,
 0x00, 0x00, 0x77, 0x00,
 0x00, 0x00, 0x55, 0x00,
 0x00, 0x00, 0x44, 0x00,
 0x00, 0x00, 0x22, 0x00,
 0x00, 0x00, 0x11, 0x00,
 0x00, 0xEE, 0x00, 0x00,
 0x00, 0xDD, 0x00, 0x00,
 0x00, 0xBB, 0x00, 0x00,
 0x00, 0xAA, 0x00, 0x00,
 0x00, 0x88, 0x00, 0x00,
 0x00, 0x77, 0x00, 0x00,
 0x00, 0x55, 0x00, 0x00,
 0x00, 0x44, 0x00, 0x00,
 0x00, 0x22, 0x00, 0x00,
 0x00, 0x11, 0x00, 0x00,
 0xEE, 0x00, 0x00, 0x00,
 0xDD, 0x00, 0x00, 0x00,
 0xBB, 0x00, 0x00, 0x00,
 0xAA, 0x00, 0x00, 0x00,
 0x88, 0x00, 0x00, 0x00,
 0x77, 0x00, 0x00, 0x00,
 0x55, 0x00, 0x00, 0x00,
 0x44, 0x00, 0x00, 0x00,
 0x22, 0x00, 0x00, 0x00,
 0x11, 0x00, 0x00, 0x00,
 0xEE, 0xEE, 0xEE, 0x00,
 0xDD, 0xDD, 0xDD, 0x00,
 0xBB, 0xBB, 0xBB, 0x00,
 0xAA, 0xAA, 0xAA, 0x00,
 0x88, 0x88, 0x88, 0x00,
 0x77, 0x77, 0x77, 0x00,
 0x55, 0x55, 0x55, 0x00,
 0x44, 0x44, 0x44, 0x00,
 0x22, 0x22, 0x22, 0x00,
 0x11, 0x11, 0x11, 0x00,
 0x00, 0x00, 0x00, 0x00,

)

DEFAULT_WINDOWS_256COLORS_PALETTE = (
     0xFF, 0xFF, 0xFF, 0x00,
     0xFF, 0xFF, 0x00, 0x00,
     0xFF, 0x00, 0xFF, 0x00,
     0xFF, 0x00, 0x00, 0x00,
     0x00, 0xFF, 0xFF, 0x00,
     0x00, 0xFF, 0x00, 0x00,
     0x00, 0x00, 0xFF, 0x00,
     0x80, 0x80, 0x80, 0x00,
     0xA4, 0xA0, 0xA0, 0x00,
     0xF0, 0xFB, 0xFF, 0x00,
     0x33, 0x33, 0x33, 0x00,
     0x00, 0x66, 0x99, 0x00,
     0x33, 0x66, 0x33, 0x00,
     0x99, 0x33, 0x00, 0x00,
     0xFF, 0x00, 0xCC, 0x00,
     0x00, 0x00, 0x88, 0x00,
     0x66, 0xCC, 0xFF, 0x00,
     0xCC, 0x99, 0xFF, 0x00,
     0xDD, 0xDD, 0xDD, 0x00,
     0x00, 0x99, 0xFF, 0x00,
     0xFF, 0x66, 0xFF, 0x00,
     0xCC, 0x66, 0xFF, 0x00,
     0x99, 0x66, 0xFF, 0x00,
     0x66, 0x66, 0xFF, 0x00,
     0x33, 0x66, 0xFF, 0x00,
     0x00, 0x66, 0xFF, 0x00,
     0xFF, 0x33, 0xFF, 0x00,
     0xCC, 0x33, 0xFF, 0x00,
     0x99, 0x33, 0xFF, 0x00,
     0x66, 0x33, 0xFF, 0x00,
     0x33, 0x33, 0xFF, 0x00,
     0x00, 0x33, 0xFF, 0x00,
     0xCC, 0x00, 0xFF, 0x00,
     0x99, 0x00, 0xFF, 0x00,
     0x66, 0x00, 0xFF, 0x00,
     0x33, 0x00, 0xFF, 0x00,
     0xFF, 0xFF, 0xCC, 0x00,
     0xCC, 0xFF, 0xCC, 0x00,
     0x99, 0xFF, 0xCC, 0x00,
     0x66, 0xFF, 0xCC, 0x00,
     0x33, 0xFF, 0xCC, 0x00,
     0x00, 0xFF, 0xCC, 0x00,
     0xFF, 0xCC, 0xCC, 0x00,
     0xCC, 0xCC, 0xCC, 0x00,
     0x99, 0xCC, 0xCC, 0x00,
     0x66, 0xCC, 0xCC, 0x00,
     0x33, 0xCC, 0xCC, 0x00,
     0x00, 0xCC, 0xCC, 0x00,
     0xFF, 0x99, 0xCC, 0x00,
     0xCC, 0x99, 0xCC, 0x00,
     0x99, 0x99, 0xCC, 0x00,
     0x66, 0x99, 0xCC, 0x00,
     0x33, 0x99, 0xCC, 0x00,
     0x00, 0x99, 0xCC, 0x00,
     0xFF, 0x66, 0xCC, 0x00,
     0xCC, 0x66, 0xCC, 0x00,
     0x99, 0x66, 0xCC, 0x00,
     0x66, 0x66, 0xCC, 0x00,
     0x33, 0x66, 0xCC, 0x00,
     0x00, 0x66, 0xCC, 0x00,
     0xFF, 0x33, 0xCC, 0x00,
     0xCC, 0x33, 0xCC, 0x00,
     0x99, 0x33, 0xCC, 0x00,
     0x66, 0x33, 0xCC, 0x00,
     0x33, 0x33, 0xCC, 0x00,
     0x00, 0x33, 0xCC, 0x00,
     0xFF, 0x08, 0xD4, 0x00,
     0xCC, 0x00, 0xCC, 0x00,
     0x99, 0x00, 0xCC, 0x00,
     0x66, 0x00, 0xCC, 0x00,
     0x33, 0x00, 0xCC, 0x00,
     0x00, 0x00, 0xCC, 0x00,
     0xFF, 0xFF, 0x99, 0x00,
     0xCC, 0xFF, 0x99, 0x00,
     0x99, 0xFF, 0x99, 0x00,
     0x66, 0xFF, 0x99, 0x00,
     0x33, 0xFF, 0x99, 0x00,
     0x00, 0xFF, 0x99, 0x00,
     0xFF, 0xCC, 0x99, 0x00,
     0xCC, 0xCC, 0x99, 0x00,
     0x99, 0xCC, 0x99, 0x00,
     0x66, 0xCC, 0x99, 0x00,
     0x33, 0xCC, 0x99, 0x00,
     0x00, 0xCC, 0x99, 0x00,
     0xFF, 0x99, 0x99, 0x00,
     0xCC, 0x99, 0x99, 0x00,
     0x99, 0x99, 0x99, 0x00,
     0x66, 0x99, 0x99, 0x00,
     0x33, 0x99, 0x99, 0x00,
     0x00, 0x99, 0x99, 0x00,
     0xFF, 0x66, 0x99, 0x00,
     0xCC, 0x66, 0x99, 0x00,
     0x99, 0x66, 0x99, 0x00,
     0x66, 0x66, 0x99, 0x00,
     0x33, 0x66, 0x99, 0x00,
     0x00, 0x66, 0xA1, 0x00,
     0xFF, 0x33, 0x99, 0x00,
     0xCC, 0x33, 0x99, 0x00,
     0x99, 0x33, 0x99, 0x00,
     0x66, 0x33, 0x99, 0x00,
     0x33, 0x33, 0x99, 0x00,
     0x00, 0x33, 0x99, 0x00,
     0xFF, 0x00, 0x99, 0x00,
     0xCC, 0x00, 0x99, 0x00,
     0x99, 0x00, 0x99, 0x00,
     0x66, 0x00, 0x99, 0x00,
     0x33, 0x00, 0x99, 0x00,
     0x00, 0x00, 0x99, 0x00,
     0xFF, 0xFF, 0x66, 0x00,
     0xCC, 0xFF, 0x66, 0x00,
     0x99, 0xFF, 0x66, 0x00,
     0x66, 0xFF, 0x66, 0x00,
     0x33, 0xFF, 0x66, 0x00,
     0x00, 0xFF, 0x66, 0x00,
     0xFF, 0xCC, 0x66, 0x00,
     0xCC, 0xCC, 0x66, 0x00,
     0x99, 0xCC, 0x66, 0x00,
     0x66, 0xCC, 0x66, 0x00,
     0x33, 0xCC, 0x66, 0x00,
     0x00, 0xCC, 0x66, 0x00,
     0xFF, 0x99, 0x66, 0x00,
     0xCC, 0x99, 0x66, 0x00,
     0x99, 0x99, 0x66, 0x00,
     0x66, 0x99, 0x66, 0x00,
     0x33, 0x99, 0x66, 0x00,
     0x00, 0x99, 0x66, 0x00,
     0xFF, 0x66, 0x66, 0x00,
     0xCC, 0x66, 0x66, 0x00,
     0x99, 0x66, 0x66, 0x00,
     0x66, 0x66, 0x66, 0x00,
     0x33, 0x66, 0x66, 0x00,
     0x00, 0x66, 0x66, 0x00,
     0xFF, 0x33, 0x66, 0x00,
     0xCC, 0x33, 0x66, 0x00,
     0x99, 0x33, 0x66, 0x00,
     0x66, 0x33, 0x66, 0x00,
     0x33, 0x33, 0x66, 0x00,
     0x00, 0x33, 0x66, 0x00,
     0xFF, 0x00, 0x66, 0x00,
     0xCC, 0x00, 0x66, 0x00,
     0x99, 0x00, 0x66, 0x00,
     0x66, 0x00, 0x66, 0x00,
     0x33, 0x00, 0x66, 0x00,
     0x00, 0x00, 0x66, 0x00,
     0xFF, 0xFF, 0x33, 0x00,
     0xCC, 0xFF, 0x33, 0x00,
     0x99, 0xFF, 0x33, 0x00,
     0x66, 0xFF, 0x33, 0x00,
     0x33, 0xFF, 0x33, 0x00,
     0x00, 0xFF, 0x33, 0x00,
     0xFF, 0xCC, 0x33, 0x00,
     0xCC, 0xCC, 0x33, 0x00,
     0x99, 0xCC, 0x33, 0x00,
     0x66, 0xCC, 0x33, 0x00,
     0x33, 0xCC, 0x33, 0x00,
     0x00, 0xCC, 0x33, 0x00,
     0xFF, 0x99, 0x33, 0x00,
     0xCC, 0x99, 0x33, 0x00,
     0x99, 0x99, 0x33, 0x00,
     0x66, 0x99, 0x33, 0x00,
     0x33, 0x99, 0x33, 0x00,
     0x00, 0x99, 0x33, 0x00,
     0xFF, 0x66, 0x33, 0x00,
     0xCC, 0x66, 0x33, 0x00,
     0x99, 0x66, 0x33, 0x00,
     0x66, 0x66, 0x33, 0x00,
     0x33, 0x6E, 0x33, 0x00,
     0x00, 0x66, 0x33, 0x00,
     0xFF, 0x33, 0x33, 0x00,
     0xCC, 0x33, 0x33, 0x00,
     0x99, 0x33, 0x33, 0x00,
     0x66, 0x33, 0x33, 0x00,
     0x3B, 0x33, 0x33, 0x00,
     0x00, 0x33, 0x33, 0x00,
     0xFF, 0x00, 0x33, 0x00,
     0xCC, 0x00, 0x33, 0x00,
     0x99, 0x00, 0x33, 0x00,
     0x66, 0x00, 0x33, 0x00,
     0x33, 0x00, 0x33, 0x00,
     0x00, 0x00, 0x33, 0x00,
     0xCC, 0xFF, 0x00, 0x00,
     0x99, 0xFF, 0x00, 0x00,
     0x66, 0xFF, 0x00, 0x00,
     0x33, 0xFF, 0x00, 0x00,
     0xFF, 0xCC, 0x00, 0x00,
     0xCC, 0xCC, 0x00, 0x00,
     0x99, 0xCC, 0x00, 0x00,
     0x66, 0xCC, 0x00, 0x00,
     0x33, 0xCC, 0x00, 0x00,
     0x00, 0xCC, 0x00, 0x00,
     0xFF, 0x99, 0x00, 0x00,
     0xCC, 0x99, 0x00, 0x00,
     0x99, 0x99, 0x00, 0x00,
     0x66, 0x99, 0x00, 0x00,
     0x33, 0x99, 0x00, 0x00,
     0x00, 0x99, 0x00, 0x00,
     0xFF, 0x66, 0x00, 0x00,
     0xCC, 0x66, 0x00, 0x00,
     0x99, 0x66, 0x00, 0x00,
     0x66, 0x66, 0x00, 0x00,
     0x33, 0x66, 0x00, 0x00,
     0x00, 0x66, 0x00, 0x00,
     0xFF, 0x33, 0x00, 0x00,
     0xCC, 0x33, 0x00, 0x00,
     0xA1, 0x33, 0x00, 0x00,
     0x66, 0x33, 0x00, 0x00,
     0x33, 0x33, 0x00, 0x00,
     0x00, 0x33, 0x00, 0x00,
     0xCC, 0x00, 0x00, 0x00,
     0x99, 0x00, 0x00, 0x00,
     0x66, 0x00, 0x00, 0x00,
     0x33, 0x00, 0x00, 0x00,
     0x00, 0x00, 0xEE, 0x00,
     0x00, 0x00, 0xDD, 0x00,
     0x00, 0x00, 0xAA, 0x00,
     0x00, 0x00, 0x90, 0x00,
     0x00, 0x00, 0x77, 0x00,
     0x00, 0x00, 0x55, 0x00,
     0x00, 0x00, 0x44, 0x00,
     0x00, 0x00, 0x22, 0x00,
     0x00, 0x00, 0x11, 0x00,
     0x00, 0xEE, 0x00, 0x00,
     0x00, 0xDD, 0x00, 0x00,
     0x00, 0xAA, 0x00, 0x00,
     0x00, 0x88, 0x00, 0x00,
     0x00, 0x77, 0x00, 0x00,
     0x00, 0x55, 0x00, 0x00,
     0x00, 0x44, 0x00, 0x00,
     0x00, 0x22, 0x00, 0x00,
     0x00, 0x11, 0x00, 0x00,
     0xEE, 0x00, 0x00, 0x00,
     0xDD, 0x00, 0x00, 0x00,
     0xAA, 0x00, 0x00, 0x00,
     0x88, 0x00, 0x00, 0x00,
     0x77, 0x00, 0x00, 0x00,
     0x55, 0x00, 0x00, 0x00,
     0x44, 0x00, 0x00, 0x00,
     0x22, 0x00, 0x00, 0x00,
     0x11, 0x00, 0x00, 0x00,
     0x30, 0x22, 0x22, 0x00,
     0x99, 0x99, 0xFF, 0x00,
     0xFF, 0xCC, 0xFF, 0x00,
     0xFF, 0xD4, 0x99, 0x00,
     0x99, 0xD4, 0x99, 0x00,
     0x99, 0xFF, 0xFF, 0x00,
     0xF0, 0xF0, 0xF0, 0x00,
     0xF0, 0xC8, 0xA4, 0x00,
     0xC0, 0xDC, 0xC0, 0x00,
     0xC0, 0xC0, 0xC0, 0x00,
     0xBF, 0xBF, 0x00, 0x00,
     0xBF, 0x00, 0xBF, 0x00,
     0xBF, 0x00, 0x00, 0x00,
     0x00, 0xBF, 0xBF, 0x00,
     0x00, 0xBF, 0x00, 0x00,
     0x00, 0x00, 0xBF, 0x00,
     0x00, 0x00, 0x00, 0x00,
 )


ONE_BYTE_OPCODES = [ 
    0x01, # exit            Leave the current function immediately and return to its caller. Automatically added as the final step of a function.
    0x02, # UNKNOWN
    0x03, # 0 or FALSE      Push zero onto the stack
    0x04, # (a * b)         Pop two values from the stack, multiply them together and push the result.
    0x05, # (a + b)         Pop two values from the stack, add them together and push the result.
    0x06, # (a - b)         Pop two values from the stack, subtract the second from the first and push the result.
    0x07, # (a / b)         Pop two values from the stack, divide the first by the second and push the result.
    0x08, # (a mod b)       Pop two values from the stack, perform a modulo operation and push the result.
    0x09, # (-a)            Pop one value from the stack, negate it and push the result.
    0x0A, # (a & b)         Pop two values from the stack, concatenate them and push the resulting string.
    0x0B, # (a && b)        Pop two values from the stack, concatenate them with one space character added in between, and push the resulting string.
    0x0C, # (a < b)         Pop two values from the stack, push 1 if the first is less than the second and 0 if not.
    0x0D, # (a <= b)        Pop two values from the stack, push 1 if the first is less than or equal to the second and 0 if not.
    0x0E, # (a <> b)        Pop two values from the stack, push 0 if the two values are the same and 1 if they are not.
    0x0F, # (a = b)         Pop two values from the stack, push 1 if the two values are the same and 0 if they are not.
    0x10, # (a > b)         Pop two values from the stack, push 1 if the first is greater than the second and 0 if not.
    0x11, # (a >= b)        Pop two values from the stack, push 1 if the first is greater than or equal to the sceond and 0 if not.
    0x12, # (a and b)       Pop two values from the stack, push 1 if both are logically true and 0 if not.
    0x13, # (a or b)        Pop two values from the stack, push 1 if either are logically true and 0 if not.
    0x14, # (not a)         Pop one value from the stack, push 0 if it is logically true and 1 if not.
    0x15, # (a contains b)  Pop two values from the stack, push 1 if the first is a string that contains the second and 0 if not.
          #                 The text comparison is case-insensitive and ignores diacritic marks.
    0x16, # (a starts b)    Pop two values from the stack, push 1 if the first is a string that begins with second string and 0 if not.
          #                 The text comparison is case-insensitive and ignores diacritic marks.
    0x17, # (split op)      String slice/split operation.
    0x18, # (hilite op)     Highlight (select) some text.
    0x19, # (sprite 1 intersects 2)  Pop two sprite IDs and push 1 if the bounding rectangles of the two sprites touch at all, or 0 if they do not.
    0x1A, # (sprite 1 within 2) Pop two sprite IDs and push 1 if the bounding rectangle of the first is entirely inside the bounding rectangle of the second, or 0 if not.
    0x1B, # (field 1)       Pop a cast ID (name or number), push the value of that cast member's text property.
    0x1C, # tell someObject to go to frame 1   Pop an object from the stack and begin running subsequent bytecodes in the context of that object, until code 1D is encountered.
    0x1D, # tell someObject to go to frame 1   Marker for the end of a sequence of bytecodes started by 1C. Similar to 01 except for nested bytecode chunks instead of the main one.
    0x1E, # UNKNOWN         Some kind of list transformation or check, seen used just before setting the actorList to []. More research is needed to know exactly what is happening there.
    0x1F  # [#key: value]   Pops a list that must be in the form [#symbol1, val1, #symbol2, val2 ...] to transform into [#symbol1: val1, #symbol2: val2 ...]

]

TWO_BYTE_OPCODES = [
    0x41, # push <int>      Push integer of value XX, which must be between 1 and 127, inclusive. To push zero, use 03. To push larger integers, use 81 XX YY.
    0x42, # push <nargs>    Pop the specified number of values off the top of the stack, create an unparenthesized argument list containing them (i.e. for a call statement like myFunction 1, 2, 3), and push that to the stack.
    0x43, # push <list>     op the specified number of values off the top of the stack, create a list for them (which can also be used for a parenthesized call expression like set result = myFunction(1, 2, 3)), 
          #                 and push that to the stack.
    0x44, # push <const>    Push a constant from local constant records onto the stack. These records seem to be six bytes long (regardless of the actual size of the constant value), 
          #                 so pushing the first one is 44 00, the second is 44 06, the third is 44 0C, etc. To push the 65th one and beyond use code 84 YY ZZ
    0x45, # push <sym>      Push a symbol with a name from namelist[XX]. Note that the name will be stored as "name", not "#name".
    0x46, # push <object>   Push a object with a name from namelist[XX]. See also code 86.
    0x47, # UNKNOWN
    0x48, # UNKNOWN
    0x49, # push <global>   Push the value of a global variable with a name from namelist[XX].
    0x4A, # push <prop>     Push the value of a property
    0x4B, # push <param>    Push the value of a function call parameter. The parameter records seem to be 6 bytes long, so the first is pushed with 4B 00, the second with 4B 06, etc.
    0x4C, # push <local>    Push the value of a local variable. The local variable records seem to be 6 bytes long, so the first is pushed with 4C 00, the second with 4C 06, etc.
    0x4D, # UNKNOWN
    0x4E, # UNKNOWN
    0x4F, # set <global>    Pop one value and use it to set the global variable with name from namelist[XX].
    0x50, # set <prop>      Pop one value and use it to set a property.
    0x51, # set <param>     Pop one value and use it to set a parameter.
    0x52, # set <local>     Pop one value and use it to set a local variable. See code 4C 00 for a note about local variable records.
    0x53, # UNKNOWN
    0x54, # end repeat      Unconditional backwards jump by XX bytes, relative to the first byte of this instruction.
    0x55, # UNKNOWN
    0x56, # call <localfn>  Call a function defined in this script with the name at namelist[XX]. 
          #                 The top value on the stack must be an argument list. If the argument list was created with code 43 XX, one return value will be pushed to the stack. 
          #                 If the argument list was created with code 42 XX, no return value will be pushed.
    0x57, # call <globfn>   Call the external function with name from namelist[XX].
    0x58, # call <obj, met> Pop [argument list, call target] to make a method call. If the call target is a literal number, this indicates a local variable is the target. 
          #                 It must be divided by six to get the actual local variable number. The first argument of the argument list will be a symbol with the name of the method. 
          #                 Note: It is still unclear what difference the value of XX makes. It has been seen as 0x01 and 0x05. More research is needed to know more. (Possibly local variables vs. call parameters?)

    0x59, # UNKNOWN
    0x5A, # UNKNOWN
    0x5B, # UNKNOWN
    0x5C, # UNKNOWN
    0x5D, # UNKNOWN
    0x5E, # UNKNOWN
    0x5F, # UNKNOWN
    0x60, # UNKNOWN
    0x61, # UNKNOWN
    0x62, # UNKNOWN
    0x63, # UNKNOWN
    0x64, # UNKNOWN
    0x65,  # UNKNOWN
    0x66  # UNKNOWN

]


THREE_BYTE_OPCODES = [
    0x81, # UNKNOWN
    0x82, # UNKNOWN
    0x83, # UNKNOWN
    0x84, # UNKNOWN
    0x89, # UNKNOWN
    0x8F, # UNKNOWN
    0x90, # UNKNOWN
    0x93, # UNKNOWN
    0x95, # UNKNOWN
    0xa0, # UNKNOWN
    0xa1, # UNKNOWN
    0xa2, # UNKNOWN
    0xa6  # UNKNOWN
]

NO_PAREN_FUNCTIONS = [
    'put',
    'window',
    'forget',
    'alert'
]

SPECIAL_CONSTANTS = {
    '""': 'empty',
    '"\\r"': 'return',
    '"\\""': 'quote'
}

operations_stack = []


# ====================================================================================================================================
def clear_stack():
    operations_stack = []

# ====================================================================================================================================
def push(value):
    operations_stack.append(value)

def pop():
    if len(operations_stack) <= 0:
        return None

    return operations_stack.pop()


def pop_s():
    val = pop()
    if val is None:
        val = 'ERROR_EMPTY_STACK'
    return val

def flush_stack(f, spacing):
    op = pop()
    while op is not None:
        f.write("\n")
        f.write(spacing)
        f.write("%s"%(op))
        op = pop()

    f.write("\n")

# ====================================================================================================================================
def to_string(strval):
    strval = strval.replace("\\", "\\\\")
    strval = strval.replace("\"", "\\\"")
    strval = strval.replace("\a", "\\a")
    strval = strval.replace("\b", "\\b")
    strval = strval.replace("\f", "\\f")
    strval = strval.replace("\n", "\\n")
    strval = strval.replace("\r", "\\r")
    strval = strval.replace("\t", "\\t")
    strval = strval.replace("\v", "\\v")
    return '"' + strval + '"'


# ====================================================================================================================================
def parse_imap(data):
    # Unknown block data
    content = struct.unpack(bit_order+"hhiiiii", data)
    print("IMAP[0]: %s"%(content[0]))
    print("IMAP[1]: %s"%(content[1]))
    print("IMAP[2]: %s"%(content[2]))
    print("IMAP[3]: %s"%(content[3]))
    print("IMAP[4]: %s"%(content[4]))
    print("IMAP[5]: %s"%(content[5]))
    print("IMAP[6]: %s"%(content[6]))

# ====================================================================================================================================
def save_4bit_bmp(bmp_width, bmp_height, file, previous_clut, fdata):
    bmp_bpp = 4
    values = (bmp_width*bmp_height+(16*4)+40+14, # The size of the BMP file in bytes
              0, # Reserved
              0, # Reserved
              ((16*4)+40+14) # Data offset
             )
    s = struct.Struct('<ihhi')
    packed_data = s.pack(*values)
    file.write(packed_data)

    ncolors = 16

    # Write BITMAPINFOHEADER
    values = (40, # the size of this header (40 bytes)
              bmp_width, # the bitmap width in pixels (signed integer)
              bmp_height, # the bitmap height in pixels (signed integer)
              1, # the number of color planes (must be 1)
              bmp_bpp, # the number of bits per pixel, which is the color depth of the image. Typical values are 1, 4, 8, 16, 24 and 32.
              0, # the compression method being used
              0, # the image size. This is the size of the raw bitmap data; a dummy 0 can be given for BI_RGB bitmaps.
              0, # the horizontal resolution of the image. (pixel per meter, signed integer)
              0, # the vertical resolution of the image. (pixel per meter, signed integer)
              ncolors, # the number of colors in the color palette, or 0 to default to 2n
              ncolors  # the number of important colors used, or 0 when every color is important; generally ignored
             )
    s = struct.Struct('<iiihhiiiiii')
    packed_data = s.pack(*values)
    file.write(packed_data)

    # Write the color palette
    if previous_clut is not None:
        s = struct.Struct('B'*(ncolors*4))
        packed_data = s.pack(*previous_clut[0:(ncolors*4)])
        file.write(packed_data)

    else:
        # Default windows 16 colors palete
        s = struct.Struct('B'*(ncolors*4))
        if sys.argv[1] == 'pc':
            packed_data = s.pack(*DEFAULT_WINDOWS_16COLORS_PALETTE)
        else:
            packed_data = s.pack(*DEFAULT_MAC_16COLORS_PALETTE)

        file.write(packed_data)

    # get the pixel information
    # RLE encoded bytes contains 2 pixel colors
    w = (bmp_width/2)

    imgdata = [0 for x in range(w*bmp_height)]
    x = 0
    y = bmp_height - 1
    idx = 8
    while (idx < len(fdata)) and (y>=0):
        val = struct.unpack("B", fdata[idx])[0]
        if (val & 0x80) != 0:
            # RLE encoded
            run_length = 257 - val
            run_value = struct.unpack("B", fdata[idx+1])[0]
            idx = idx + 2
            for i in range(0, run_length):
                imgdata[y*w + x] = run_value
                x += 1
                if x >= w:
                    x = 0
                    y -= 1
            

        elif val != 0:
            # Not RLE encoded
            run_length = (val + 1)
            idx = idx + 1
            for i in range(0, run_length):
                imgdata[y*w + x] = struct.unpack("B", fdata[idx])[0]
                idx = idx + 1
                x += 1
                if x >= w:
                    x = 0
                    y -= 1

        else: # val is zero
            run_value = struct.unpack("B", fdata[idx+1])[0]
            idx = idx + 2

            imgdata[y*w + x] = run_value
            x += 1
            if x >= w:
                x = 0
                y -= 1

    if y!=-1 or x!=0:
        print("WARNING: Not enought data to decode. Probably the image is not properly generated. (y=%s, x=%s)"%(y, x))

    if idx != len(fdata):
        print("WARNING: there is more data to decode. Probably the image is not properly generated. (%s != %s)"%(idx, len(fdata)))


    # Write the pixel information
    file.write(struct.pack("B"*(w*bmp_height), *imgdata))
    file.close()

# ====================================================================================================================================
def save_8bit_bmp(bmp_width, bmp_height, bmp_wlimit, file, previous_clut, fdata):
    bmp_bpp = 8
    values = (bmp_width*bmp_height+(256*4)+40+14, # The size of the BMP file in bytes
              0, # Reserved
              0, # Reserved
              ((256*4)+40+14) # Data offset
             )
    s = struct.Struct('<ihhi')
    packed_data = s.pack(*values)
    file.write(packed_data)

    ncolors = 256

    # Write BITMAPINFOHEADER
    values = (40, # the size of this header (40 bytes)
              bmp_width, # the bitmap width in pixels (signed integer)
              bmp_height, # the bitmap height in pixels (signed integer)
              1, # the number of color planes (must be 1)
              bmp_bpp, # the number of bits per pixel, which is the color depth of the image. Typical values are 1, 4, 8, 16, 24 and 32.
              0, # the compression method being used
              0, # the image size. This is the size of the raw bitmap data; a dummy 0 can be given for BI_RGB bitmaps.
              0, # the horizontal resolution of the image. (pixel per meter, signed integer)
              0, # the vertical resolution of the image. (pixel per meter, signed integer)
              ncolors, # the number of colors in the color palette, or 0 to default to 2n
              ncolors  # the number of important colors used, or 0 when every color is important; generally ignored
             )
    s = struct.Struct('<iiihhiiiiii')
    packed_data = s.pack(*values)
    file.write(packed_data)

    # Write the color palette
    if previous_clut is not None:
        s = struct.Struct('B'*(256*4))
        packed_data = s.pack(*previous_clut)
        file.write(packed_data)

    else:
        # Default windows 256 colors palete
        s = struct.Struct('B'*(256*4))
        if sys.argv[1] == 'pc':
            packed_data = s.pack(*DEFAULT_WINDOWS_256COLORS_PALETTE)
        else:
            packed_data = s.pack(*DEFAUL_MAC_256COLORS_PALETTE)

        file.write(packed_data)

    # get the pixel information
    # RLE encoded bytes contains 1 pixel color
    w = bmp_width

    if (len(fdata)-8) == w*bmp_height:
        print("The size of the data matches the image resolution. Not RLE compressed!")
        # Write the pixel information
        y = bmp_height - 1
        while y>=0:
            idx = 8 + y*w
            file.write(fdata[idx:(idx+w)])
            y -= 1
        file.close()
        return


    imgdata = [0 for x in range(w*bmp_height)]
    x = 0
    y = bmp_height - 1
    idx = 8
    previous_encoded = True
    previous_run_length = 0
    while (idx < len(fdata)) and (y>=0):
        val = struct.unpack("B", fdata[idx])[0]
        if (val & 0x80) != 0:
            # RLE encoded
            run_length = 257 - val
            if idx+1 >= len(fdata):
                print("ERROR: Unexpected end of data! (data length=%s)"%(len(fdata)))
                break
            run_value = struct.unpack("B", fdata[idx+1])[0]
            idx = idx + 2

            # Jump to next row when necessary
            if ((x + run_length) > bmp_wlimit):
                x = 0
                y -= 1

            if y < 0:
                break

            for i in range(0, run_length):
                imgdata[y*w + x] = run_value
                x += 1
                if x >= w:
                    x = 0
                    y -= 1
                    if y < 0:
                        break
            
            previous_encoded = True
            previous_run_length = run_length

        else:
            # Not RLE encoded
            run_length = val + 1
            idx = idx + 1
            if idx >= len(fdata):
                print("ERROR: Bad run length! (value=%s)"%(run_length))
                break

            # Jump to next row when necessary
            if ((x + run_length) > bmp_wlimit) or ( not previous_encoded and (run_length+previous_run_length) < 128 ):
                # (not previous_encoded and (run_length+previous_run_length) < 128) condition
                # detects when there is something like:
                #   00 AA 00 BB
                #
                # Because that could be compressed as:
                #   01 AA BB
                #
                # And that means that [00 BB] must be at the begining of a new line
                previous_encoded = True
                previous_run_length = 0

                x = 0
                y -= 1

            else:
                previous_encoded = False
                previous_run_length = run_length


            if y < 0:
                break

            for i in range(0, run_length):
                imgdata[y*w + x] = struct.unpack("B", fdata[idx])[0]
                idx = idx + 1
                if idx >= len(fdata):
                    print("ERROR: Bad run length! (value=%s)"%(run_length))
                    break

                x += 1
                if x >= w:
                    previous_encoded = True
                    previous_run_length = 0

                    x = 0
                    y -= 1
                    if y < 0:
                        break



    if y!=-1 or x!=0:
        print("WARNING: Not enought data to decode. Probably the image is not properly generated. (y=%s, x=%s)"%(y, x))

    if idx != len(fdata):
        print("WARNING: there is more data to decode. Probably the image is not properly generated. (%s != %s)"%(idx, len(fdata)))

    # Write the pixel information
    file.write(struct.pack("B"*(bmp_width*bmp_height), *imgdata))
    file.close()

# ====================================================================================================================================
def save_16bit_bmp(bmp_width, bmp_height, file, fdata):
    bmp_bpp = 16
    hsize = 124
    values = (bmp_width*bmp_height*2+hsize+14, # The size of the BMP file in bytes
              0, # Reserved
              0, # Reserved
              (hsize+14) # Data offset
             )
    s = struct.Struct('<ihhi')
    packed_data = s.pack(*values)
    file.write(packed_data)

    # Write BITMAPINFOHEADER
    values = (hsize, # the size of this header (hsize bytes)
              bmp_width, # the bitmap width in pixels (signed integer)
              bmp_height, # the bitmap height in pixels (signed integer)
              1, # the number of color planes (must be 1)
              bmp_bpp, # the number of bits per pixel, which is the color depth of the image. Typical values are 1, 4, 8, 16, 24 and 32.
              3, # the compression method being used (BI_BITFIELDS)
              0, # the image size. This is the size of the raw bitmap data; a dummy 0 can be given for BI_RGB bitmaps.
              0, # the horizontal resolution of the image. (pixel per meter, signed integer)
              0, # the vertical resolution of the image. (pixel per meter, signed integer)
              0, # the number of colors in the color palette, or 0 to default to 2n
              0, # the number of important colors used, or 0 when every color is important; generally ignored
              0x00007C00, # Red channel bitmask
              0x000003E0, # Green channel bitmask
              0x0000001F, # Blue channel bitmask
              0x00000000, # Alpha channel bitmask
              0x73524742, # "BGRs"
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, # CIEXYZTRIPLE Color Space endpoints
              0, # Red Gamma
              0, # Green Gamma
              0, # Blue Gamma
             )
    s = struct.Struct('<iiihhIIIIIIIIIIIIIIIIIIIIIIIIIII')
    packed_data = s.pack(*values)
    file.write(packed_data)

    # get the pixel information
    # RLE encoded bytes are:
    #   - RLE encoded lower byte
    #   - RLE encoded upper byte

    w = bmp_width*2
    h = bmp_height

    imgdata = [0 for x in range(w*bmp_height)]
    x = 0
    y = bmp_height - 1
    idx = 8
    while (idx < len(fdata)) and (y>=0):
        val = struct.unpack("B", fdata[idx])[0]
        if (val & 0x80) != 0:
            # RLE encoded
            run_length = 257 - val
            run_value = struct.unpack("B", fdata[idx+1])[0]
            idx = idx + 2

            # Jump to next byte when necessary
            if ((x + run_length) > bmp_width) and (x < bmp_width):
                x = bmp_width

            # Jump to next row when necessary
            if ((x + run_length) > w):
                x = 0
                y -= 1

            for i in range(0, run_length):
                imgdata[y*w + x] = run_value
                x += 1
            

        else:
            # Not RLE encoded
            run_length = val + 1
            idx = idx + 1

            # Jump to next byte when necessary
            if ((x + run_length) > bmp_width) and (x < bmp_width):
                x = bmp_width

            # Jump to next row when necessary
            if ((x + run_length) > w):
                x = 0
                y -= 1

            for i in range(0, run_length):
                imgdata[y*w + x] = struct.unpack("B", fdata[idx])[0]
                idx = idx + 1
                x += 1
                if x >= w:
                    x = 0
                    y -= 1

    if y!=0 or x!=w:
        print("WARNING: Not enought data to decode. Probably the image is not properly generated. (y=%s, x=%s)"%(y, x))

    if idx != len(fdata):
        print("WARNING: there is more data to decode. Probably the image is not properly generated. (%s != %s)"%(idx, len(fdata)))


    # Order lower and upper bytes
    imgdatamix = [0 for x in range(bmp_width*2*bmp_height)]
    w2 = bmp_width*2
    w1 = bmp_width
    w0 = 0
    for y in range(0, bmp_height):
        yw1 = y*w1
        yw2 = y*w2
        for x in range(0, bmp_width):
            imgdatamix[yw2 + x*2 + 0] = imgdata[yw2 + w1 + x]  # Upper
            imgdatamix[yw2 + x*2 + 1] = imgdata[yw2 + w0 + x]  # Lower

    # Write the pixel information
    file.write(struct.pack("B"*(bmp_width*2*bmp_height), *imgdatamix))
    file.close()

# ====================================================================================================================================
def save_24bit_bmp(bmp_width, bmp_height, file, fdata):
    bmp_bpp = 24
    values = (bmp_width*bmp_height*3+40+14, # The size of the BMP file in bytes
              0, # Reserved
              0, # Reserved
              (40+14) # Data offset
             )
    s = struct.Struct('<ihhi')
    packed_data = s.pack(*values)
    file.write(packed_data)

    ncolors = 0

    # Write BITMAPINFOHEADER
    values = (40, # the size of this header (40 bytes)
              bmp_width, # the bitmap width in pixels (signed integer)
              bmp_height, # the bitmap height in pixels (signed integer)
              1, # the number of color planes (must be 1)
              bmp_bpp, # the number of bits per pixel, which is the color depth of the image. Typical values are 1, 4, 8, 16, 24 and 32.
              0, # the compression method being used
              0, # the image size. This is the size of the raw bitmap data; a dummy 0 can be given for BI_RGB bitmaps.
              0, # the horizontal resolution of the image. (pixel per meter, signed integer)
              0, # the vertical resolution of the image. (pixel per meter, signed integer)
              ncolors, # the number of colors in the color palette, or 0 to default to 2n
              ncolors  # the number of important colors used, or 0 when every color is important; generally ignored
             )
    s = struct.Struct('<iiihhiiiiii')
    packed_data = s.pack(*values)
    file.write(packed_data)

    # get the pixel information
    # RLE encoded bytes are:
    #   - RLE encoded Alpha channel for 1 row
    #   - RLE encoded Blue channel for 1 row
    #   - RLE encoded Green channel for 1 row
    #   - RLE encoded Red channel for 1 row

    w = bmp_width*4
    h = bmp_height

    imgdata = [0 for x in range(w*bmp_height)]
    x = 0
    y = bmp_height - 1
    idx = 8
    while (idx < len(fdata)) and (y>=0):
        val = struct.unpack("B", fdata[idx])[0]
        if (val & 0x80) != 0:
            # RLE encoded
            run_length = 257 - val
            run_value = struct.unpack("B", fdata[idx+1])[0]
            idx = idx + 2
            for i in range(0, run_length):
                imgdata[y*w + x] = run_value
                x += 1
                if x >= w:
                    x = 0
                    y -= 1
            

        elif val != 0:
            # Not RLE encoded
            run_length = val + 1
            idx = idx + 1
            for i in range(0, run_length):
                imgdata[y*w + x] = struct.unpack("B", fdata[idx])[0]
                idx = idx + 1
                x += 1
                if x >= w:
                    x = 0
                    y -= 1

        else: # val is zero
            run_value = struct.unpack("B", fdata[idx+1])[0]
            idx = idx + 2
            imgdata[y*w + x] = run_value
            x += 1
            if x >= w:
                x = 0
                y -= 1

    if y!=-1 or x!=0:
        print("WARNING: Not enought data to decode. Probably the image is not properly generated. (y=%s, x=%s)"%(y, x))

    if idx != len(fdata):
        print("WARNING: there is more data to decode. Probably the image is not properly generated. (%s != %s)"%(idx, len(fdata)))


    # Order RGB bytes and discard Alpha channel
    imgdatamix = [0 for x in range(bmp_width*3*bmp_height)]
    w4 = bmp_width*4
    w3 = bmp_width*3
    w2 = bmp_width*2
    w1 = bmp_width
    w0 = 0
    for y in range(0, bmp_height):
        yw4 = y*w4
        yw3 = y*w3
        for x in range(0, bmp_width):
            imgdatamix[yw3 + x*3 + 0] = imgdata[yw4 + w3 + x]  # Red
            imgdatamix[yw3 + x*3 + 1] = imgdata[yw4 + w2 + x]  # Green
            imgdatamix[yw3 + x*3 + 2] = imgdata[yw4 + w1 + x]  # Blue

    # Write the pixel information
    file.write(struct.pack("B"*(bmp_width*3*bmp_height), *imgdatamix))
    file.close()

# ====================================================================================================================================
def parse_mmap(data, fileContent, offset):
    # This file types will be ignored
    types_to_ignore = [IMAP_FILE_FORMAT, MMAP_FILE_FORMAT, FREE_FILE_FORMAT, THUM_FILE_FORMAT]

    # Unknown block data
    content = struct.unpack(bit_order+"hhiiiii", data[0:24])
    print("MMAP[0]: %s"%(content[0]))
    print("MMAP[1]: %s"%(content[1]))
    # Number Of Files (including nulls at the end of the directory)
    no_files_wnull = content[2]
    # Number Of Files (not including the nulls at the end of the directory)
    no_files_wonull = content[3]
    print("MMAP: Number of files (including nulls) %s"%(no_files_wnull))
    print("MMAP: Number of files (without nulls) %s"%(no_files_wonull))
    # Padding
    if content[4] != -1 or content[5] != -1:
        print("ERROR: Bad nmap padding %s %s"%(content[4], content[5]))
        sys.exit(-1)        

    print("MMAP[6]: %s"%(content[6]))

    # Ignore RIFX file data
    file_format = struct.unpack("cccc", data[24:28])
    file_format = ('%c%c%c%c'%(file_format[0], file_format[1], file_format[2], file_format[3]))
    print("MMAP: Meta file: %s"%(file_format))
    if RIFX_FILE_FORMAT != file_format:
        print("ERROR: nmap internal format is not %s"%(RIFX_FILE_FORMAT))
        sys.exit(-1)

    # Read file length
    file_length = struct.unpack(bit_order+"i", data[28:32])[0]
    print("NMAP: Meta file length (must be the whole data length): %s"%(file_length))
    if len(fileContent) != file_length + 8 + offset:
        print("ERROR: Bad file length!")
        sys.exit(-1)

    # Read file offset
    file_offset = struct.unpack(bit_order+"i", data[32:36])[0]
    print("NMAP: Meta file offset: %s"%(file_offset))
    if file_offset != 0 and file_offset != offset:
        print("ERROR: Bad file offset!")
        sys.exit(-1)

    # Unknown
    unknown0 = struct.unpack(bit_order+"i", data[36:40])[0]
    print("NMAP: Unknown 0: %s"%(unknown0))

    unknown1 = struct.unpack(bit_order+"i", data[40:44])[0]
    print("NMAP: Unknown 1: %s"%(unknown1))

    name_list = []

    # Look for list of names
    index = 44
    while index < len(data):
        # Read file format
        file_format = struct.unpack("cccc", data[index:(index+4)])
        file_format = ('%c%c%c%c'%(file_format[0], file_format[1], file_format[2], file_format[3]))

        # Read file length
        file_length = struct.unpack(bit_order+"i", data[(index+4):(index+8)])[0]

        # Read file offset
        file_offset = struct.unpack(bit_order+"i", data[(index+8):(index+12)])[0]

        # Unknown
        unknown0 = struct.unpack(bit_order+"i", data[(index+12):(index+16)])[0]

        unknown1 = struct.unpack(bit_order+"i", data[(index+16):(index+20)])[0]

        # -------------------------- Lnam ------------------------------------------------------------------
        if (file_format == LNAM_FILE_FORMAT):
            print('Getting names from Lnam file')

            lnam_bit_order = '>'

            fdata = fileContent[file_offset:(file_offset+file_length+8)]

            # Skip file size and length
            indx = 8

            # Unknown header data
            unk = struct.unpack(lnam_bit_order+"i", fdata[(indx):(indx+4)])[0]
            indx = indx + 4
            print "Unknown: %08x"%(unk)

            unk = struct.unpack(lnam_bit_order+"i", fdata[(indx):(indx+4)])[0]
            indx = indx + 4
            print "Unknown: %08x"%(unk)

            filesize = struct.unpack(lnam_bit_order+"i", fdata[(indx):(indx+4)])[0]
            indx = indx + 4
            print "filesize: %08x"%(filesize)

            filesize_cp = struct.unpack(lnam_bit_order+"i", fdata[(indx):(indx+4)])[0]
            indx = indx + 4
            print "filesize_cp: %08x"%(filesize_cp)

            unk = struct.unpack(lnam_bit_order+"h", fdata[(indx):(indx+2)])[0]
            indx = indx + 2
            print "Unknown: %08x"%(unk)            

            nnames = struct.unpack(lnam_bit_order+"h", fdata[(indx):(indx+2)])[0]
            indx = indx + 2
            print "Number of names: %s"%(nnames)            


            if filesize_cp != filesize:
                print("ERROR: Bad file size! (%s != %s)"%(filesize_cp, filesize))
                sys.exit(-1)


              
            for i in range(0, nnames):
                nbytes = ord(fdata[indx])
                indx = indx + 1

                name = fdata[indx:(indx + nbytes)]
                indx = indx + nbytes
                
                name_list.append(name)
                print("DEBUG: name_list[%s] = %s"%(i, name))
                

        index = index + 20

    # Extract file contents
    index = 44
    nfiles = 1
  
    # Default values
    previous_clut = None
    bmp_file_name = None
    bmp_width = 0
    bmp_height = 0
    bmp_bpp = 0

    snd_file_name = None
    while index < len(data) and nfiles < no_files_wonull:
        print("---------------------------------------")
        print("FILE: Number: %s"%(nfiles))

        # Read file format
        file_format = struct.unpack("cccc", data[index:(index+4)])
        file_format = ('%c%c%c%c'%(file_format[0], file_format[1], file_format[2], file_format[3]))
        print("FILE: File format: %s"%(file_format))

        # Read file length
        file_length = struct.unpack(bit_order+"i", data[(index+4):(index+8)])[0]
        print("FILE: Length: %s"%(file_length))

        # Read file offset
        file_offset = struct.unpack(bit_order+"i", data[(index+8):(index+12)])[0]
        print("FILE: Offset: %s"%(file_offset))

        # Unknown
        unknown0 = struct.unpack(bit_order+"i", data[(index+12):(index+16)])[0]
        print("FILE: Unknown 0: %s"%(unknown0))

        unknown1 = struct.unpack(bit_order+"i", data[(index+16):(index+20)])[0]
        print("FILE: Unknown 1: %s"%(unknown1))

        if (file_format in types_to_ignore) or (file_length == 0):
            print("FILE: Empty file data or must ignore file!")


        # -------------------------- KEY* ------------------------------------------------------------------
        elif (file_format == KEY_FILE_FORMAT):
            file_ext = "KEY"
            file_name = "%s.%s"%(nfiles, file_ext)

            print(u"FILE: Saving KEY file to: %s"%(file_name))

            with open(os.path.join(sys.argv[3], file_name), 'wb') as file:
                fdata = fileContent[file_offset:(file_offset+file_length+8)]

                # Skip file size and length
                indx = 8

                # Unknown header data
                unk = struct.unpack(bit_order+"i", fdata[(indx):(indx+4)])[0]
                indx = indx + 4
                print "Unknown: %08x"%(unk)

                unk = struct.unpack(bit_order+"i", fdata[(indx):(indx+4)])[0]
                indx = indx + 4
                print "Unknown: %08x"%(unk)

                unk = struct.unpack(bit_order+"i", fdata[(indx):(indx+4)])[0]
                indx = indx + 4
                print "Unknown: %08x"%(unk)

                unk = struct.unpack(bit_order+"i", fdata[(indx):(indx+4)])[0]
                indx = indx + 4
                print "Unknown: %08x"%(unk)

                unk = struct.unpack(bit_order+"i", fdata[(indx):(indx+4)])[0]
                indx = indx + 4
                print "Unknown: %08x"%(unk)

                
                while len(fdata) >= indx + 12:
                    file_ext = struct.unpack("cccc", fdata[indx:indx+4])
                    file_ext = ('%c%c%c%c'%(file_ext[0], file_ext[1], file_ext[2], file_ext[3]))
                    if sys.argv[1] == 'pc':
                        file_ext = file_ext[3] + file_ext[2] + file_ext[1] + file_ext[0]

                    nfile = struct.unpack(bit_order+"i", fdata[(indx+4):(indx+8)])[0]
                    cas_index = struct.unpack(bit_order+"i", fdata[(indx+8):(indx+12)])[0]

                    indx = indx + 12

                    if nfile > 0:
                        key_value = "%s.%s, %08x\n"%(nfile, file_ext, cas_index)
                        file.write(key_value)

                file.close()

        # -------------------------- CAS* ------------------------------------------------------------------
        elif (file_format == CAS_FILE_FORMAT):
            file_ext = "CAS"
            file_name = "%s.%s"%(nfiles, file_ext)

            print(u"FILE: Saving CAS file to: %s"%(file_name))

            with open(os.path.join(sys.argv[3], file_name), 'wb') as file:
                fdata = fileContent[file_offset:(file_offset+file_length+8)]

                # Skip file size and length
                indx = 8

                while len(fdata) >= indx + 4:
                    cas_index = struct.unpack(">i", fdata[(indx):(indx+4)])[0]
                    indx = indx + 4
                    key_value = "%08x\n"%(cas_index)
                    file.write(key_value)

                file.close()

        # -------------------------- CLUT ------------------------------------------------------------------
        elif (file_format == CLUT_FILE_FORMAT):
            # Save clut for BMP creation
            fdata = fileContent[file_offset:(file_offset+file_length+8)]

            # Read data format
            data_format = struct.unpack("cccc", fdata[0:4])
            data_format = ('%c%c%c%c'%(data_format[0], data_format[1], data_format[2], data_format[3]))
            if data_format != file_format:
                print("ERROR: Bad data format! (%s != %s)"%(data_format, file_format))
                sys.exit(-1)

            if len(fdata)<8:
                print("WARNING: Creating empty file!")
                file.close()
                index = index + 20
                nfiles = nfiles + 1
                continue

            # Read file length
            data_length = struct.unpack(bit_order+"i", fdata[4:8])[0]
            if data_length != file_length:
                print("ERROR: Bad data length! (%s != %s)"%(data_length, file_length))
                sys.exit(-1)

            idx = 8
            previous_clut = () 

            while (idx+5) < len(fdata):
                previous_clut += (struct.unpack("B", fdata[idx+5])[0],) # Red
                previous_clut += (struct.unpack("B", fdata[idx+3])[0],) # Green
                previous_clut += (struct.unpack("B", fdata[idx+1])[0],) # Blue
                previous_clut += (0,)            # Alpha
                idx = idx + 6

            while len(previous_clut) < (256*4):
                previous_clut += (0, 0, 0, 0) # Black


        # -------------------------- CASt ------------------------------------------------------------------
        elif (file_format == CAST_FILE_FORMAT):     
            # Save cast info for a later use
            fdata = fileContent[file_offset:(file_offset+file_length+8)]

            # Read data format
            data_format = struct.unpack("cccc", fdata[0:4])
            data_format = ('%c%c%c%c'%(data_format[0], data_format[1], data_format[2], data_format[3]))
            if data_format != file_format:
                print("ERROR: Bad data format! (%s != %s)"%(data_format, file_format))
                sys.exit(-1)

            if len(fdata)<8:
                print("WARNING: Creating empty file!")
                file.close()
                index = index + 20
                nfiles = nfiles + 1
                continue

            # Read file length
            data_length = struct.unpack(bit_order+"i", fdata[4:8])[0]
            if data_length != file_length:
                print("ERROR: Bad data length! (%s != %s)"%(data_length, file_length))
                sys.exit(-1)

            # Parse cast data
            idx = 8
            cast_bit_order = '>'
            data_type = struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
            idx += 4

            print("DEBUG: data_type = %s"%(data_type)) 
            bmp_file_name = None
            if data_type == DIR5_IMAGE_TYPE: # --------------------------------------------------------------------------------------
                print("Reading image data...")
                unknown_00 = struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
                idx += 4
                unknown_01 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
                idx += 4
                unknown_02 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
                idx += 4
                unknown_03 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
                idx += 4
                unknown_04 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
                idx += 4
                unknown_05 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
                idx += 4
                unknown_06 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
                idx += 4
                unknown_07 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
                idx += 4
                unknown_08 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
                idx += 4
                unknown_09 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
                idx += 4
                unknown_10 =  struct.unpack("B", fdata[idx])[0]
                idx += 1

                print("DEBUG: unknown_00 = %s"%(unknown_00)) 
                print("DEBUG: unknown_01 = %s"%(unknown_01)) 
                print("DEBUG: unknown_02 = %s"%(unknown_02)) 
                print("DEBUG: unknown_03 = %s"%(unknown_03)) 
                print("DEBUG: unknown_04 = %s"%(unknown_04)) 
                print("DEBUG: unknown_05 = %s"%(unknown_05)) 
                print("DEBUG: unknown_06 = %s"%(unknown_06)) 
                print("DEBUG: unknown_07 = %s"%(unknown_07)) 
                print("DEBUG: unknown_08 = %s"%(unknown_08)) 
                print("DEBUG: unknown_09 = %s"%(unknown_09)) 
                print("DEBUG: unknown_10 = %s"%(unknown_10)) 

                fnamepad = struct.unpack("B", fdata[idx])[0]
                print("DEBUG: fnamepad = %s"%(fnamepad)) 
                idx += 1

                fnamechars = struct.unpack("B", fdata[idx])[0]
                print("DEBUG: fnamechars = %s"%(fnamechars)) 
                idx += 1
                bmp_file_name = fdata[idx:idx+fnamechars]
                idx += fnamechars

                idx += (fnamepad - (fnamechars+1))

                print("DEBUG: bmp_file_name = %s"%(bmp_file_name)) 

                bmp_bpp_val =  struct.unpack(cast_bit_order+"B", fdata[idx])[0]
                idx += 1                

                if bmp_bpp_val == 0x81:
                    # 4 bit per pixel image
                    bmp_bpp = 4

                elif bmp_bpp_val == 0x82:
                    # 8 bit per pixel image
                    bmp_bpp = 8

                elif bmp_bpp_val == 0x84:
                    # 16 bit per pixel image
                    bmp_bpp = 16

                elif bmp_bpp_val == 0x85:
                    # 16 bit per pixel image (MAC format)
                    bmp_bpp = 16

                elif bmp_bpp_val == 0x8A:
                    # 24 bit per pixel image
                    bmp_bpp = 24

                else:
                    print("WARNING: Unknown BPP value: %s"%(bmp_bpp_val))

                print("DEBUG: bmp_bpp = %s"%(bmp_bpp)) 


                unknown_11 =  struct.unpack(cast_bit_order+"B", fdata[idx])[0]
                idx += 1                
                print("DEBUG: unknown_11 = %s"%(unknown_11)) 

                h_padding =  struct.unpack(cast_bit_order+"h", fdata[idx:idx+2])[0]
                idx += 2
                print("DEBUG: h_padding = %s"%(h_padding)) 

                w_padding =  struct.unpack(cast_bit_order+"h", fdata[idx:idx+2])[0]
                idx += 2
                print("DEBUG: w_padding = %s"%(w_padding)) 

                bmp_height =  struct.unpack(cast_bit_order+"h", fdata[idx:idx+2])[0]
                idx += 2                
                print("DEBUG: bmp_height = %s"%(bmp_height)) 

                bmp_width =  struct.unpack(cast_bit_order+"h", fdata[idx:idx+2])[0]
                idx += 2                
                print("DEBUG: bmp_width = %s"%(bmp_width)) 

                bmp_height -= h_padding
                bmp_width -= w_padding

                unknown_12 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
                idx += 4
                print("DEBUG: unknown_12 = %s"%(unknown_12)) 

                unknown_13 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
                idx += 4
                print("DEBUG: unknown_13 = %s"%(unknown_13)) 

                unknown_14 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
                idx += 4
                print("DEBUG: unknown_14 = %s"%(unknown_14)) 

                unknown_15 =  struct.unpack(cast_bit_order+"h", fdata[idx:idx+2])[0]
                idx += 2
                print("DEBUG: unknown_15 = %s"%(unknown_15)) 

                unknown_16 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
                idx += 4
                print("DEBUG: unknown_16 = %s"%(unknown_16)) 


            elif data_type == DIR5_SND_TYPE: # --------------------------------------------------------------------------------------
                print("Reading sound data...")
                unknown_00 = struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
                idx += 4
                unknown_01 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
                idx += 4
                unknown_02 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
                idx += 4
                unknown_03 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
                idx += 4
                unknown_04 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
                idx += 4
                unknown_05 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
                idx += 4
                unknown_06 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
                idx += 4
                unknown_07 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
                idx += 4
                unknown_08 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
                idx += 4
                unknown_09 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
                idx += 4
                unknown_10 =  struct.unpack("B", fdata[idx])[0]
                idx += 1

                print("DEBUG: unknown_00 = %s"%(unknown_00)) 
                print("DEBUG: unknown_01 = %s"%(unknown_01)) 
                print("DEBUG: unknown_02 = %s"%(unknown_02)) 
                print("DEBUG: unknown_03 = %s"%(unknown_03)) 
                print("DEBUG: unknown_04 = %s"%(unknown_04)) 
                print("DEBUG: unknown_05 = %s"%(unknown_05)) 
                print("DEBUG: unknown_06 = %s"%(unknown_06)) 
                print("DEBUG: unknown_07 = %s"%(unknown_07)) 
                print("DEBUG: unknown_08 = %s"%(unknown_08)) 
                print("DEBUG: unknown_09 = %s"%(unknown_09)) 
                print("DEBUG: unknown_10 = %s"%(unknown_10)) 

                fnamepad = struct.unpack("B", fdata[idx])[0]
                print("DEBUG: fnamepad = %s"%(fnamepad)) 
                idx += 1

                fnamechars = struct.unpack("B", fdata[idx])[0]
                print("DEBUG: fnamechars = %s"%(fnamechars)) 
                idx += 1
                snd_file_name = fdata[idx:idx+fnamechars]
                idx += fnamechars

                idx += (fnamepad - (fnamechars+1))

                print("DEBUG: snd_file_name = %s"%(snd_file_name)) 

            elif data_type == DIR4_SND_TYPE: # --------------------------------------------------------------------------------------
                print("Reading sound data...")
                unknown_16 =  struct.unpack(cast_bit_order+"h", fdata[idx:idx+2])[0]
                idx += 2
                print("DEBUG: unknown_16 = %s"%(unknown_16)) 

                unknown_17 = struct.unpack("B", fdata[idx])[0]
                idx += 1
                print("DEBUG: unknown_17 = %s"%(unknown_17)) 

                if idx < len(fdata) - 1:
                    # 00 00 00 14
                    unknown_02 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
                    idx += 4
                    if unknown_02 != 0x14:
                        print("ERROR: Can't locate a region in the CASt file")
                        sys.exit(-1)

                    unknown_03 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
                    idx += 4
                    unknown_04 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
                    idx += 4
                    unknown_05 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
                    idx += 4
                    unknown_06 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
                    idx += 4
                    unknown_07_h =  struct.unpack(cast_bit_order+"h", fdata[idx:idx+2])[0]
                    idx += 2

                    print("DEBUG: unknown_02 = %s"%(unknown_02)) 
                    print("DEBUG: unknown_03 = %s"%(unknown_03)) 
                    print("DEBUG: unknown_04 = %s"%(unknown_04)) 
                    print("DEBUG: unknown_05 = %s"%(unknown_05)) 
                    print("DEBUG: unknown_06 = %s"%(unknown_06)) 
                    print("DEBUG: unknown_07_h = %s"%(unknown_07_h)) 

                    if unknown_07_h > 0:
                        unknown_07_l =  struct.unpack(cast_bit_order+"h", fdata[idx:idx+2])[0]
                        idx += 2

                        print("DEBUG: unknown_07_l = %s"%(unknown_07_l)) 


                        for k in range(0, unknown_07_h):
                            unknown_08 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
                            print("DEBUG: unknown_08 = %s"%(unknown_08))
                            idx += 4

                    unknown_10 =  struct.unpack("B", fdata[idx])[0]
                    idx += 1

 
                    print("DEBUG: unknown_10 = %s"%(unknown_10)) 

                if idx < len(fdata) - 1:
                    fnamepad = struct.unpack("B", fdata[idx])[0]
                    print("DEBUG: fnamepad = %s"%(fnamepad)) 
                    idx += 1

                    fnamechars = struct.unpack("B", fdata[idx])[0]
                    print("DEBUG: fnamechars = %s"%(fnamechars)) 
                    idx += 1
                    snd_file_name = fdata[idx:idx+fnamechars]
                    idx += fnamechars

                    idx += (fnamepad - (fnamechars+1))

                    if snd_file_name == '':
                        snd_file_name = None
                    else:
                        print("DEBUG: snd_file_name = %s"%(snd_file_name)) 

            elif data_type == DIR4_IMAGE_TYPE: # --------------------------------------------------------------------------------------
                print("Reading image data...")
                unknown_00 = struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
                idx += 4
                 
                print("DEBUG: unknown_00 = %s"%(unknown_00)) 
 
  
                bmp_bpp_val =  struct.unpack("B", fdata[idx])[0]
                idx += 1                

                # Force 8BPP
                bmp_bpp = 8

                print("DEBUG: bmp_bpp = %s"%(bmp_bpp)) 


                unknown_11 =  struct.unpack("B", fdata[idx])[0]
                idx += 1                
                print("DEBUG: unknown_11 = %s"%(unknown_11)) 


                h_padding =  struct.unpack(cast_bit_order+"h", fdata[idx:idx+2])[0]
                idx += 2
                print("DEBUG: h_padding = %s"%(h_padding)) 

                w_padding =  struct.unpack(cast_bit_order+"h", fdata[idx:idx+2])[0]
                idx += 2
                print("DEBUG: w_padding = %s"%(w_padding)) 

                bmp_height =  struct.unpack(cast_bit_order+"h", fdata[idx:idx+2])[0]
                idx += 2                

                bmp_width =  struct.unpack(cast_bit_order+"h", fdata[idx:idx+2])[0]
                idx += 2                

                print("DEBUG: bmp_height = %s"%(bmp_height)) 
                print("DEBUG: bmp_width = %s"%(bmp_width)) 

                bmp_height -= h_padding
                bmp_width -= w_padding

                unknown_12 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
                idx += 4
                print("DEBUG: unknown_12 = %s"%(unknown_12)) 

                unknown_13 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
                idx += 4
                print("DEBUG: unknown_13 = %s"%(unknown_13)) 

                unknown_14 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
                idx += 4
                print("DEBUG: unknown_14 = %s"%(unknown_14)) 

                unknown_15 =  struct.unpack(cast_bit_order+"h", fdata[idx:idx+2])[0]
                idx += 2
                print("DEBUG: unknown_15 = %s"%(unknown_15)) 

                unknown_16 =  struct.unpack(cast_bit_order+"h", fdata[idx:idx+2])[0]
                idx += 2
                print("DEBUG: unknown_16 = %s"%(unknown_16)) 

                if idx < len(fdata) - 1:
                    # 00 00 00 14
                    unknown_02 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
                    idx += 4
                    if unknown_02 != 0x14:
                        print("ERROR: Can't locate a region in the CASt file")
                        sys.exit(-1)

                    unknown_03 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
                    idx += 4
                    unknown_04 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
                    idx += 4
                    unknown_05 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
                    idx += 4
                    unknown_06 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
                    idx += 4
                    unknown_07_h =  struct.unpack(cast_bit_order+"h", fdata[idx:idx+2])[0]
                    idx += 2

                    print("DEBUG: unknown_02 = %s"%(unknown_02)) 
                    print("DEBUG: unknown_03 = %s"%(unknown_03)) 
                    print("DEBUG: unknown_04 = %s"%(unknown_04)) 
                    print("DEBUG: unknown_05 = %s"%(unknown_05)) 
                    print("DEBUG: unknown_06 = %s"%(unknown_06)) 
                    print("DEBUG: unknown_07_h = %s"%(unknown_07_h)) 

                    if unknown_07_h > 0:
                        unknown_07_l =  struct.unpack(cast_bit_order+"h", fdata[idx:idx+2])[0]
                        idx += 2

                        print("DEBUG: unknown_07_l = %s"%(unknown_07_l)) 


                        for k in range(0, unknown_07_h):
                            unknown_08 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
                            print("DEBUG: unknown_08 = %s"%(unknown_08))
                            idx += 4

                    unknown_10 =  struct.unpack("B", fdata[idx])[0]
                    idx += 1

 
                    print("DEBUG: unknown_10 = %s"%(unknown_10)) 

                if idx < len(fdata) - 1:
                    fnamepad = struct.unpack("B", fdata[idx])[0]
                    print("DEBUG: fnamepad = %s"%(fnamepad)) 
                    idx += 1

                    fnamechars = struct.unpack("B", fdata[idx])[0]
                    print("DEBUG: fnamechars = %s"%(fnamechars)) 
                    idx += 1
                    bmp_file_name = fdata[idx:idx+fnamechars]
                    idx += fnamechars

                    idx += (fnamepad - (fnamechars+1))

                    if bmp_file_name == '':
                        bmp_file_name = None
                    else:
                        print("DEBUG: bmp_file_name = %s"%(bmp_file_name)) 


            else:
                print("WARNING: Unknown CASt type: %s"%(data_type))

        # -------------------------- Lingo script ------------------------------------------------------------------
        elif (file_format == LSCR_FILE_FORMAT):
            print("Lingo script header ================ ")

            # Format details from: http://fileformats.archiveteam.org/wiki/Lingo_bytecode

            fdata = fileContent[file_offset:(file_offset+file_length+8)]

            lsrc_bit_order = '>'

            # Skip file size and length
            idx = 8
            scr_type = struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
            idx += 4
            unknown_01 =  struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
            idx += 4
            filesize0 =  struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
            idx += 4
            filesize1 =  struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
            idx += 4
            unknown_04 =  struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
            idx += 4
            unknown_05 =  struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
            idx += 4
            unknown_06 =  struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
            idx += 4
            unknown_07 =  struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
            idx += 4
            unknown_08 =  struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
            idx += 4
            unknown_09 =  struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
            idx += 4
            unknown_10 =  struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
            idx += 4
            unknown_11 =  struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
            idx += 4
            unknown_12 =  struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
            idx += 4
            unknown_13 =  struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
            idx += 4
            unknown_14 =  struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
            idx += 4
            unknown_15 =  struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
            idx += 4

            print("DEBUG: scr_type = %08x"%(scr_type)) 
            print("DEBUG: unknown_01 = %08x"%(unknown_01)) 
            print("DEBUG: filesize0 = %s"%(filesize0)) 
            print("DEBUG: filesize1 = %s"%(filesize1)) 
            print("DEBUG: unknown_04 = %08x"%(unknown_04)) 
            print("DEBUG: unknown_05 = %08x"%(unknown_05)) 
            print("DEBUG: unknown_06 = %08x"%(unknown_06)) 
            print("DEBUG: unknown_07 = %08x"%(unknown_07)) 
            print("DEBUG: unknown_08 = %08x"%(unknown_08)) 
            print("DEBUG: unknown_09 = %08x"%(unknown_09)) 
            print("DEBUG: unknown_10 = %08x"%(unknown_10)) 
            print("DEBUG: unknown_11 = %08x"%(unknown_11)) 
            print("DEBUG: unknown_12 = %08x"%(unknown_12)) 
            print("DEBUG: unknown_13 = %08x"%(unknown_13)) 
            print("DEBUG: unknown_14 = %08x"%(unknown_14)) 
            print("DEBUG: unknown_15 = %08x"%(unknown_15)) 

            if filesize1 != filesize0 or filesize1 != len(fdata) - 8:
                print("ERROR: bad filesize (%s, %s, %s)"%(filesize1, filesize0, (len(fdata) - 8))) 
                sys.exit(-1)

            # $0040-$0041 	uint16 	Offset to the function records block  
            frb_offset = struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
            idx += 2

            unknown_17 =  struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
            idx += 2
            unknown_18 =  struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
            idx += 2

            # Offset to the function records block repeated
            frb_offset_cp = struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
            idx += 2

            print("DEBUG: frb_offset = %s"%(frb_offset)) 
            print("DEBUG: unknown_17 = %s"%(unknown_17)) 
            print("DEBUG: unknown_18 = %s"%(unknown_18)) 
            print("DEBUG: frb_offset_cp = %s"%(frb_offset_cp)) 

            if frb_offset != frb_offset_cp:
                print("ERROR: bad offset to the function records block (%s, %s)"%(frb_offset, frb_offset_cp))
                sys.exit(-1)

            # $0048-$0049 	uint16 	Number of function records 
            frb_nrecords = struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
            idx += 2

            unknown_19 =  struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
            idx += 2

            # Offset to the function records block repeated
            frb_offset_cp = struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
            idx += 2

            print("DEBUG: frb_nrecords = %s"%(frb_nrecords)) 
            print("DEBUG: unknown_19 = %s"%(unknown_19)) 
            print("DEBUG: frb_offset_cp = %s"%(frb_offset_cp)) 

            if frb_offset != frb_offset_cp:
                print("ERROR: bad offset to the function records block (%s, %s)"%(frb_offset, frb_offset_cp)) 
                sys.exit(-1)

            # $004E-$004F    uint16 	Number of constants 
            con_nconstants = struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
            idx += 2

            unknown_20 =  struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
            idx += 2

            # $0052-$0053 	uint16 	Offset to the constant records block 
            crb_offset = struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
            idx += 2

            unknown_21 =  struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
            idx += 2

            # Size in bytes of the constants area???
            unknown_22 =  struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
            idx += 2

            unknown_23 =  struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
            idx += 2

            # $005A-$005B 	uint16 	Base address for constant data
            con_offset = struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
            idx += 2

            print("DEBUG: con_nconstants = %s"%(con_nconstants)) 
            print("DEBUG: unknown_20 = %s"%(unknown_20)) 
            print("DEBUG: crb_offset = %s"%(crb_offset))            
            print("DEBUG: unknown_21 = %s"%(unknown_21)) 
            print("DEBUG: unknown_22 = %s"%(unknown_22)) 
            print("DEBUG: unknown_23 = %s"%(unknown_23)) 
            print("DEBUG: con_offset = %s"%(con_offset))      

            # Read the constants record blocks
            constants = []

            bytes_per_const = 6
            idx = crb_offset + 8
            for i in range(0, con_nconstants):
                if scr_type == 0x1fc7ea60:
                    # uint32: Value type ID 
                   constant_type = struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
                   idx += 4
                   bytes_per_const = 8
                else:
                    # uint16: Value type ID 
                   constant_type = struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
                   idx += 2

                # uint32: Data address, relative to the base address given in the header 
                constant_offset = struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
                idx += 4

                #print("DEBUG: constant_type = %s"%(constant_type)) 
                #print("DEBUG: contant_offset = %s"%(constant_offset)) 

                if constant_type == 1:
                    # Text constant
                    idxc = con_offset + constant_offset + 8

                    # uint32: String length
                    strlength = struct.unpack(lsrc_bit_order+"i", fdata[idxc:idxc+4])[0] - 1
                    idxc += 4
                    #print("DEBUG: strlength = %s"%(strlength)) 

                    strval = str(fdata[idxc:idxc+strlength])
                    constants.append(to_string(strval))
                   

                elif constant_type == 4:
                    # 32 bits integer
                    print("ERROR: TODO! integer treatment: %s"%(constant_type)) 
                    sys.exit(-1)

                elif constant_type == 9:
                    # Floating point 
                    print("ERROR: TODO! floating point treatment: %s"%(constant_type))
                    sys.exit(-1)


                else:
                    # Unknown
                    print("ERROR: Unknown constant type: %s"%(constant_type))
                    sys.exit(-1)

                print("DEBUG: constants[%s] = %s"%(i, constants[i])) 

            
            file_ext = "Lscr"
            file_name = "%s.%s"%(nfiles, file_ext)

            print(u"FILE: Saving script file to: %s"%(file_name))

            with open(os.path.join(sys.argv[3], file_name), 'wb') as file:

                # Read the functions record blocks
                idx = frb_offset + 8
                for i in range(0, frb_nrecords):

                    # $0000-$0001 	uint16 	Namelist index for the function's name, or 0xFFFF if there is no name(?)
                    namelist_index = struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
                    idx += 2

                    # $0002-$0003 	uint16 	Unknown
                    unknown_rb0 = struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
                    idx += 2

                    # $0004-$0007 	uint32 	Length of the function bytecode in bytes
                    bc_length = struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
                    idx += 4

                    # $0008-$000B 	uint32 	Offset to the function bytecode
                    bc_off = struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
                    idx += 4

                    # $000C-$000D 	uint16 	Number of arguments
                    bc_narg = struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
                    idx += 2

                    # $000E-$0011 	uint32 	Unknown
                    unknown_rb1 = struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
                    idx += 4

                    # $0012-$0013 	uint16 	Number of local variables
                    bc_nlocal = struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
                    idx += 2

                    # $0014-$0017 	uint32 	Unknown
                    unknown_rb2 = struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
                    idx += 4

                    # $0018-$0019 	uint16 	Count (C)
                    count_c = struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
                    idx += 2

                    # $001A-$001D 	uint32 	Unknown
                    unknown_rb3 = struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
                    idx += 4

                    # $001E-$0021 	uint32 	Unknown
                    unknown_rb4 = struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
                    idx += 4

                    # $0022-$0023 	uint16 	Unknown
                    unknown_rb5 = struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
                    idx += 2

                    # $0024-$0025 	uint16 	Count (D)
                    count_d = struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
                    idx += 2

                    # $0026-$0029 	uint32 	Unknown
                    unknown_rb6 = struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
                    idx += 4

                    print("DEBUG: namelist_index = %x"%(namelist_index)) 
                    print("DEBUG: unknown_rb0 = %x"%(unknown_rb0)) 
                    print("DEBUG: bc_length = %x"%(bc_length)) 
                    print("DEBUG: bc_off = %x"%(bc_off)) 
                    print("DEBUG: bc_narg = %x"%(bc_narg)) 
                    print("DEBUG: unknown_rb1 = %x"%(unknown_rb1)) 
                    print("DEBUG: bc_nlocal = %x"%(bc_nlocal)) 
                    print("DEBUG: unknown_rb2 = %x"%(unknown_rb2)) 
                    print("DEBUG: count_c = %x"%(count_c)) 
                    print("DEBUG: unknown_rb3 = %x"%(unknown_rb3)) 
                    print("DEBUG: unknown_rb4 = %x"%(unknown_rb4)) 
                    print("DEBUG: unknown_rb5 = %x"%(unknown_rb5)) 
                    print("DEBUG: count_d = %x"%(count_d)) 
                    print("DEBUG: unknown_rb6 = %x"%(unknown_rb6)) 

                    fname = 'noname'
                    if namelist_index >= 0 and namelist_index < len(name_list):
                        fname = name_list[namelist_index]

                    args = ''
                    for c in range(0, bc_narg):
                         if args == '':
                              args = ('param%s'%(c))
                         else:
                              args = args + ', ' + ('param%s'%(c))

                    file.write("on %s %s\n"%(fname, args))

                    spacing = '    '

                    label_indexes = []
                    label_types = {}
                    global_vars = []
                    # Search for loops and globals
                    idxc = bc_off + 8
                    while (idxc - bc_off - 8) < bc_length:
                        opcode = ord(fdata[idxc])
                        idxc = idxc + 1
                        
                        if ((opcode not in ONE_BYTE_OPCODES) and
                            (opcode not in TWO_BYTE_OPCODES) and
                            (opcode not in THREE_BYTE_OPCODES)):
                            print("ERROR: Unknown opcode: %02x"%(opcode))
                            sys.exit(-1)

                        if opcode in ONE_BYTE_OPCODES:
                            pass

                        elif opcode in TWO_BYTE_OPCODES:
                            # Two bytes operation
                            op1 = ord(fdata[idxc])
                            idxc = idxc + 1

                            if opcode == 0x54:
                                # Unconditional backwards jump by XX bytes, relative to the first byte of this instruction. 
                                label_indexes.append(idxc - 2 - op1)
                                label_types[idxc - 2 - op1] = 'repeat while TRUE'
                                label_types[idxc] = 'end repeat'
                            elif opcode == 0x49:
                                # Push the value of a global variable with a name from namelist[XX].  
                                if not name_list[op1] in global_vars:
                                    global_vars.append(name_list[op1])
                            elif opcode == 0x4F:
                                # Pop one value and use it to set the global variable with name from namelist[XX].    
                                if not name_list[op1] in global_vars:
                                    global_vars.append(name_list[op1])

                        else:
                            # Three bytes operation 
                            op1 = ord(fdata[idxc])
                            idxc = idxc + 1

                            op2 = ord(fdata[idxc])
                            idxc = idxc + 1

                            if opcode == 0x93:
                                # Unconditional jump: Advance by ((XX * 0x100) + YY) bytes, relative to the first byte of this instruction.
                                label_indexes.append(idxc - 3 + (op1 * 256 + op2))
                                label_types[idxc - 3 + (op1 * 256 + op2)] = 'end if'

                                label_indexes.append(idxc)
                                label_types[idxc] = 'else'

                            elif opcode == 0x95:
                                # Conditional jump: Pop a value, and if it is logically FALSE, advance by ((XX * 0x100) + YY) bytes, relative to the first byte of this instruction. 
                                label_indexes.append(idxc - 3 + (op1 * 256 + op2))
                                label_types[idxc - 3 + (op1 * 256 + op2)] = 'end if'

                            elif opcode == 0x89:
                                # Push the value of a global variable with a name from namelist[XX].  
                                if not name_list[op1] in global_vars:
                                    global_vars.append(name_list[op1 * 256 + op2])
                            elif opcode == 0x8F:
                                # Pop one value and use it to set the global variable with name from namelist[XX].    
                                if not name_list[op1] in global_vars:
                                    global_vars.append(name_list[op1 * 256 + op2])


                    # Generate code
                    clear_stack()
                    window_to_tell = None

                    for gv in global_vars:
                        file.write(spacing)
                        file.write("global %s\n"%(gv))

                    idxc = bc_off + 8
                    while (idxc - bc_off - 8) < bc_length:
                        if idxc in label_indexes:
                            flush_stack(file, spacing)
                            if idxc in label_types:
                                if label_types[idxc].startswith('end') or label_types[idxc] == 'else':
                                    spacing = spacing[0:(len(spacing) - 4)]

                                file.write(spacing)
                                file.write("%s\n"%(label_types[idxc]))
                                if not label_types[idxc].startswith('end'):
                                    spacing = spacing + '    '

                            else:
                                file.write("label%08x\n"%(idxc))

                        file.write(spacing)

                        opcode = ord(fdata[idxc])
                        idxc = idxc + 1
                        
                        if ((opcode not in ONE_BYTE_OPCODES) and
                            (opcode not in TWO_BYTE_OPCODES) and
                            (opcode not in THREE_BYTE_OPCODES)):
                            print("ERROR: Unknown opcode: %02x"%(opcode))
                            sys.exit(-1)

                        if opcode in ONE_BYTE_OPCODES:
                            # One byte operation
                            file.write("-- [0x%04x]: 0x%02x"%(idxc - 1, opcode))

                            if opcode == 0x01:
                                flush_stack(file, spacing)
                                file.write('\n')
                                file.write(spacing)
                                file.write('exit')

                            elif opcode == 0x03:
                                push('0')

                            elif opcode == 0x04:
                                op2 = pop_s()
                                op1 = pop_s()
                                push('(' + op1 + ' * ' + op2 + ')')

                            elif opcode == 0x04:
                                op2 = pop_s()
                                op1 = pop_s()
                                push('(' + op1 + ' * ' + op2 + ')')

                            elif opcode == 0x05:
                                op2 = pop_s()
                                op1 = pop_s()
                                push('(' + op1 + ' + ' + op2 + ')')

                            elif opcode == 0x06:
                                op2 = pop_s()
                                op1 = pop_s()
                                push('(' + op1 + ' - ' + op2 + ')')

                            elif opcode == 0x07:
                                op2 = pop_s()
                                op1 = pop_s()
                                push('(' + op1 + ' / ' + op2 + ')')

                            elif opcode == 0x08:
                                op2 = pop_s()
                                op1 = pop_s()
                                push('(' + op1 + ' mod ' + op2 + ')')

                            elif opcode == 0x09:
                                push('-' + pop_s())

                            elif opcode == 0x0A:
                                op2 = pop_s()
                                op1 = pop_s()
                                push('('+ op1 + ' & ' + op2 + ')')

                            elif opcode == 0x0B:
                                op2 = pop_s()
                                op1 = pop_s()
                                push('(' + op1 + ' && ' + op2 + ')')

                            elif opcode == 0x0C:
                                op2 = pop_s()
                                op1 = pop_s()
                                push('(' + op1 + ' < ' + op2 + ')')

                            elif opcode == 0x0D:
                                op2 = pop_s()
                                op1 = pop_s()
                                push('(' + op1 + ' <= ' + op2 + ')')

                            elif opcode == 0x0E:
                                op2 = pop_s()
                                op1 = pop_s()
                                push('(' + op1 + ' <> ' + op2 + ')')

                            elif opcode == 0x0F:
                                op2 = pop_s()
                                op1 = pop_s()
                                push('(' + op1 + ' = ' + op2 + ')')

                            elif opcode == 0x10:
                                op2 = pop_s()
                                op1 = pop_s()
                                push('(' + op1 + ' > ' + op2 + ')')

                            elif opcode == 0x11:
                                op2 = pop_s()
                                op1 = pop_s()
                                push('(' + op1 + ' >= ' + op2 + ')')

                            elif opcode == 0x12:
                                op2 = pop_s()
                                op1 = pop_s()
                                push('(' + op1 + ' and ' + op2 + ')')

                            elif opcode == 0x13:
                                op2 = pop_s()
                                op1 = pop_s()
                                push('(' + op1 + ' or ' + op2 + ')')

                            elif opcode == 0x14:
                                push('(not ' + pop_s() + ')')

                            elif opcode == 0x15:
                                op2 = pop_s()
                                op1 = pop_s()
                                push('(' + op1 + ' contains ' + op2 + ')')

                            elif opcode == 0x16:
                                op2 = pop_s()
                                op1 = pop_s()
                                push('(' + op1 + ' starts ' + op2 + ')')


                            elif opcode == 0x17:
                                op_str = pop_s()       # The string to slice
                                op_ll_pos = pop_s()    # Last line position
                                op_fl_pos = pop_s()    # First line position
                                op_li_pos = pop_s()    # Last item position
                                op_fi_pos = pop_s()    # First item position (items separated by the itemDelimiter, which is a comma by default)
                                op_lw_pos = pop_s()    # Last word position
                                op_fw_pos = pop_s()    # First word position
                                op_lc_pos = pop_s()    # Last char position
                                op_fc_pos = pop_s()    # First char position

                                operation = ''

                                if op_fc_pos != '0':
                                    operation = operation + ('char %s '%(op_fc_pos))
                                    if op_lc_pos != '0':
                                        operation = operation + ('to %s '%(op_lc_pos))
                                    operation = operation + 'of '

                                if op_fw_pos != '0':
                                    operation = operation + ('word %s '%(op_fw_pos))
                                    if op_lw_pos != '0':
                                        operation = operation + ('to %s '%(op_lw_pos))
                                    operation = operation + 'of '

                                if op_fi_pos != '0':
                                    operation = operation + ('item %s '%(op_fi_pos))
                                    if op_li_pos != '0':
                                        operation = operation + ('to %s '%(op_li_pos))
                                    operation = operation + 'of '

                                if op_fl_pos != '0':
                                    operation = operation + ('line %s '%(op_fl_pos))
                                    if op_ll_pos != '0':
                                        operation = operation + ('to %s '%(op_ll_pos))
                                    operation = operation + 'of '

                                operation = operation + op_str

                                push(operation)


                            elif opcode == 0x18:
                                op_cid = pop_s()       # Field number (cast ID
                                op_ll_pos = pop_s()    # Last line position
                                op_fl_pos = pop_s()    # First line position
                                op_li_pos = pop_s()    # Last item position
                                op_fi_pos = pop_s()    # First item position (items separated by the itemDelimiter, which is a comma by default)
                                op_lw_pos = pop_s()    # Last word position
                                op_fw_pos = pop_s()    # First word position
                                op_lc_pos = pop_s()    # Last char position
                                op_fc_pos = pop_s()    # First char position

                                operation = ''

                                if op_fc_pos != '0':
                                    operation = operation + ('char %s '%(op_fc_pos))
                                    if op_lc_pos != '0':
                                        operation = operation + ('to %s '%(op_lc_pos))
                                    operation = operation + 'of '

                                if op_fw_pos != '0':
                                    operation = operation + ('word %s '%(op_fw_pos))
                                    if op_lw_pos != '0':
                                        operation = operation + ('to %s '%(op_lw_pos))
                                    operation = operation + 'of '

                                if op_fi_pos != '0':
                                    operation = operation + ('item %s '%(op_fi_pos))
                                    if op_li_pos != '0':
                                        operation = operation + ('to %s '%(op_li_pos))
                                    operation = operation + 'of '

                                if op_fl_pos != '0':
                                    operation = operation + ('line %s '%(op_fl_pos))
                                    if op_ll_pos != '0':
                                        operation = operation + ('to %s '%(op_ll_pos))
                                    operation = operation + 'of '

                                operation = 'hilite ' + operation + 'field ' + op_cid

                                push(operation)

                            elif opcode == 0x19:
                                op2 = pop_s()
                                op1 = pop_s()

                                push('sprite_intersects(' + op1 + ', ' + op2 + ')')

                            elif opcode == 0x1A:
                                op2 = pop_s()
                                op1 = pop_s()

                                push('sprite_within(' + op1 + ', ' + op2 + ')')

                            elif opcode == 0x1B:
                                pop_s()
                                push('field ' + pop_s())

                            elif opcode == 0x1C:
                                # Start of "tell" operation
                                window_to_tell = pop_s()

                            elif opcode == 0x1D:
                                # End of "tell" operation
                                params = ''
                                p = pop()
                                while p is not None:
                                    if params == '':
                                        params = p
                                    else:
                                        params = params + ' ' + p
                                    p = pop()

                                file.write("\n")
                                file.write(spacing)
                                file.write('tell ' + window_to_tell + ' to ' + params)

                            elif opcode == 0x1F:
                                push('transpose(' + pop_s() + ')')


                        elif opcode in TWO_BYTE_OPCODES:
                            # Two bytes operation
                            op1 = ord(fdata[idxc])
                            idxc = idxc + 1

                            file.write("-- [0x%04x]: 0x%02x 0x%02x"%(idxc - 2, opcode, op1))


                            if opcode == 0x41:
                                # Push integer of value XX, which must be between 1 and 127, inclusive.
                                push('%s'%(op1))

                            elif opcode == 0x42:
                                # Pop the specified number of values off the top of the stack, create an unparenthesized argument list containing them 
                                # (i.e. for a call statement like myFunction 1, 2, 3), and push that to the stack.
                                params = ''
                                for c in range(0, op1):
                                    p = pop_s()
                                    if params == '':
                                        params = p
                                    else:
                                        params = p + ', ' + params

                                push(params)

                            elif opcode == 0x43:
                                # Pop the specified number of values off the top of the stack, create a list for them (which can also be used for a parenthesized call expression like set result = myFunction(1, 2, 3)), 
                                # and push that to the stack.
                                params = ''
                                for c in range(0, op1):
                                    p = pop_s()
                                    if params == '':
                                        params = p
                                    else:
                                        params = p + ', ' + params

                                push('<%s'%(params))

                            elif opcode == 0x44:
                                # Push a constant from local constant records onto the stack. These records seem to be six bytes long (regardless of the actual size of the constant value), 
                                # so pushing the first one is 44 00, the second is 44 06, the third is 44 0C, etc. 
                                constant_value = constants[op1 / bytes_per_const]
                                if constant_value in SPECIAL_CONSTANTS:
                                    constant_value = SPECIAL_CONSTANTS[constant_value]
                                push('%s'%(constant_value))

                            elif opcode == 0x45:
                                # Push a symbol with a name from namelist[XX]. Note that the name will be stored as "name", not "#name". 
                                push('%s'%(name_list[op1]))

                            elif opcode == 0x46:
                                # Push a object with a name from namelist[XX]. 
                                push('%s'%(name_list[op1]))

                            elif opcode == 0x49:
                                # Push the value of a global variable with a name from namelist[XX].  
                                push('%s'%(name_list[op1]))

                            elif opcode == 0x4A:
                                # Push the value of a property.  
                                push('the %s'%(name_list[op1]))

                            elif opcode == 0x4B:
                                # Push the value of a function call parameter. The parameter records seem to be 6 bytes long, so the first is pushed with 4B 00, the second with 4B 06, etc.   
                                push('param%s'%(op1 / bytes_per_const))

                            elif opcode == 0x4C:
                                # Push the value of a function call parameter. The parameter records seem to be 6 bytes long, so the first is pushed with 4B 00, the second with 4B 06, etc.   
                                push('local%s'%(op1 / bytes_per_const))

                            elif opcode == 0x4F:
                                # Pop one value and use it to set the global variable with name from namelist[XX].    
                                file.write("\n")
                                file.write(spacing)
                                file.write('put %s into %s'%(pop_s(), name_list[op1]))

                            elif opcode == 0x50:
                                # Pop one value and use it to set a property.
                                file.write("\n")
                                file.write(spacing)
                                file.write('set_property("%s", %s);'%(name_list[op1], pop_s()))

                            elif opcode == 0x51:
                                # Pop one value and use it to set a parameter. 
                                file.write("\n")
                                file.write(spacing)
                                file.write('put %s into param%s'%(pop_s(), op1 / bytes_per_const))

                            elif opcode == 0x52:
                                # Pop one value and use it to set a local variable.
                                file.write("\n")
                                file.write(spacing)
                                file.write('put %s into local%s'%(pop_s(), op1 / bytes_per_const))

                            elif opcode == 0x54:
                                # Unconditional backwards jump by XX bytes, relative to the first byte of this instruction. 
                                file.write("\n")
                                file.write(spacing)
                                file.write('-- goto label%04x;'%(idxc - 2 - op1))
                                flush_stack(file, spacing)
                                
 
                            elif opcode == 0x56:
                                # Call a function defined in this script with the name at namelist[XX].
                                params = pop_s()
                                if params.startswith('<'):
                                    # The function must return something
                                    if name_list[op1] in NO_PAREN_FUNCTIONS:
                                        push('%s %s'%(name_list[op1], params[1:]))
                                    else:
                                        push('%s(%s)'%(name_list[op1], params[1:]))
                                else:
                                    file.write("\n")
                                    file.write(spacing)
                                    if name_list[op1] in NO_PAREN_FUNCTIONS:
                                        file.write('%s %s'%(name_list[op1], params))
                                    else:
                                        file.write('%s(%s)'%(name_list[op1], params))

                            elif opcode == 0x57:
                                # Call the external function with name from namelist[XX].
                                params = pop_s()
                                if params.startswith('<'):
                                    # The function must return something
                                    if name_list[op1] in NO_PAREN_FUNCTIONS:
                                        push('%s %s'%(name_list[op1], params[1:]))
                                    else:
                                        push('%s(%s)'%(name_list[op1], params[1:]))
                                else:
                                    file.write("\n")
                                    file.write(spacing)
                                    if name_list[op1] in NO_PAREN_FUNCTIONS:
                                        file.write('%s %s'%(name_list[op1], params))
                                    else:
                                        file.write('%s(%s)'%(name_list[op1], params))

                            elif opcode == 0x58:
                                # Call an object method
                                obj = pop_s()
                                if obj.isdigit():
                                    obj = ('local%s'%(obj))

                                params = pop_s()
                                if params.startswith('<'):
                                    # The function must return something
                                    push('%s(%s)'%(obj, params[1:]))
                                else:
                                    file.write("\n")
                                    file.write(spacing)
                                    file.write('%s(%s)'%(obj, params))

                            elif opcode == 0x59:
                                if op1 == 0x16:
                                    op_type = int(pop())
                                    op_var = pop_s()
                                    op_value = pop_s()
                                    op_types = ['field']

                                    if op_type < len(op_types):
                                        op_type = op_types[op_type]
                                    else:
                                        op_type = ' UNKNOWN '

                                    file.write("\n")
                                    file.write(spacing)
                                    file.write('put %s into %s %s'%(op_value, op_type, op_var))

                                elif op1 == 0x25:
                                    op_var = int(pop())
                                    op_value = pop_s()

                                    file.write("\n")
                                    file.write(spacing)
                                    file.write('put %s after local%s'%(op_value, op_var / bytes_per_const))

                                elif op1 == 0x35:
                                    op_var = int(pop())
                                    op_value = pop_s()

                                    file.write("\n")
                                    file.write(spacing)
                                    file.write('put %s before local%s'%(op_value, op_var / bytes_per_const))

                                else:
                                    file.write("\n")
                                    file.write(spacing)
                                    file.write("ERROR: Missing subcommand! (0x%02x) :("%(op1))

                            # TODO! Complete this

                            elif opcode == 0x5B:
                                op_type = 'UNKNOWN'

                                op_vind = pop_s()      # The local variable
                                op_ll_pos = pop_s()    # Last line position
                                op_fl_pos = pop_s()    # First line position
                                op_li_pos = pop_s()    # Last item position
                                op_fi_pos = pop_s()    # First item position (items separated by the itemDelimiter, which is a comma by default)
                                op_lw_pos = pop_s()    # Last word position
                                op_fw_pos = pop_s()    # First word position
                                op_lc_pos = pop_s()    # Last char position
                                op_fc_pos = pop_s()    # First char position

                                if op_fl_pos != '0':
                                    op_type = 'line ' + op_fl_pos
                                    if op_ll_pos != '0':
                                        op_type = op_type + ' to ' + op_ll_pos

                                if op_fi_pos != '0':
                                    op_type = 'item ' + op_fi_pos
                                    if op_li_pos != '0':
                                        op_type = op_type + ' to ' + op_li_pos

                                if op_fw_pos != '0':
                                    op_type = 'word ' + op_fw_pos
                                    if op_lw_pos != '0':
                                        op_type = op_type + ' to ' + op_lw_pos

                                if op_fc_pos != '0':
                                    op_type = 'char ' + op_fc_pos
                                    if op_lc_pos != '0':
                                        op_type = op_type + ' to ' + op_lc_pos

                                op_vind = int(op_vind)
                                op_vname = 'local%s'%(op_vind / bytes_per_const)

                                file.write("\n")
                                file.write(spacing)
                                file.write('delete ' + op_type + ' of ' + op_vname)

                            elif opcode == 0x5C:
                                if op1 == 0x01:
                                    # the number of chars in someText
                                    op_type = int(pop())
                                    op_var = pop_s()
                                    op_types = ['chars', 'words', 'items', 'lines']
                                    push('the number of %s of %s'%(op_types[op_type - 1], op_var))


                                else:
                                    file.write("\n")
                                    file.write(spacing)
                                    file.write("ERROR: Missing subcommand! (0x%02x) :("%(op1))

                            elif opcode == 0x5F:
                                # Push the value of the contextual property with the name at namelist[XX].
                                push('the %s'%(name_list[op1]))

                            # TODO! Complete this

                            elif opcode == 0x63:
                                # property to tell  
                                push('%s'%(name_list[op1]))

                            elif opcode == 0x64:
                                # Push a copy of a value already on the stack, relative to the top where 00 is the top slot, 01 is one slot beneath the top, etc. 
                                file.write("\n")
                                file.write(spacing)
                                file.write("ERROR: I don't know to implement the copy command! :(")

                            elif opcode == 0x65:
                                # Pop and discard XX values from the top of the stack.
                                file.write("\n")
                                file.write(spacing)
                                file.write("ERROR: I don't know to implement the discard command! :(")

                            elif opcode == 0x66:
                                # Pop an empty list and push the value of a read-only property named at namelist[XX]. 
                                pop()
                                push('the %s'%(name_list[op1]))


                            else:
                                # Unknown operation
                                flush_stack(file, spacing)
                                file.write("\n")
                                file.write(spacing)
                                file.write('unknown_op2(0x%02x, 0x%02x);'%(opcode, op1))

                        else:
                            # Three bytes operation 
                            op1 = ord(fdata[idxc])
                            idxc = idxc + 1

                            op2 = ord(fdata[idxc])
                            idxc = idxc + 1

                            file.write("-- [0x%04x]: 0x%02x 0x%02x 0x%02x"%(idxc - 3, opcode, op1, op2))

                            if opcode == 0x81:
                                # Push the integer ((XX * 0x100) + YY).
                                push('%s'%(op1 * 256 + op2))

                            elif opcode == 0x82:
                                # Pop the specified number of values off the top of the stack, create an unparenthesized argument list containing them 
                                # (i.e. for a call statement like myFunction 1, 2, 3), and push that to the stack.
                                push('arglist(%s)'%(op1 * 256 + op2))

                            elif opcode == 0x83:
                                # Pop the specified number of values off the top of the stack, create a list for them (which can also be used for a parenthesized call expression like set result = myFunction(1, 2, 3)), 
                                # and push that to the stack.
                                push('list(%s)'%(op1 * 256 + op2))

                            elif opcode == 0x84:
                                # Push a constant from local constant records onto the stack. 
                                constant_value = constants[(op1 * 256 + op2) / bytes_per_const]
                                if constant_value in SPECIAL_CONSTANTS:
                                    constant_value = SPECIAL_CONSTANTS[constant_value]
                                push('%s'%(constant_value))

                            elif opcode == 0x89:
                                # Push the value of a global variable with a name from namelist[XX].  
                                push('%s'%(name_list[(op1 * 256 + op2)]))

                            elif opcode == 0x8F:
                                # Pop one value and use it to set the global variable with name from namelist[XX].    
                                file.write("\n")
                                file.write(spacing)
                                file.write('put %s into %s'%(pop_s(), name_list[(op1 * 256 + op2)]))

                            elif opcode == 0x90:
                                # Pop one value and use it to set a property.
                                file.write("\n")
                                file.write(spacing)
                                file.write('put %s into %s'%(pop_s(), name_list[(op1 * 256 + op2)]))

                            elif opcode == 0x93:
                                # Unconditional jump: Advance by ((XX * 0x100) + YY) bytes, relative to the first byte of this instruction.
                                flush_stack(file, spacing)
                                file.write("\n")
                                file.write(spacing)
                                file.write('-- goto label%04x;'%(idxc - 3 + (op1 * 256 + op2)))
                                if label_types[idxc - 3 + (op1 * 256 + op2)] == 'end repeat':
                                    file.write('\n')
                                    file.write(spacing)
                                    file.write('exit repeat')
                                    if label_types[idxc] == 'else':
                                        label_types[idxc] = 'end if'
                                    

                            elif opcode == 0x95:
                                # Conditional jump: Pop a value, and if it is logically FALSE, advance by ((XX * 0x100) + YY) bytes, relative to the first byte of this instruction. 
                                file.write("\n")
                                file.write(spacing)
                                file.write('-- if (!pop()) goto label%04x;\n'%(idxc - 3 + (op1 * 256 + op2)))
                                file.write(spacing)
                                erpos = idxc - 3 + (op1 * 256 + op2)
                                if (erpos in label_types) and (label_types[erpos] == 'end repeat'):
                                    file.write('if not %s then exit repeat'%(pop_s()))
                                else:
                                    file.write('if %s then'%(pop_s()))
                                    spacing = spacing + '    '

                            elif opcode == 0xa0:
                                # Pop one value and use it to set a property.
                                file.write("\n")
                                file.write(spacing)
                                file.write('put %s into %s'%(pop_s(), name_list[(op1 * 256 + op2)]))

                            elif opcode == 0xa1:
                                # Pop one value and use it to set a parameter. 
                                file.write("\n")
                                file.write(spacing)
                                file.write('param%s = %s;'%((op1 * 256 + op2) / bytes_per_const, pop_s()))

                            elif opcode == 0xa2:
                                # Pop one value and use it to set a local variable.
                                file.write("\n")
                                file.write(spacing)
                                file.write('local%s = %s;'%((op1 * 256 + op2) / bytes_per_const, pop_s()))

                            elif opcode == 0xa6:
                                # Pop an empty list and push the value of a read-only property named at namelist[XX]. 
                                pop()
                                push('%s'%(name_list[(op1 * 256 + op2)]))

                            else:
                                # Unknown operation
                                flush_stack(file, spacing)
                                file.write("\n")
                                file.write(spacing)
                                file.write('unknown_op3(0x%02x, 0x%02x, 0x%02x);'%(opcode, op1, op2))

                        file.write("\n")

                    file.write("end %s\n\n"%(fname))

                file.close()
 


        # -------------------------- SND ------------------------------------------------------------------
        elif (file_format == SND_FILE_FORMAT):
            # RLE compression?
            file_ext = 'wav'
            
            file_name = "%s.%s"%(nfiles, file_ext)
            if snd_file_name is not None:
                file_name = snd_file_name
                if not file_name.upper().endswith('.WAV'):
                    file_name = "%s.%s"%(file_name, file_ext)

            # Remove strange chars
            file_namer = re.sub(r"[^A-Za-z0-9\-_\.]", "_", file_name)
            if file_namer != file_name:
                try:
                    # Maybe is a japanese file name
                    file_name = file_name.decode('shift-jis')
                except:
                    file_name = file_namer
            file_name = file_name.replace("/", "_")

            try:
                print(u"FILE: Saving file content to: %s"%(file_name))
            except:
                file_name = file_namer
                print(u"FILE: Saving file content to: %s"%(file_name))

            fdata = fileContent[file_offset:(file_offset+file_length+8)]

            # Read data format
            data_format = struct.unpack("cccc", fdata[0:4])
            data_format = ('%c%c%c%c'%(data_format[0], data_format[1], data_format[2], data_format[3]))
            if data_format != file_format:
                print("ERROR: Bad data format! (%s != %s)"%(data_format, file_format))
                sys.exit(-1)

            if len(fdata)<8:
                print("WARNING: Creating empty file!")
                file.close()
                index = index + 20
                nfiles = nfiles + 1
                continue

            # Read file length
            data_length = struct.unpack(bit_order+"i", fdata[4:8])[0]
            if data_length != file_length:
                print("ERROR: Bad data length! (%s != %s)"%(data_length, file_length))
                sys.exit(-1)

            wavef = wave.open(os.path.join(sys.argv[3], file_name),'w')
            idx = 8
            cast_bit_order = '>'

            # Read SND file header
            # 00 02 00 00 
            unknown_00 = struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
            idx += 4
            # 00 01 80 51
            unknown_01 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
            idx += 4
            # 00 00 00 00
            unknown_02 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
            idx += 4
            # 00 0E 00 00
            unknown_03 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
            idx += 4

            unknown_04 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
            idx += 4
 
            # Number of channels
            num_channels =  struct.unpack(cast_bit_order+"h", fdata[idx:idx+2])[0]
            idx += 2

            if num_channels != 1 and num_channels != 2:
                # Unknown short format, lets use default values
                # PCM 8 bits mono 16000Hz
                num_channels =  1
                bps = 8 
                sample_rate = 16000

                unknown_05 =  struct.unpack(cast_bit_order+"h", fdata[idx:idx+2])[0]
                idx += 2

                unknown_07 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
                idx += 4
                unknown_08 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
                idx += 4
                unknown_09 =  struct.unpack(cast_bit_order+"h", fdata[idx:idx+2])[0]
                idx += 2

                unknown_10 = 0
                unknown_11 = 0
                unknown_12 = 0
                unknown_13 = 0
                unknown_14 = 0
                unknown_15 = 0
                unknown_16 = 0
                unknown_17 = 0
                unknown_18 = 0

            else:
                # Sample rate
                sample_rate =  struct.unpack(cast_bit_order+"h", fdata[idx:idx+2])[0]
                idx += 2


                unknown_05 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
                idx += 4
                unknown_06 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
                idx += 4
                unknown_07 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
                idx += 4
                unknown_08 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
                idx += 4
                unknown_09 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
                idx += 4
                unknown_10 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
                idx += 4
                unknown_11 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
                idx += 4
                unknown_12 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
                idx += 4
                unknown_13 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
                idx += 4
                unknown_14 =  struct.unpack(cast_bit_order+"h", fdata[idx:idx+2])[0]
                idx += 2

                # Bits per sample
                bps =  struct.unpack(cast_bit_order+"h", fdata[idx:idx+2])[0]
                idx += 2

                unknown_15 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
                idx += 4
                unknown_16 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
                idx += 4
                unknown_17 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
                idx += 4
                unknown_18 =  struct.unpack(cast_bit_order+"h", fdata[idx:idx+2])[0]
                idx += 2

            print("DEBUG: num_channels = %s"%(num_channels)) 
            print("DEBUG: sample_rate = %s"%(sample_rate)) 
            print("DEBUG: bps = %s"%(bps)) 

            print("DEBUG: unknown_01 = %s"%(unknown_01)) 
            print("DEBUG: unknown_02 = %s"%(unknown_02)) 
            print("DEBUG: unknown_03 = %s"%(unknown_03)) 
            print("DEBUG: unknown_04 = %s"%(unknown_04)) 
            print("DEBUG: unknown_05 = %s"%(unknown_05)) 
            print("DEBUG: unknown_06 = %s"%(unknown_06)) 
            print("DEBUG: unknown_07 = %s"%(unknown_07)) 
            print("DEBUG: unknown_08 = %s"%(unknown_08)) 
            print("DEBUG: unknown_09 = %s"%(unknown_09)) 
            if unknown_04 == 0:
                print("DEBUG: unknown_10 = %s"%(unknown_10)) 
                print("DEBUG: unknown_11 = %s"%(unknown_11)) 
                print("DEBUG: unknown_12 = %s"%(unknown_12)) 
                print("DEBUG: unknown_13 = %s"%(unknown_13)) 
                print("DEBUG: unknown_14 = %s"%(unknown_14)) 
                print("DEBUG: unknown_15 = %s"%(unknown_15)) 
                print("DEBUG: unknown_16 = %s"%(unknown_16)) 
                print("DEBUG: unknown_17 = %s"%(unknown_17)) 
                print("DEBUG: unknown_18 = %s"%(unknown_18)) 


            # Write wave file
            wavef.setnchannels(num_channels)
            wavef.setsampwidth(bps/8) 
            wavef.setframerate(sample_rate)

            if bps == 8:
                # 8 bit per sample
                wavef.writeframesraw( fdata[idx:] )

            elif bps == 16:
                # 16 bit per sample
                # Convert from big endian word to little endian word
                while idx < len(fdata[idx:]):
                    sample =  struct.unpack(">H", fdata[idx:idx+2])[0]
                    idx += 2
                    data = struct.pack('<H', sample)
                    wavef.writeframesraw( data )

            else:
                print("ERROR: Bad number of bits per sample! (%s)"%(bps))
                sys.exit(-1)

            wavef.writeframes('')
            wavef.close()


        # -------------------------- BITD ------------------------------------------------------------------
        elif (file_format == BITD_FILE_FORMAT):
            # RLE compression?
            file_ext = 'bmp'
            
            file_name = "%s.%s"%(nfiles, file_ext)
            if bmp_file_name is not None:
                file_name = bmp_file_name
                if not file_name.upper().endswith('.BMP'):
                    file_name = "%s.%s"%(file_name, file_ext)

            # Remove strange chars
            file_namer = re.sub(r"[^A-Za-z0-9\-_\.]", "_", file_name)
            if file_namer != file_name:
                try:
                    # Maybe is a japanese file name
                    file_name = file_name.decode('shift-jis')
                except:
                    file_name = file_namer
            file_name = file_name.replace("/", "_")

            
            try:
                print(u"FILE: Saving file content to: %s"%(file_name))
            except:
                file_name = file_namer
                print(u"FILE: Saving file content to: %s"%(file_name))


            with open(os.path.join(sys.argv[3], file_name), 'wb') as file:
                fdata = fileContent[file_offset:(file_offset+file_length+8)]
                # Read data format
                data_format = struct.unpack("cccc", fdata[0:4])
                data_format = ('%c%c%c%c'%(data_format[0], data_format[1], data_format[2], data_format[3]))
                if data_format != file_format:
                    print("ERROR: Bad data format! (%s != %s)"%(data_format, file_format))
                    sys.exit(-1)

                if len(fdata)<8:
                    print("WARNING: Creating empty file!")
                    file.close()
                    index = index + 20
                    nfiles = nfiles + 1
                    continue

                # Read file length
                data_length = struct.unpack(bit_order+"i", fdata[4:8])[0]
                if data_length != file_length:
                    print("ERROR: Bad data length! (%s != %s)"%(data_length, file_length))
                    sys.exit(-1)

                # Write Windows bitmap file header
                file.write('BM')
                
                # bmp_width must be divisible by 4
                bmp_wlimit = bmp_width
                if (bmp_width & 3) != 0:
                    bmp_width += 4-(bmp_width & 3)
                    print("Change bmp_width to %s"%(bmp_width))
                    bmp_wlimit += 1

                if bmp_bpp == 4:
                    # 4 bits per pixel image
                    save_4bit_bmp(bmp_width, bmp_height, file, previous_clut, fdata)

                elif bmp_bpp == 8:
                    # 8 bits per pixel image
                    save_8bit_bmp(bmp_width, bmp_height, bmp_wlimit, file, previous_clut, fdata)

                elif bmp_bpp == 16:
                    # 16 bits per pixel image
                    save_16bit_bmp(bmp_width, bmp_height, file, fdata)

                elif bmp_bpp == 24:
                    # 24 bits per pixel image
                    save_24bit_bmp(bmp_width, bmp_height, file, fdata)

                else:
                    print("ERROR: Bad BPP value (%s)"%(bmp_bpp))
                    sys.exit(-1)


        else:
            # Save file content
            file_ext = file_format
            if sys.argv[1] == 'pc':
                file_ext = file_format[3] + file_format[2] + file_format[1] + file_format[0]

            file_name = "%s.%s"%(nfiles, file_ext)
            # Remove strange chars
            file_namer = re.sub(r"[^A-Za-z0-9\-_\.]", "_", file_name)
            if file_namer != file_name:
                try:
                    # Maybe is a japanese file name
                    file_name = file_name.decode('shift-jis')
                except:
                    file_name = file_namer
            file_name = file_name.replace("/", "_")


            try:
                print(u"FILE: Saving file content to: %s"%(file_name))
            except:
                file_name = file_namer
                print(u"FILE: Saving file content to: %s"%(file_name))

            with open(os.path.join(sys.argv[3], file_name), 'wb') as file:
                fdata = fileContent[file_offset:(file_offset+file_length+8)]
                # Read data format
                data_format = struct.unpack("cccc", fdata[0:4])
                data_format = ('%c%c%c%c'%(data_format[0], data_format[1], data_format[2], data_format[3]))
                if data_format != file_format:
                    print("ERROR: Bad data format! (%s != %s)"%(data_format, file_format))
                    sys.exit(-1)

                if len(fdata)<8:
                    print("WARNING: Creating empty file!")
                    file.close()
                    index = index + 20
                    nfiles = nfiles + 1
                    continue

                # Read file length
                data_length = struct.unpack(bit_order+"i", fdata[4:8])[0]
                if data_length != file_length:
                    print("ERROR: Bad data length! (%s != %s)"%(data_length, file_length))
                    sys.exit(-1)

                file.write(fdata[8:])
                file.close()

        index = index + 20
        nfiles = nfiles + 1


def parse_riff(fileContent, offset):
    # Check if file format is RIFX
    file_format = struct.unpack("cccc", fileContent[offset:offset+4])
    file_format = ('%c%c%c%c'%(file_format[0], file_format[1], file_format[2], file_format[3]))

    print("INFO: File format: %s"%(file_format))
    if RIFX_FILE_FORMAT != file_format:
        print("ERROR: File format is not %s"%(RIFX_FILE_FORMAT))
        sys.exit(-1)

    # Read file length
    file_length = struct.unpack(bit_order+"i", fileContent[offset+4:offset+8])[0]
    print("INFO: File contains %s bytes of information."%(file_length))
    if len(fileContent) != file_length + 8 + offset:
        print("ERROR: Bad file length!")
        sys.exit(-1)
 
    # Check Macromedia Director MV93 header
    mv93_format = struct.unpack("cccc", fileContent[offset+8:offset+12])
    mv93_format = ('%c%c%c%c'%(mv93_format[0], mv93_format[1], mv93_format[2], mv93_format[3]))
    print("INFO: Data format: %s"%(mv93_format))
    if MV93_FILE_TYPE != mv93_format:
        print("ERROR: Data format is not %s"%(MV93_FILE_TYPE))
        sys.exit(-1)

    index = offset + 12
    while index < len(fileContent):
        block_type = struct.unpack("cccc", fileContent[index:(index+4)])
        block_type = ('%c%c%c%c'%(block_type[0], block_type[1], block_type[2], block_type[3]))
        print("==================================")
        print("INFO: Block type: %s"%(block_type))

        block_size = struct.unpack(bit_order+"i", fileContent[(index+4):(index+8)])[0]
        print("INFO: Block size: %s"%(block_size))

        block_data = fileContent[(index+8):(index + 8 + block_size)]
        if block_type == IMAP_FILE_FORMAT:
            # Parse 'imap' block
            parse_imap(block_data)

        if block_type == MMAP_FILE_FORMAT:
            # Parse 'mmap' block
            parse_mmap(block_data, fileContent, offset)


        else:
            print("WARNING: Unknown block type!")

        index = index + 8 + block_size


if __name__ == '__main__':
    if len(sys.argv) < 4:
        print("USSAGE: drxtract [pc|mac] <file.drx> <directory>")

    else:
        if sys.argv[1] != 'pc' and sys.argv[1] != 'mac':
            print("ERROR: First argument must be 'pc' or 'mac'")
            sys.exit(-1)

        if sys.argv[1] == 'pc':
            bit_order_type = 'pc'
            bit_order = "<"
            MV93_FILE_TYPE = '39VM'
            RIFX_FILE_FORMAT = 'XFIR'
            IMAP_FILE_FORMAT = 'pami'
            MMAP_FILE_FORMAT = 'pamm'
            FREE_FILE_FORMAT = 'eerf'
            THUM_FILE_FORMAT = 'MUHT'
            BITD_FILE_FORMAT = 'DTIB'
            CLUT_FILE_FORMAT = 'TULC'
            CAST_FILE_FORMAT = 'tSAC'
            SND_FILE_FORMAT = ' dns'
            KEY_FILE_FORMAT = '*YEK'
            CAS_FILE_FORMAT = '*SAC'
            LSCR_FILE_FORMAT = 'rcsL'
            LNAM_FILE_FORMAT = 'manL'

        if not os.path.isfile(sys.argv[2]):
            print("ERROR: '%s' is not a file"%(sys.argv[2]))
            sys.exit(-1)
        
        if not os.path.isdir(sys.argv[3]):
            print("ERROR: '%s' is not a directory"%(sys.argv[3]))
            sys.exit(-1)

        print("Try to parse %s file."%(sys.argv[2]))
        rifx_offset = 0
        with open(sys.argv[2], mode='rb') as file:
            fileContent = file.read()
            if sys.argv[2].upper().endswith('.EXE'):
                # Try to find DRX header inside the EXE file
                content = fileContent
                index = content.find(RIFX_FILE_FORMAT)
                found = False
                while index >= 0 and not found:
                    rifx_offset += index
                    content = content[index:]
                    if content[8:12] == MV93_FILE_TYPE:
                        found = True
                    else:
                        content = content[4:]
                        rifx_offset += 4
                        index = content.find(RIFX_FILE_FORMAT)

            parse_riff(fileContent, rifx_offset)

