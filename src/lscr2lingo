#!/usr/bin/python3

# Author: Abraham Macias Paredes
# E-mail: system252001@yahoo.es
# License: GNU GPL v2 (see LICENSE file for details).

#
# Script to decompile lingo scripts.
# LSCR file format details from: http://fileformats.archiveteam.org/wiki/Lingo_bytecode
# 

import sys
import os
import struct
import re
import logging
import base64
import json
from shutil import copyfile

logging.basicConfig(level=logging.DEBUG)

# For debugging purposes
WRITE_OPCODES = True
WRITE_JUMPS = False

# Default bit order for MAC
bit_order_type = 'mac'
bit_order = ">"

DIR5_LSCR_TYPE = 0xB
DIR4_LSCR_TYPE = 0x00040000

ONE_BYTE_OPCODES = [ 
    0x01, # exit            Leave the current function immediately and return to its caller. Automatically added as the final step of a function.
    0x02, # UNKNOWN
    0x03, # 0 or FALSE      Push zero onto the stack
    0x04, # (a * b)         Pop two values from the stack, multiply them together and push the result.
    0x05, # (a + b)         Pop two values from the stack, add them together and push the result.
    0x06, # (a - b)         Pop two values from the stack, subtract the second from the first and push the result.
    0x07, # (a / b)         Pop two values from the stack, divide the first by the second and push the result.
    0x08, # (a mod b)       Pop two values from the stack, perform a modulo operation and push the result.
    0x09, # (-a)            Pop one value from the stack, negate it and push the result.
    0x0A, # (a & b)         Pop two values from the stack, concatenate them and push the resulting string.
    0x0B, # (a && b)        Pop two values from the stack, concatenate them with one space character added in between, and push the resulting string.
    0x0C, # (a < b)         Pop two values from the stack, push 1 if the first is less than the second and 0 if not.
    0x0D, # (a <= b)        Pop two values from the stack, push 1 if the first is less than or equal to the second and 0 if not.
    0x0E, # (a <> b)        Pop two values from the stack, push 0 if the two values are the same and 1 if they are not.
    0x0F, # (a = b)         Pop two values from the stack, push 1 if the two values are the same and 0 if they are not.
    0x10, # (a > b)         Pop two values from the stack, push 1 if the first is greater than the second and 0 if not.
    0x11, # (a >= b)        Pop two values from the stack, push 1 if the first is greater than or equal to the sceond and 0 if not.
    0x12, # (a and b)       Pop two values from the stack, push 1 if both are logically true and 0 if not.
    0x13, # (a or b)        Pop two values from the stack, push 1 if either are logically true and 0 if not.
    0x14, # (not a)         Pop one value from the stack, push 0 if it is logically true and 1 if not.
    0x15, # (a contains b)  Pop two values from the stack, push 1 if the first is a string that contains the second and 0 if not.
          #                 The text comparison is case-insensitive and ignores diacritic marks.
    0x16, # (a starts b)    Pop two values from the stack, push 1 if the first is a string that begins with second string and 0 if not.
          #                 The text comparison is case-insensitive and ignores diacritic marks.
    0x17, # (split op)      String slice/split operation.
    0x18, # (hilite op)     Highlight (select) some text.
    0x19, # (sprite 1 intersects 2)  Pop two sprite IDs and push 1 if the bounding rectangles of the two sprites touch at all, or 0 if they do not.
    0x1A, # (sprite 1 within 2) Pop two sprite IDs and push 1 if the bounding rectangle of the first is entirely inside the bounding rectangle of the second, or 0 if not.
    0x1B, # (field 1)       Pop a cast ID (name or number), push the value of that cast member's text property.
    0x1C, # tell someObject to go to frame 1   Pop an object from the stack and begin running subsequent bytecodes in the context of that object, until code 1D is encountered.
    0x1D, # tell someObject to go to frame 1   Marker for the end of a sequence of bytecodes started by 1C. Similar to 01 except for nested bytecode chunks instead of the main one.
    0x1E, # UNKNOWN         Some kind of list transformation or check, seen used just before setting the actorList to []. More research is needed to know exactly what is happening there.
    0x1F  # [#key: value]   Pops a list that must be in the form [#symbol1, val1, #symbol2, val2 ...] to transform into [#symbol1: val1, #symbol2: val2 ...]

]

TWO_BYTE_OPCODES = [
    0x41, # push <int>      Push integer of value XX, which must be between 1 and 127, inclusive. To push zero, use 03. To push larger integers, use 81 XX YY.
    0x42, # push <nargs>    Pop the specified number of values off the top of the stack, create an unparenthesized argument list containing them (i.e. for a call statement like myFunction 1, 2, 3), and push that to the stack.
    0x43, # push <list>     op the specified number of values off the top of the stack, create a list for them (which can also be used for a parenthesized call expression like set result = myFunction(1, 2, 3)), 
          #                 and push that to the stack.
    0x44, # push <const>    Push a constant from local constant records onto the stack. These records seem to be six bytes long (regardless of the actual size of the constant value), 
          #                 so pushing the first one is 44 00, the second is 44 06, the third is 44 0C, etc. To push the 65th one and beyond use code 84 YY ZZ
    0x45, # push <sym>      Push a symbol with a name from namelist[XX]. Note that the name will be stored as "name", not "#name".
    0x46, # push <object>   Push a object with a name from namelist[XX]. See also code 86.
    0x47, # UNKNOWN
    0x48, # push <global>   Push the value of a global variable with a name from namelist[XX].
    0x49, # push <global>   Push the value of a global variable with a name from namelist[XX].
    0x4A, # push <prop>     Push the value of a property
    0x4B, # push <param>    Push the value of a function call parameter. The parameter records seem to be 6 bytes long, so the first is pushed with 4B 00, the second with 4B 06, etc.
    0x4C, # push <local>    Push the value of a local variable. The local variable records seem to be 6 bytes long, so the first is pushed with 4C 00, the second with 4C 06, etc.
    0x4D, # UNKNOWN
    0x4E, # put Y into XX   Pop one value and use it to set the global variable with name from namelist[XX].
    0x4F, # set <global>    Pop one value and use it to set the global variable with name from namelist[XX].
    0x50, # set <prop>      Pop one value and use it to set a property.
    0x51, # set <param>     Pop one value and use it to set a parameter.
    0x52, # set <local>     Pop one value and use it to set a local variable. See code 4C 00 for a note about local variable records.
    0x53, # UNKNOWN
    0x54, # end repeat      Unconditional backwards jump by XX bytes, relative to the first byte of this instruction.
    0x55, # UNKNOWN
    0x56, # call <localfn>  Call a function defined in this script with the name at namelist[XX]. 
          #                 The top value on the stack must be an argument list. If the argument list was created with code 43 XX, one return value will be pushed to the stack. 
          #                 If the argument list was created with code 42 XX, no return value will be pushed.
    0x57, # call <globfn>   Call the external function with name from namelist[XX].
    0x58, # call <obj, met> Pop [argument list, call target] to make a method call. If the call target is a literal number, this indicates a local variable is the target. 
          #                 It must be divided by six to get the actual local variable number. The first argument of the argument list will be a symbol with the name of the method. 
          #                 Note: It is still unclear what difference the value of XX makes. It has been seen as 0x01 and 0x05. More research is needed to know more. (Possibly local variables vs. call parameters?)

    0x59, # put value [into/after/before] textVar
    0x5A, # put value (chunkexpression)
    0x5B, # delete something 3 of textVar
    0x5C, # multi operation (depends on the parameters)
    0x5D, # multi operation (depends on the parameters)
    0x5E, # UNKNOWN
    0x5F, # (the someProperty)
    0x60, # set the someProperty to 0
    0x61, # (the someProperty of someVariable)
    0x62, # set the someProperty of someVariable to 1
    0x63, # tell someObject to go to frame 1
    0x64, # UNKNOWN
    0x65, # UNKNOWN
    0x66, # (the pathName)
    0x67  # UNKNOWN

]

# TODO! Fill the comments with explanations of the opcodes

THREE_BYTE_OPCODES = [
    0x81, # UNKNOWN
    0x82, # UNKNOWN
    0x83, # UNKNOWN
    0x84, # UNKNOWN
    0x85, # UNKNOWN
    0x89, # UNKNOWN
    0x8F, # UNKNOWN
    0x90, # UNKNOWN
    0x93, # UNKNOWN
    0x95, # UNKNOWN
    0x96, # UNKNOWN
    0x97, # UNKNOWN
    0x9F, # UNKNOWN
    0xa0, # UNKNOWN
    0xa1, # UNKNOWN
    0xa2, # UNKNOWN
    0xa6, # UNKNOWN
    0xa7  # UNKNOWN
]

NO_PAREN_FUNCTIONS = [
    'put',
    'window',
    'forget',
    'alert',
    'go'
]

SPECIAL_CONSTANTS = {
    '""': 'empty',
    '"\\r"': 'return',
    '"\\""': 'quote',
    '"\\x03"': 'enter'
}

SYSTEM_PROPERTIES = [
    'UNKNOWN_SYSTEM_PROPERTY_00',
    'beepOn',
    'buttonStyle',
    'centerStage',
    'checkBoxAccess',
    'checkBoxType',
    'colorDepth',
    'UNKNOWN_SYSTEM_PROPERTY_07',
    'exitLock',
    'fixStageSize',
    'UNKNOWN_SYSTEM_PROPERTY_0A',
    'UNKNOWN_SYSTEM_PROPERTY_0B',
    'UNKNOWN_SYSTEM_PROPERTY_0C',
    'UNKNOWN_SYSTEM_PROPERTY_0D',
    'UNKNOWN_SYSTEM_PROPERTY_0E',
    'UNKNOWN_SYSTEM_PROPERTY_0F',
    'UNKNOWN_SYSTEM_PROPERTY_10',
    'UNKNOWN_SYSTEM_PROPERTY_11',
    'UNKNOWN_SYSTEM_PROPERTY_12',
    'timeoutLapsed',
    'UNKNOWN_SYSTEM_PROPERTY_14',
    'UNKNOWN_SYSTEM_PROPERTY_15',
    'UNKNOWN_SYSTEM_PROPERTY_16',
    'selEnd',
    'selStart',
    'soundEnabled',
    'soundLevel',
    'stageColor',
    'UNKNOWN_SYSTEM_PROPERTY_1C',
    'stillDown',
    'timeoutKeyDown',
    'timeoutLength',
    'timeoutMouse',
    'timeoutPlay',
    'timer'
    
]


operations_stack = []


# ====================================================================================================================================
def write_code(file, code):
    file.write(code.encode('utf-8'))

# ====================================================================================================================================
def clear_stack():
    operations_stack = []

# ====================================================================================================================================
def push(value):
    operations_stack.append(value)

def pop():
    if len(operations_stack) <= 0:
        return None

    return operations_stack.pop()


def pop_s():
    val = pop()
    if val is None:
        val = 'ERROR_EMPTY_STACK'
    return val

def flush_stack(f, spacing):
    op = pop()
    while op is not None:
        write_code(f, "\n")
        write_code(f, spacing)
        write_code(f, "%s"%(op))
        op = pop()

    write_code(f, "\n")

# ====================================================================================================================================
def to_string(strval):
    strval = strval.replace("\\", "\\\\")
    strval = strval.replace("\"", "\\\"")
    strval = strval.replace("\a", "\\a")
    strval = strval.replace("\b", "\\b")
    strval = strval.replace("\f", "\\f")
    strval = strval.replace("\n", "\\n")
    strval = strval.replace("\r", "\\r")
    strval = strval.replace("\t", "\\t")
    strval = strval.replace("\v", "\\v")
    strval = strval.replace("\v", "\\v")
    return '"' + strval.encode("unicode_escape").decode('ascii') + '"'


# ====================================================================================================================================
def unpack_float80(b):
    e = struct.unpack(">H", b[0:2])[0] 
    q = struct.unpack(">Q", b[2:10])[0]
    m = (q*2.0)/(1<<64)
    
    str = '%s'%(m*pow(2, e - 16383))
    
    return str


# ====================================================================================================================================
def parse_lnam_file(lnam_file):
    name_list = []

    with open(lnam_file, mode='rb') as file:
        fdata = file.read()

        indx = 0
        lnam_bit_order = '>'


        # Unknown header data
        unk = struct.unpack(lnam_bit_order+"i", fdata[(indx):(indx+4)])[0]
        indx = indx + 4
        logging.debug("Unknown: %08x"%(unk))

        unk = struct.unpack(lnam_bit_order+"i", fdata[(indx):(indx+4)])[0]
        indx = indx + 4
        logging.debug("Unknown: %08x"%(unk))

        filesize = struct.unpack(lnam_bit_order+"i", fdata[(indx):(indx+4)])[0]
        indx = indx + 4
        logging.debug("filesize: %08x"%(filesize))

        filesize_cp = struct.unpack(lnam_bit_order+"i", fdata[(indx):(indx+4)])[0]
        indx = indx + 4
        logging.debug("filesize_cp: %08x"%(filesize_cp))

        unk = struct.unpack(lnam_bit_order+"h", fdata[(indx):(indx+2)])[0]
        indx = indx + 2
        logging.debug("Unknown: %08x"%(unk))

        nnames = struct.unpack(lnam_bit_order+"h", fdata[(indx):(indx+2)])[0]
        indx = indx + 2
        logging.debug("Number of names: %s"%(nnames))


        if filesize_cp != filesize:
            logging.error("Bad file size! (%s != %s)"%(filesize_cp, filesize))
            sys.exit(-1)



        for i in range(0, nnames):
            nbytes = int(fdata[indx])
            indx = indx + 1

            name = fdata[indx:(indx + nbytes)].decode('ISO-8859-1')
            indx = indx + nbytes

            name_list.append(name)
            logging.debug("name_list[%s] = %s"%(i, name))
                
    return name_list

# ====================================================================================================================================
def lscr2lingo(lscr_file, name_list):
    file_ext = "lingo"
    nfiles = lscr_file[0:lscr_file.rfind('.')]
    file_name = "%s.%s"%(nfiles, file_ext)
    
    with open(lscr_file, mode='rb') as file:
        fdata = file.read()
        
        lsrc_bit_order = '>'

        idx = 0
        scr_type = struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
        idx += 4
        unknown_01 =  struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
        idx += 4
        filesize0 =  struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
        idx += 4
        filesize1 =  struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
        idx += 4
        unknown_04 =  struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
        idx += 4
        unknown_05 =  struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
        idx += 4
        unknown_06 =  struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
        idx += 4
        unknown_07 =  struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
        idx += 4
        unknown_08 =  struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
        idx += 4
        unknown_09 =  struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
        idx += 4
        unknown_10 =  struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
        idx += 4
        unknown_11 =  struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
        idx += 4
        unknown_12 =  struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
        idx += 4
        unknown_13 =  struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
        idx += 4
        unknown_14 =  struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
        idx += 4
        unknown_15 =  struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
        idx += 4

        logging.debug("scr_type = %08x"%(scr_type)) 
        logging.debug("unknown_01 = %08x"%(unknown_01)) 
        logging.debug("filesize0 = %s"%(filesize0)) 
        logging.debug("filesize1 = %s"%(filesize1)) 
        logging.debug("unknown_04 = %08x"%(unknown_04)) 
        logging.debug("unknown_05 = %08x"%(unknown_05)) 
        logging.debug("unknown_06 = %08x"%(unknown_06)) 
        logging.debug("unknown_07 = %08x"%(unknown_07)) 
        logging.debug("unknown_08 = %08x"%(unknown_08)) 
        logging.debug("unknown_09 = %08x"%(unknown_09)) 
        logging.debug("unknown_10 = %08x"%(unknown_10)) 
        logging.debug("unknown_11 = %08x"%(unknown_11)) 
        logging.debug("unknown_12 = %08x"%(unknown_12)) 
        logging.debug("unknown_13 = %08x"%(unknown_13)) 
        logging.debug("unknown_14 = %08x"%(unknown_14)) 
        logging.debug("unknown_15 = %08x"%(unknown_15)) 

        if filesize1 != filesize0 or filesize1 != len(fdata):
            logging.error("bad filesize (%s, %s, %s)"%(filesize1, filesize0, len(fdata))) 
            sys.exit(-1)

        # $0040-$0041 uint16 Offset to the properties records block  
        prb_offset = struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
        idx += 2

        grb_nrecords =  struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
        idx += 2
        unknown_18 =  struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
        idx += 2

        # $0045-$0046 uint16 Offset to the globals records block  
        grb_offset = struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
        idx += 2

        logging.debug("prb_offset = %s"%(prb_offset)) 
        logging.debug("grb_nrecords = %s"%(grb_nrecords)) 
        logging.debug("unknown_18 = %s"%(unknown_18)) 
        logging.debug("grb_offset = %s"%(grb_offset)) 


        # $0048-$0049 uint16 Number of function records 
        frb_nrecords = struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
        idx += 2

        unknown_19 =  struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
        idx += 2

        # Offset to the function records block repeated
        frb_offset = struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
        idx += 2

        logging.debug("frb_nrecords = %s"%(frb_nrecords)) 
        logging.debug("unknown_19 = %s"%(unknown_19)) 
        logging.debug("frb_offset = %s"%(frb_offset)) 


        # $004E-$004F    uint16  Number of constants 
        con_nconstants = struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
        idx += 2

        unknown_20 =  struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
        idx += 2

        # $0052-$0053  uint16 Offset to the constant records block 
        crb_offset = struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
        idx += 2

        unknown_21 =  struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
        idx += 2

        # Size in bytes of the constants area???
        unknown_22 =  struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
        idx += 2

        unknown_23 =  struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
        idx += 2

        # $005A-$005B uint16 Base address for constant data
        con_offset = struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
        idx += 2

        logging.debug("con_nconstants = %s"%(con_nconstants))
        logging.debug("unknown_20 = %s"%(unknown_20))
        logging.debug("crb_offset = %s"%(crb_offset))
        logging.debug("unknown_21 = %s"%(unknown_21))
        logging.debug("unknown_22 = %s"%(unknown_22))
        logging.debug("unknown_23 = %s"%(unknown_23))
        logging.debug("con_offset = %s"%(con_offset))

        # Read the constants record blocks
        constants = []

        bytes_per_const = 6
        idx = crb_offset

        # In some lingo 
        for i in range(0, con_nconstants):
            logging.debug("idx = %s"%(idx))
            if bytes_per_const == 8:
                # uint32: Value type ID 
                logging.debug("4 bytes constant ID")
                constant_type = struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
                idx += 4
            else:
                # uint16: Value type ID
                logging.debug("2 bytes constant ID")
                constant_type = struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
                idx += 2
                if constant_type == 0:
                    logging.debug("It may be a 4 bytes constant ID")
                    constant_type = struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
                    idx += 2
                    bytes_per_const = 8

            # uint32: Data address, relative to the base address given in the header 
            constant_offset = struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
            idx += 4

            #logging.debug("constant_type = %s"%(constant_type)) 
            #logging.debug("constant_offset = %s"%(constant_offset))

            if constant_type == 1:
                # Text constant
                idxc = con_offset + constant_offset

                # uint32: String length
                strlength = struct.unpack(lsrc_bit_order+"i", fdata[idxc:idxc+4])[0] - 1
                idxc += 4
                #logging.debug("strlength = %s"%(strlength)) 

                strval = fdata[idxc:idxc+strlength].decode('ISO-8859-1')
                constants.append(to_string(strval))


            elif constant_type == 4:
                # 32 bits integer constant
                constants.append(constant_offset)

            elif constant_type == 9:
                # Floating point
                idxc = con_offset + constant_offset
                
                # uint32: Float length
                floatlength = struct.unpack(lsrc_bit_order+"i", fdata[idxc:idxc+4])[0]
                idxc += 4
                #logging.debug("floatlength = %s"%(floatlength))
                
                float_val =  unpack_float80(fdata[idxc:idxc+floatlength])
                #logging.debug("float Value = %s"%(float_val))
                constants.append(float_val)


            else:
                # Unknown
                logging.error("Unknown constant type: %s"%(constant_type))
                sys.exit(-1)

            logging.debug("constants[%s] = %s"%(i, constants[i])) 


        logging.debug(u"FILE: Saving script file to: %s"%(file_name))

        with open(file_name, 'wb') as file:

            if grb_offset != prb_offset:
                # Read the properties record blocks once to get all the properties names
                idx = prb_offset
                pnames = []
                i = 0
                while idx < grb_offset:
                    # $0000-$0001  uint16  Namelist index for the property's name, or 0xFFFF if there is no name(?)
                    namelist_index = struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
                    idx += 2

                    fname = 'noname'
                    if namelist_index >= 0 and namelist_index < len(name_list):
                        fname = name_list[namelist_index]
                    logging.debug('pnames[%d]=%s'%(i, fname))
                    i += 1
                    pnames.append(fname)            
            
                write_code(file, "property %s\n"%(', '.join(pnames)))
            
            if frb_offset != grb_offset:
                # Read the global record blocks once to get all the global var names
                idx = grb_offset
                gnames = []
                i = 0
                while idx < frb_offset:
                    # $0000-$0001  uint16  Namelist index for the property's name, or 0xFFFF if there is no name(?)
                    namelist_index = struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
                    idx += 2

                    fname = 'noname'
                    if namelist_index >= 0 and namelist_index < len(name_list):
                        fname = name_list[namelist_index]
                    logging.debug('pnames[%d]=%s'%(i, fname))
                    i += 1
                    gnames.append(fname)         
                    write_code(file, "global %s\n"%(fname))
            
                write_code(file, "\n")            
            
            # Read the functions record blocks once to get all the local function names
            idx = frb_offset
            lfnames = []
            for i in range(0, frb_nrecords):
                # $0000-$0001  uint16  Namelist index for the function's name, or 0xFFFF if there is no name(?)
                namelist_index = struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
                idx += 42
                
                fname = 'noname'
                if namelist_index >= 0 and namelist_index < len(name_list):
                    fname = name_list[namelist_index]
                logging.debug('lfnames[%d]=%s'%(i, fname))
                lfnames.append(fname)

            # Read the functions record blocks
            idx = frb_offset
            for i in range(0, frb_nrecords):

                logging.debug("Function Record Block: %i (starts in: %x)"%(i, idx)) 
                # $0000-$0001  uint16  Namelist index for the function's name, or 0xFFFF if there is no name(?)
                namelist_index = struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
                idx += 2

                # $0002-$0003  uint16  Unknown
                unknown_rb0 = struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
                idx += 2

                # $0004-$0007  uint32  Length of the function bytecode in bytes
                bc_length = struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
                idx += 4

                # $0008-$000B  uint32  Offset to the function bytecode
                bc_off = struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
                idx += 4

                # $000C-$000D  uint16 Number of arguments
                bc_narg = struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
                idx += 2

                # $000E-$0011  uint32  Offset of arguments name
                argnames_off = struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
                idx += 4

                # $0012-$0013  uint16  Number of local variables
                bc_nlocal = struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
                idx += 2

                # $0014-$0017  uint32  Local variables offset
                localnames_off = struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
                idx += 4

                # $0018-$0019  uint16  Count (C)
                count_c = struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
                idx += 2

                # $001A-$001D  uint32  Unknown
                unknown_rb3 = struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
                idx += 4

                # $001E-$0021  uint32  Unknown
                unknown_rb4 = struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
                idx += 4

                # $0022-$0023  uint16  Unknown
                unknown_rb5 = struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
                idx += 2

                # $0024-$0025  uint16  Count (D)
                count_d = struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
                idx += 2

                # $0026-$0029  uint32  Unknown
                unknown_rb6 = struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
                idx += 4

                logging.debug("namelist_index = %x"%(namelist_index)) 
                logging.debug("unknown_rb0 = %x"%(unknown_rb0)) 
                logging.debug("bc_length = %x"%(bc_length)) 
                logging.debug("bc_off = %x"%(bc_off)) 
                logging.debug("bc_narg = %x"%(bc_narg)) 
                logging.debug("argnames_off = %x"%(argnames_off)) 
                logging.debug("bc_nlocal = %x"%(bc_nlocal)) 
                logging.debug("localnames_off = %x"%(localnames_off)) 
                logging.debug("count_c = %x"%(count_c)) 
                logging.debug("unknown_rb3 = %x"%(unknown_rb3)) 
                logging.debug("unknown_rb4 = %x"%(unknown_rb4)) 
                logging.debug("unknown_rb5 = %x"%(unknown_rb5)) 
                logging.debug("count_d = %x"%(count_d)) 
                logging.debug("unknown_rb6 = %x"%(unknown_rb6)) 


                logging.debug("Function Record Block: %i (ends in: %x)"%(i, idx)) 

                fname = 'noname'
                if namelist_index >= 0 and namelist_index < len(name_list):
                    fname = name_list[namelist_index]

                # Read the local variable names record block
                localvs = []
                for nl in range(0, bc_nlocal):
                    idxl = 2*nl + localnames_off
                    n = struct.unpack(lsrc_bit_order+"h", fdata[idxl:idxl+2])[0]
                    logging.debug("idxl = %x n=%s"%(idxl, n))
                    logging.debug('localvs[%s] = "%s"'%(nl, name_list[n]))
                    localvs.append(name_list[n])

                # Read the parameter names record block
                paramns = []
                for nl in range(0, bc_narg):
                    idxl = 2*nl + argnames_off
                    n = struct.unpack(lsrc_bit_order+"h", fdata[idxl:idxl+2])[0]
                    logging.debug("idxl = %x n=%s"%(idxl, n))
                    logging.debug('paramns[%s] = "%s"'%(nl, name_list[n]))
                    paramns.append(name_list[n])

                args = ''
                for c in range(0, bc_narg):
                    if args == '':
                        args = ('%s'%(paramns[c]))
                    else:
                        args = args + ', ' + ('%s'%(paramns[c]))

                if fname != 'noname':
                    write_code(file, "on %s %s\n"%(fname, args))

                spacing = '    '

                label_indexes = []
                label_types = {}
                global_vars = []
                # Search for loops and globals
                idxc = bc_off
                while (idxc - bc_off) < bc_length:
                    opcode = int(fdata[idxc])
                    idxc = idxc + 1

                    if ((opcode not in ONE_BYTE_OPCODES) and
                        (opcode not in TWO_BYTE_OPCODES) and
                        (opcode not in THREE_BYTE_OPCODES)):
                        logging.error("Unknown opcode: %02x"%(opcode))
                        sys.exit(-1)

                    if opcode in ONE_BYTE_OPCODES:
                        pass

                    elif opcode in TWO_BYTE_OPCODES:
                        # Two bytes operation
                        op1 = int(fdata[idxc])
                        idxc = idxc + 1

                        if opcode == 0x54:
                            # Unconditional backwards jump by XX bytes, relative to the first byte of this instruction. 
                            label_indexes.append(idxc - 2 - op1)
                            label_types[idxc - 2 - op1] = 'repeat while TRUE'
                            label_types[idxc] = 'end repeat'
                        elif opcode == 0x49:
                            # Push the value of a global variable with a name from namelist[XX].  
                            if not name_list[op1] in global_vars:
                                global_vars.append(name_list[op1])
                        elif opcode == 0x4F:
                            # Pop one value and use it to set the global variable with name from namelist[XX].    
                            if not name_list[op1] in global_vars:
                                global_vars.append(name_list[op1])

                    else:
                        # Three bytes operation 
                        op1 = int(fdata[idxc])
                        idxc = idxc + 1

                        op2 = int(fdata[idxc])
                        idxc = idxc + 1

                        if opcode == 0x93:
                            # Unconditional jump: Advance by ((XX * 0x100) + YY) bytes, relative to the first byte of this instruction.
                            label_indexes.append(idxc - 3 + (op1 * 256 + op2))
                            label_types[idxc - 3 + (op1 * 256 + op2)] = 'end if'

                            label_indexes.append(idxc)
                            label_types[idxc] = 'else'

                        elif opcode == 0x95:
                            # Conditional jump: Pop a value, and if it is logically FALSE, advance by ((XX * 0x100) + YY) bytes, relative to the first byte of this instruction. 
                            label_indexes.append(idxc - 3 + (op1 * 256 + op2))
                            label_types[idxc - 3 + (op1 * 256 + op2)] = 'end if'

                        elif opcode == 0x89:
                            # Push the value of a global variable with a name from namelist[XX].  
                            if not name_list[op1] in global_vars:
                                global_vars.append(name_list[op1 * 256 + op2])
                        elif opcode == 0x8F:
                            # Pop one value and use it to set the global variable with name from namelist[XX].    
                            if not name_list[op1] in global_vars:
                                global_vars.append(name_list[op1 * 256 + op2])


                # Generate code
                clear_stack()
                window_to_tell = None

                for gv in global_vars:
                    write_code(file, spacing)
                    write_code(file, "global %s\n"%(gv))

                idxc = bc_off
                while (idxc - bc_off) < bc_length:
                    if idxc in label_indexes:
                        nends = 1
                        if (idxc in label_types) and label_types[idxc].startswith('end'):
                            nends = label_indexes.count(idxc)
                        
                        for nlabel in range(0, nends):
                            # Can be more than one "end if" in the same position
                            if idxc in label_types:
                                if label_types[idxc].startswith('end') or label_types[idxc] == 'else':
                                    spacing = spacing[0:(len(spacing) - 4)]

                                write_code(file, spacing)
                                write_code(file, "%s\n"%(label_types[idxc]))
                                if not label_types[idxc].startswith('end'):
                                    spacing = spacing + '    '

                            else:
                                write_code(file, "label%08x\n"%(idxc))

                    write_code(file, spacing)

                    opcode = int(fdata[idxc])
                    idxc = idxc + 1

                    if ((opcode not in ONE_BYTE_OPCODES) and
                        (opcode not in TWO_BYTE_OPCODES) and
                        (opcode not in THREE_BYTE_OPCODES)):
                        logging.error("Unknown opcode: %02x"%(opcode))
                        sys.exit(-1)

                    if opcode in ONE_BYTE_OPCODES:
                        # One byte operation
                        if WRITE_OPCODES:
                            write_code(file, "-- [0x%04x]: 0x%02x"%(idxc - 1, opcode))

                        if opcode == 0x01:
                            flush_stack(file, spacing)
                            if (idxc - bc_off) < bc_length:
                                write_code(file, '\n')
                                write_code(file, spacing)
                                write_code(file, 'exit\n')

                        elif opcode == 0x03:
                            push('0')

                        elif opcode == 0x04:
                            op2 = pop_s()
                            op1 = pop_s()
                            push('(' + op1 + ' * ' + op2 + ')')

                        elif opcode == 0x04:
                            op2 = pop_s()
                            op1 = pop_s()
                            push('(' + op1 + ' * ' + op2 + ')')

                        elif opcode == 0x05:
                            op2 = pop_s()
                            op1 = pop_s()
                            push('(' + op1 + ' + ' + op2 + ')')

                        elif opcode == 0x06:
                            op2 = pop_s()
                            op1 = pop_s()
                            push('(' + op1 + ' - ' + op2 + ')')

                        elif opcode == 0x07:
                            op2 = pop_s()
                            op1 = pop_s()
                            push('(' + op1 + ' / ' + op2 + ')')

                        elif opcode == 0x08:
                            op2 = pop_s()
                            op1 = pop_s()
                            push('(' + op1 + ' mod ' + op2 + ')')

                        elif opcode == 0x09:
                            push('-' + pop_s())

                        elif opcode == 0x0A:
                            op2 = pop_s()
                            op1 = pop_s()
                            push('('+ op1 + ' & ' + op2 + ')')

                        elif opcode == 0x0B:
                            op2 = pop_s()
                            op1 = pop_s()
                            push('(' + op1 + ' && ' + op2 + ')')

                        elif opcode == 0x0C:
                            op2 = pop_s()
                            op1 = pop_s()
                            push('(' + op1 + ' < ' + op2 + ')')

                        elif opcode == 0x0D:
                            op2 = pop_s()
                            op1 = pop_s()
                            push('(' + op1 + ' <= ' + op2 + ')')

                        elif opcode == 0x0E:
                            op2 = pop_s()
                            op1 = pop_s()
                            push('(' + op1 + ' <> ' + op2 + ')')

                        elif opcode == 0x0F:
                            op2 = pop_s()
                            op1 = pop_s()
                            push('(' + op1 + ' = ' + op2 + ')')

                        elif opcode == 0x10:
                            op2 = pop_s()
                            op1 = pop_s()
                            push('(' + op1 + ' > ' + op2 + ')')

                        elif opcode == 0x11:
                            op2 = pop_s()
                            op1 = pop_s()
                            push('(' + op1 + ' >= ' + op2 + ')')

                        elif opcode == 0x12:
                            op2 = pop_s()
                            op1 = pop_s()
                            push('(' + op1 + ' and ' + op2 + ')')

                        elif opcode == 0x13:
                            op2 = pop_s()
                            op1 = pop_s()
                            push('(' + op1 + ' or ' + op2 + ')')

                        elif opcode == 0x14:
                            push('(not ' + pop_s() + ')')

                        elif opcode == 0x15:
                            op2 = pop_s()
                            op1 = pop_s()
                            push('(' + op1 + ' contains ' + op2 + ')')

                        elif opcode == 0x16:
                            op2 = pop_s()
                            op1 = pop_s()
                            push('(' + op1 + ' starts ' + op2 + ')')


                        elif opcode == 0x17:
                            op_str = pop_s()       # The string to slice
                            op_ll_pos = pop_s()    # Last line position
                            op_fl_pos = pop_s()    # First line position
                            op_li_pos = pop_s()    # Last item position
                            op_fi_pos = pop_s()    # First item position (items separated by the itemDelimiter, which is a comma by default)
                            op_lw_pos = pop_s()    # Last word position
                            op_fw_pos = pop_s()    # First word position
                            op_lc_pos = pop_s()    # Last char position
                            op_fc_pos = pop_s()    # First char position

                            operation = ''

                            if op_fc_pos != '0':
                                operation = operation + ('char %s '%(op_fc_pos))
                                if op_lc_pos != '0':
                                    operation = operation + ('to %s '%(op_lc_pos))
                                operation = operation + 'of '

                            if op_fw_pos != '0':
                                operation = operation + ('word %s '%(op_fw_pos))
                                if op_lw_pos != '0':
                                    operation = operation + ('to %s '%(op_lw_pos))
                                operation = operation + 'of '

                            if op_fi_pos != '0':
                                operation = operation + ('item %s '%(op_fi_pos))
                                if op_li_pos != '0':
                                    operation = operation + ('to %s '%(op_li_pos))
                                operation = operation + 'of '

                            if op_fl_pos != '0':
                                operation = operation + ('line %s '%(op_fl_pos))
                                if op_ll_pos != '0':
                                    operation = operation + ('to %s '%(op_ll_pos))
                                operation = operation + 'of '

                            operation = operation + op_str

                            push(operation)


                        elif opcode == 0x18:
                            op_cid = pop_s()       # Field number (cast ID
                            op_ll_pos = pop_s()    # Last line position
                            op_fl_pos = pop_s()    # First line position
                            op_li_pos = pop_s()    # Last item position
                            op_fi_pos = pop_s()    # First item position (items separated by the itemDelimiter, which is a comma by default)
                            op_lw_pos = pop_s()    # Last word position
                            op_fw_pos = pop_s()    # First word position
                            op_lc_pos = pop_s()    # Last char position
                            op_fc_pos = pop_s()    # First char position

                            operation = ''

                            if op_fc_pos != '0':
                                operation = operation + ('char %s '%(op_fc_pos))
                                if op_lc_pos != '0':
                                    operation = operation + ('to %s '%(op_lc_pos))
                                operation = operation + 'of '

                            if op_fw_pos != '0':
                                operation = operation + ('word %s '%(op_fw_pos))
                                if op_lw_pos != '0':
                                    operation = operation + ('to %s '%(op_lw_pos))
                                operation = operation + 'of '

                            if op_fi_pos != '0':
                                operation = operation + ('item %s '%(op_fi_pos))
                                if op_li_pos != '0':
                                    operation = operation + ('to %s '%(op_li_pos))
                                operation = operation + 'of '

                            if op_fl_pos != '0':
                                operation = operation + ('line %s '%(op_fl_pos))
                                if op_ll_pos != '0':
                                    operation = operation + ('to %s '%(op_ll_pos))
                                operation = operation + 'of '

                            operation = 'hilite ' + operation + 'field ' + op_cid

                            push(operation)

                        elif opcode == 0x19:
                            op2 = pop_s()
                            op1 = pop_s()

                            push('%s intersects %s'%(op1, op2))

                        elif opcode == 0x1A:
                            op2 = pop_s()
                            op1 = pop_s()

                            push('sprite_within(' + op1 + ', ' + op2 + ')')

                        elif opcode == 0x1B:
                            push('field ' + pop_s())

                        elif opcode == 0x1C:
                            # Start of "tell" operation
                            window_to_tell = pop_s()

                        elif opcode == 0x1D:
                            # End of "tell" operation
                            params = ''
                            p = pop()
                            while p is not None:
                                if params == '':
                                    params = p
                                else:
                                    params = params + ' ' + p
                                p = pop()

                            write_code(file, "\n")
                            write_code(file, spacing)
                            write_code(file, 'tell ' + window_to_tell + ' to ' + params)

                        elif opcode == 0x1E:
                            # Convert to list
                            lval = pop_s()
                            if lval.startswith('<'):
                                lval = lval[1:]
                            push('[%s]'%(lval))                            
                            
                        elif opcode == 0x1F:
                            lval = pop_s()
                            if lval.startswith('<'):
                                lval = lval[1:]
                            plval = ''
                            pv = lval.split(', ')
                            for i in range(0, int(len(pv) / 2)):
                                p = pv[i*2]
                                v = pv[i*2+1]
                                plval = plval + ', ' + p + ': ' + v
                            
                            if plval == '':
                                plval = ':'
                            else:
                                plval = plval[2:]
                            push('[%s]'%(plval))


                    elif opcode in TWO_BYTE_OPCODES:
                        # Two bytes operation
                        op1 = int(fdata[idxc])
                        idxc = idxc + 1

                        if WRITE_OPCODES:
                            write_code(file, "-- [0x%04x]: 0x%02x 0x%02x"%(idxc - 2, opcode, op1))


                        if opcode == 0x41:
                            # Push integer of value XX, which must be between 1 and 127, inclusive.
                            v = int(op1)
                            if v > 127:
                                v = v - 256
                            push('%s'%(v))

                        elif opcode == 0x42:
                            # Pop the specified number of values off the top of the stack, create an unparenthesized argument list containing them 
                            # (i.e. for a call statement like myFunction 1, 2, 3), and push that to the stack.
                            params = ''
                            for c in range(0, op1):
                                p = pop_s()
                                if params == '':
                                    params = p
                                else:
                                    params = p + ', ' + params

                            push(params)

                        elif opcode == 0x43:
                            # Pop the specified number of values off the top of the stack, create a list for them (which can also be used for a parenthesized call expression like set result = myFunction(1, 2, 3)), 
                            # and push that to the stack.
                            params = ''
                            for c in range(0, op1):
                                p = pop_s()
                                if params == '':
                                    params = p
                                else:
                                    params = p + ', ' + params

                            push('<%s'%(params))

                        elif opcode == 0x44:
                            # Push a constant from local constant records onto the stack. These records seem to be six bytes long (regardless of the actual size of the constant value), 
                            # so pushing the first one is 44 00, the second is 44 06, the third is 44 0C, etc. 
                            if (op1 % bytes_per_const) > 0:
                                bytes_per_const = (op1 % bytes_per_const)

                            constant_value = constants[int(op1 / bytes_per_const)]
                            if constant_value in SPECIAL_CONSTANTS:
                                constant_value = SPECIAL_CONSTANTS[constant_value]
                            push('%s'%(constant_value))

                        elif opcode == 0x45:
                            # Push a symbol with a name from namelist[XX]. Note that the name will be stored as "name", not "#name". 
                            push('#%s'%(name_list[op1]))

                        elif opcode == 0x46:
                            # Push a object with a name from namelist[XX]. 
                            push('%s'%(name_list[op1]))

                        elif opcode == 0x48:
                            # Push the value of a global variable with a name from namelist[XX].  
                            push('%s'%(name_list[op1]))                            
                            
                        elif opcode == 0x49:
                            # Push the value of a global variable with a name from namelist[XX].  
                            push('%s'%(name_list[op1]))

                        elif opcode == 0x4A:
                            # Push the value of a property.  
                            push('the %s'%(name_list[op1]))

                        elif opcode == 0x4B:
                            # Push the value of a function call parameter. The parameter records seem to be 6 bytes long, so the first is pushed with 4B 00, the second with 4B 06, etc.
                            if (op1 % bytes_per_const) > 0:
                                bytes_per_const = (op1 % bytes_per_const)

                            push('%s'%(paramns[int(op1 / bytes_per_const)]))

                        elif opcode == 0x4C:
                            # Push the value of a function call parameter. The parameter records seem to be 6 bytes long, so the first is pushed with 4B 00, the second with 4B 06, etc.   
                            if (op1 % bytes_per_const) > 0:
                                bytes_per_const = (op1 % bytes_per_const)

                            push('%s'%(localvs[int(op1 / bytes_per_const)]))

                        elif opcode == 0x4E:
                            # Pop one value and use it to set the global variable with name from namelist[XX].    
                            write_code(file, "\n")
                            write_code(file, spacing)
                            write_code(file, 'put %s into %s'%(pop_s(), name_list[op1]))                         
                            
                        elif opcode == 0x4F:
                            # Pop one value and use it to set the global variable with name from namelist[XX].    
                            write_code(file, "\n")
                            write_code(file, spacing)
                            write_code(file, 'put %s into %s'%(pop_s(), name_list[op1]))

                        elif opcode == 0x50:
                            # Pop one value and use it to set a property.
                            write_code(file, "\n")
                            write_code(file, spacing)
                            write_code(file, 'set %s = %s'%(name_list[op1], pop_s()))

                        elif opcode == 0x51:
                            # Pop one value and use it to set a parameter. 
                            write_code(file, "\n")
                            write_code(file, spacing)
                            if (op1 % bytes_per_const) > 0:
                                bytes_per_const = (op1 % bytes_per_const)

                            write_code(file, 'put %s into %s'%(pop_s(), paramns[int(op1 / bytes_per_const)]))

                        elif opcode == 0x52:
                            # Pop one value and use it to set a local variable.
                            write_code(file, "\n")
                            write_code(file, spacing)
                            if (op1 % bytes_per_const) > 0:
                                bytes_per_const = (op1 % bytes_per_const)

                            write_code(file, 'put %s into %s'%(pop_s(), localvs[int(op1 / bytes_per_const)]))

                        elif opcode == 0x54:
                            # Unconditional backwards jump by XX bytes, relative to the first byte of this instruction.
                            if WRITE_JUMPS:
                                write_code(file, "\n")
                                write_code(file, spacing)
                                write_code(file, '-- goto label%04x;'%(idxc - 2 - op1))


                        elif opcode == 0x56:
                            # Call a function defined in this script with the name at lfnames[XX].
                            params = pop_s()
                            if params.startswith('<'):
                                # The function must return something
                                push('%s(%s)'%(lfnames[op1], params[1:]))
                            else:
                                write_code(file, "\n")
                                write_code(file, spacing)
                                write_code(file, '%s(%s)'%(lfnames[op1], params))

                        elif opcode == 0x57:
                            # Call the external function with name from namelist[XX].
                            params = pop_s()
                            if params.startswith('<'):
                                # The function must return something
                                if name_list[op1] in NO_PAREN_FUNCTIONS:
                                    push('%s %s'%(name_list[op1], params[1:]))
                                else:
                                    push('%s(%s)'%(name_list[op1], params[1:]))
                            else:
                                write_code(file, "\n")
                                write_code(file, spacing)
                                if name_list[op1] in NO_PAREN_FUNCTIONS:
                                    write_code(file, '%s %s'%(name_list[op1], params))
                                else:
                                    write_code(file, '%s(%s)'%(name_list[op1], params))

                        elif opcode == 0x58:
                            # Call an object method
                            obj = pop_s()
                            if obj.isdigit():
                                obj = ('%s'%(localvs[obj]))

                            params = pop_s()
                            if params.startswith('<'):
                                # The function must return something
                                push('%s(%s)'%(obj, params[1:]))
                            else:
                                write_code(file, "\n")
                                write_code(file, spacing)
                                write_code(file, '%s(%s)'%(obj, params))

                        elif opcode == 0x59:
                            if op1 == 0x16:
                                op_var = pop_s()
                                op_value = pop_s()

                                write_code(file, "\n")
                                write_code(file, spacing)

                                write_code(file, 'put %s into field %s'%(op_value, op_var))

                            elif op1 == 0x25:
                                op_var = pop_s()
                                op_value = pop_s()

                                write_code(file, "\n")
                                write_code(file, spacing)
                                if (op_var % bytes_per_const) > 0:
                                    bytes_per_const = (op_var % bytes_per_const)

                                write_code(file, 'put %s after %s'%(op_value, localvs[int(op_var / bytes_per_const)]))
                                
                            elif op1 == 0x26:
                                op_var = pop_s()
                                op_value = pop_s()

                                write_code(file, "\n")
                                write_code(file, spacing)

                                write_code(file, 'put %s after field %s'%(op_value, op_var))

                            elif op1 == 0x35:
                                op_var = pop_s()
                                op_value = pop_s()

                                write_code(file, "\n")
                                write_code(file, spacing)
                                if (op_var % bytes_per_const) > 0:
                                    bytes_per_const = (op_var % bytes_per_const)

                                write_code(file, 'put %s before %s'%(localvs[int(op_value, op_var / bytes_per_const)]))

                            elif op1 == 0x36:
                                op_var = pop_s()
                                op_value = pop_s()

                                write_code(file, "\n")
                                write_code(file, spacing)

                                write_code(file, 'put %s before field %s'%(op_value, op_var))
                                
                            else:
                                write_code(file, "\n")
                                write_code(file, spacing)
                                write_code(file, "ERROR: Missing subcommand! (0x%02x) :("%(op1))

                        # TODO! Complete this

                        elif opcode == 0x5B:
                            if op1 == 0x06:
                                op_str = pop_s()       # The string to slice
                                op_ll_pos = pop_s()    # Last line position
                                op_fl_pos = pop_s()    # First line position
                                op_li_pos = pop_s()    # Last item position
                                op_fi_pos = pop_s()    # First item position (items separated by the itemDelimiter, which is a comma by default)
                                op_lw_pos = pop_s()    # Last word position
                                op_fw_pos = pop_s()    # First word position
                                op_lc_pos = pop_s()    # Last char position
                                op_fc_pos = pop_s()    # First char position

                                operation = ''

                                if op_fc_pos != '0':
                                    operation = operation + ('char %s '%(op_fc_pos))
                                    if op_lc_pos != '0':
                                        operation = operation + ('to %s '%(op_lc_pos))
                                    operation = operation + 'of '

                                if op_fw_pos != '0':
                                    operation = operation + ('word %s '%(op_fw_pos))
                                    if op_lw_pos != '0':
                                        operation = operation + ('to %s '%(op_lw_pos))
                                    operation = operation + 'of '

                                if op_fi_pos != '0':
                                    operation = operation + ('item %s '%(op_fi_pos))
                                    if op_li_pos != '0':
                                        operation = operation + ('to %s '%(op_li_pos))
                                    operation = operation + 'of '

                                if op_fl_pos != '0':
                                    operation = operation + ('line %s '%(op_fl_pos))
                                    if op_ll_pos != '0':
                                        operation = operation + ('to %s '%(op_ll_pos))
                                    operation = operation + 'of '

                                operation = operation + 'field ' + op_str

                                write_code(file, "\n")
                                write_code(file, spacing)
                                write_code(file, 'delete ' + operation)
                            else:
                                write_code(file, "\n")
                                write_code(file, spacing)
                                write_code(file, "ERROR: Missing subcommand! (0x%02x) :("%(op1))

                        elif opcode == 0x5C:
                            if op1 == 0x00:
                                # Date/time/char operations
                                op_type = int(pop())
                                op_types = ['floatPrecision', 'mouseDownScript', 'mouseUpScript', 'keyDownScript',
                                            'keyUpScript', 'timeoutScript', 'short time', 'abbreviated time', 'long time',
                                            'short date', 'abbreviated date', 'long date', 'last char', 'last word',
                                            'last item', 'last line']
                                if (op_type < 0x0c):
                                    push('the %s'%(op_types[op_type]))
                                else:
                                    op_var = pop_s()
                                    push('the %s of %s'%(op_types[op_type], op_var))
                                
                            elif op1 == 0x01:
                                # the number of chars in someText
                                op_type = int(pop())
                                op_var = pop_s()
                                op_types = ['chars', 'words', 'items', 'lines']
                                push('the number of %s of %s'%(op_types[op_type - 1], op_var))
                                
                            elif op1 == 0x03:
                                # the <property> of menuItem <ID> of menu <ID>
                                op_property = int(pop())
                                op_menu_id = pop_s()
                                op_menu_item_id = pop_s()
                                
                                op_properties = [
                                    'name', 'checkMark', 'enabled', 'script'
                                ]

                                push('the %s of menuItem %s of menu %s'%(op_properties[op_property - 1], op_menu_item_id, op_menu_id))
                                
                            elif op1 == 0x06:
                                # the <property> of sprite ID
                                op_property = int(pop())
                                op_var = pop_s()
                                op_properties = [
                                    'type', 'backColor', 'bottom', 'castNum', 'constraint', 'cursor',
                                    'foreColor', 'height', 'UNKNOWN1', 'ink', 'left', 'lineSize', 'locH',
                                    'locV', 'movieRate', 'movieTime', 'UNKNOWN2', 'puppet', 'right',
                                    'startTime', 'stopTime', 'stretch', 'top', 'trails', 'visible',
                                    'volume', 'width', 'blend', 'scriptNum', 'moveableSprite',
                                    'UNKNOWN3', 'scoreColor'
                                ]
                                push('the %s of sprite %s'%(op_properties[op_property - 1], op_var))

                            elif op1 == 0x07:
                                # Pop a setting ID from the stack and push its value
                                setting_id = int(pop())
                                setting_name = 'UNKNOWN_PROPERTY_%s'%(setting_id)
                                if setting_id < len(SYSTEM_PROPERTIES):
                                    setting_name = SYSTEM_PROPERTIES[setting_id]
                                push("the %s"%(setting_name))     
                                
                            elif op1 == 0x09:
                                # the <property> of cast ID
                                op_property = int(pop())
                                op_var = pop_s()
                                op_properties = [
                                    'name', 'text', 'UNKNOWN2', 'UNKNOWN3', 'UNKNOWN4', 'UNKNOWN5',
                                    'UNKNOWN6', 'picture', 'hilite', 'number', 'size', 'UNKNOWN8',
                                    'UNKNOWN9', 'UNKNOWNA', 'UNKNOWNB', 'UNKNOWNC', 'foreColor', 'backColor'
                                ]
                                push('the %s of cast %s'%(op_properties[op_property - 1], op_var))
                                
                            elif op1 == 0x0d:
                                # (digital video property)
                                # the <property> of cast ID
                                op_property = int(pop())
                                op_var = pop_s()
                                op_properties = [
                                    'UNKNOWN1', 'UNKNOWN2', 'UNKNOWN3', 'UNKNOWN4', 'UNKNOWN5', 'UNKNOWN6',
                                    'UNKNOWN7', 'UNKNOWN8', 'UNKNOWN9', 'UNKNOWNA', 'UNKNOWNB', 'loop',
                                    'duration', 'controller', 'directToStage', 'sound'
                                ]
                                push('the %s of cast %s'%(op_properties[op_property - 1], op_var))
                                
                            else:
                                write_code(file, "\n")
                                write_code(file, spacing)
                                write_code(file, "ERROR: Missing subcommand! (0x%02x) :("%(op1))

                        elif opcode == 0x5D:
                            if op1 == 0x00:
                                # Date/time/char operations
                                write_code(file, "\n")
                                write_code(file, spacing)
                                op_type = int(pop())
                                op_types = ['floatPrecision', 'mouseDownScript', 'mouseUpScript', 'keyDownScript',
                                            'keyUpScript', 'timeoutScript', 'short time', 'abbreviated time', 'long time',
                                            'short date', 'abbreviated date', 'long date', 'last char', 'last word',
                                            'last item', 'last line']
                                if (op_type < 0x0c):
                                    op_val = pop_s()
                                    write_code(file, 'set the %s to %s'%(op_types[op_type], op_val))
                                else:
                                    op_var = pop_s()
                                    op_val = pop_s()
                                    write_code(file, 'set the %s of %s to %s'%(op_types[op_type], op_var, op_val))
                                    
                            elif op1 == 0x03:
                                # the <property> of menuItem <ID> of menu <ID> to <value>
                                write_code(file, "\n")
                                write_code(file, spacing)
                                op_property = int(pop())
                                op_var = pop_s()
                                op_menu_id = pop_s()
                                op_menu_item_id = pop_s()
                                
                                op_properties = [
                                    'name', 'checkMark', 'enabled', 'script'
                                ]

                                write_code(file, 'set the %s of menuItem %s of menu %s to %s'%(op_properties[op_property - 1], op_menu_item_id, op_menu_id, op_var))

                            elif op1 == 0x06:
                                # the <property> of sprite ID
                                write_code(file, "\n")
                                write_code(file, spacing)
                                op_property = int(pop())
                                op_var = pop_s()
                                op_property_id = pop_s()
                                
                                op_properties = [
                                    'type', 'backColor', 'bottom', 'castNum', 'constraint', 'cursor',
                                    'foreColor', 'height', 'UNKNOWN1', 'ink', 'left', 'lineSize', 'locH',
                                    'locV', 'movieRate', 'movieTime', 'UNKNOWN2', 'puppet', 'right',
                                    'startTime', 'stopTime', 'stretch', 'top', 'trails', 'visible',
                                    'volume', 'width', 'blend', 'scriptNum', 'moveableSprite',
                                    'editableText', 'scoreColor'
                                ]

                                write_code(file, 'set the %s of sprite %s to %s'%(op_properties[op_property - 1], op_property_id, op_var))
                                
                            elif op1 == 0x07:
                                # Pop a setting ID from the stack and push its value
                                write_code(file, "\n")
                                write_code(file, spacing)
                                setting_id = int(pop())
                                setting_name = 'UNKNOWN_PROPERTY_%s'%(setting_id)
                                if setting_id < len(SYSTEM_PROPERTIES):
                                    setting_name = SYSTEM_PROPERTIES[setting_id]
                                write_code(file, "put %s into the %s"%(pop_s(), setting_name))
                                
                            elif op1 == 0x09:
                                # the <property> of cast ID
                                write_code(file, "\n")
                                write_code(file, spacing)
                                op_property = int(pop())
                                op_var = pop_s()
                                cast_id = pop_s()
                                
                                op_properties = [
                                    'name', 'text', 'UNKNOWN2', 'UNKNOWN3', 'UNKNOWN4', 'UNKNOWN5',
                                    'UNKNOWN6', 'picture', 'hilite', 'number', 'size', 'UNKNOWNA',
                                    'UNKNOWNB', 'UNKNOWNC', 'UNKNOWND', 'UNKNOWNE', 'foreColor', 'backColor'
                                ]
                                
                                write_code(file, 'set the %s of cast %s to %s'%(op_properties[op_property - 1], cast_id, op_var))
                                
                            elif op1 == 0x0d:
                                # (digital video property)
                                # the <property> of cast ID
                                write_code(file, "\n")
                                write_code(file, spacing)
                                op_property = int(pop())
                                op_var = pop_s()
                                cast_id = pop_s()
                                
                                op_properties = [
                                    'UNKNOWN1', 'UNKNOWN2', 'UNKNOWN3', 'UNKNOWN4', 'UNKNOWN5', 'UNKNOWN6',
                                    'UNKNOWN7', 'UNKNOWN8', 'UNKNOWN9', 'UNKNOWNA', 'UNKNOWNB', 'loop',
                                    'duration', 'controller', 'directToStage', 'sound'
                                ]
                                
                                write_code(file, 'set the %s of cast %s to %s'%(op_properties[op_property - 1], cast_id, op_var))
                                
                            else:
                                write_code(file, "\n")
                                write_code(file, spacing)
                                write_code(file, "ERROR: Missing subcommand! (0x%02x) :("%(op1))


                        elif opcode == 0x5F:
                            # Push the value of the contextual property with the name at namelist[XX].
                            push('the %s'%(name_list[op1]))

                        elif opcode == 0x60:
                            # set the <property> to <value>
                            params = pop_s()
                            write_code(file, "\n")
                            write_code(file, spacing)
                            write_code(file, 'set the %s = %s'%(name_list[op1], params))   
                            
                        # TODO! Complete this
                        elif opcode == 0x61:
                            # (the someProperty of someVariable)
                            # Pop a property-owning object from the stack, and push the value of this object's property with the name at namelist[XX].  
                            push('the %s.%s '%(pop_s(), name_list[op1]))

                        elif opcode == 0x62:
                            # set the someProperty of someVariable to 1
                            # Pop [property-owning object, new value] from the stack and set the property of the object with the name at namelist[XX].
                            write_code(file, "\n")
                            write_code(file, spacing)
                            write_code(file, 'put %s into %s.%s '%(pop_s(), pop_s(), name_list[op1]))

                        elif opcode == 0x63:
                            # property to tell  
                            push('%s'%(name_list[op1]))

                        elif opcode == 0x64:
                            # Push a copy of a value already on the stack, relative to the top where 00 is the top slot, 01 is one slot beneath the top, etc. 
                            tmp = []
                            for i in range(0, op1):
                                tmp.append(pop_s())
                                
                            val = pop_s()
                            push(val)
                            
                            for i in range(0, op1):
                                push(tmp.pop())
                            
                            push(val)

                        elif opcode == 0x65:
                            # Pop and discard XX values from the top of the stack.
                            for i in range(0, op1):
                                pop_s()

                        elif opcode == 0x66:
                            # Pop an empty list and push the value of a read-only property named at namelist[XX]. 
                            pop()
                            push('the %s'%(name_list[op1]))

                        elif opcode == 0x67:
                            # Call a method of an object with name from namelist[XX].
                            params = pop_s()
                            cindex = op1
                            if params.startswith('<'):
                                # The function must return something
                                params = params[1:]
                                obj = params[0:params.index(',')]
                                params = params[params.index(',')+2:]
                                if name_list[cindex] in NO_PAREN_FUNCTIONS:
                                    push('%s.%s %s'%(obj, name_list[cindex], params))
                                else:
                                    push('%s.%s(%s)'%(obj, name_list[cindex], params))
                            else:
                                obj = params[0:params.index(',')]
                                params = params[params.index(',')+2:]
                                write_code(file, "\n")
                                write_code(file, spacing)
                                if name_list[cindex] in NO_PAREN_FUNCTIONS:
                                    write_code(file, '%s.%s %s'%(obj, name_list[cindex], params))
                                else:
                                    write_code(file, '%s.%s(%s)'%(obj, name_list[cindex], params))

                        else:
                            # Unknown operation
                            flush_stack(file, spacing)
                            write_code(file, "\n")
                            write_code(file, spacing)
                            write_code(file, 'unknown_op2(0x%02x, 0x%02x);'%(opcode, op1))

                    else:
                        # Three bytes operation 
                        op1 = int(fdata[idxc])
                        idxc = idxc + 1

                        op2 = int(fdata[idxc])
                        idxc = idxc + 1

                        if WRITE_OPCODES:
                            write_code(file, "-- [0x%04x]: 0x%02x 0x%02x 0x%02x"%(idxc - 3, opcode, op1, op2))

                        if opcode == 0x81:
                            # Push the integer ((XX * 0x100) + YY).
                            push('%s'%(op1 * 256 + op2))

                        elif opcode == 0x82:
                            # Pop the specified number of values off the top of the stack, create an unparenthesized argument list containing them 
                            # (i.e. for a call statement like myFunction 1, 2, 3), and push that to the stack.
                            push('arglist(%s)'%(op1 * 256 + op2))

                        elif opcode == 0x83:
                            # Pop the specified number of values off the top of the stack, create a list for them (which can also be used for a parenthesized call expression like set result = myFunction(1, 2, 3)), 
                            # and push that to the stack.
                            push('list(%s)'%(op1 * 256 + op2))

                        elif opcode == 0x84:
                            # Push a constant from local constant records onto the stack.
                            if ((op1 * 256 + op2) % bytes_per_const) > 0:
                                bytes_per_const = ((op1 * 256 + op2) % bytes_per_const)
                            constant_value = constants[(op1 * 256 + op2) / bytes_per_const]
                            if constant_value in SPECIAL_CONSTANTS:
                                constant_value = SPECIAL_CONSTANTS[constant_value]
                            push('%s'%(constant_value))

                        elif opcode == 0x85:
                            # Push a symbol with a name from namelist[XX]. Note that the name will be stored as "name", not "#name". 
                            push('%s'%(name_list[(op1 * 256 + op2)]))

                        elif opcode == 0x89:
                            # Push the value of a global variable with a name from namelist[XX].  
                            push('%s'%(name_list[(op1 * 256 + op2)]))

                        elif opcode == 0x8F:
                            # Pop one value and use it to set the global variable with name from namelist[XX].    
                            write_code(file, "\n")
                            write_code(file, spacing)
                            write_code(file, 'put %s into %s'%(pop_s(), name_list[(op1 * 256 + op2)]))

                        elif opcode == 0x90:
                            # Pop one value and use it to set a property.
                            write_code(file, "\n")
                            write_code(file, spacing)
                            write_code(file, 'put %s into %s'%(pop_s(), name_list[(op1 * 256 + op2)]))

                        elif opcode == 0x93:
                            # Unconditional jump: Advance by ((XX * 0x100) + YY) bytes, relative to the first byte of this instruction.
                            flush_stack(file, spacing)
                            if WRITE_JUMPS:
                                write_code(file, "\n")
                                write_code(file, spacing)
                                write_code(file, '-- goto label%04x;'%(idxc - 3 + (op1 * 256 + op2)))
                            if label_types[idxc - 3 + (op1 * 256 + op2)] == 'end repeat':
                                write_code(file, '\n')
                                write_code(file, spacing)
                                write_code(file, 'exit repeat')
                                if label_types[idxc] == 'else':
                                    label_indexes.remove(idxc)
                                    label_types[idxc] = 'end if'


                        elif opcode == 0x95:
                            # Conditional jump: Pop a value, and if it is logically FALSE, advance by ((XX * 0x100) + YY) bytes, relative to the first byte of this instruction.
                            if WRITE_JUMPS:
                                write_code(file, "\n")
                                write_code(file, spacing)
                                write_code(file, '-- if (!pop()) goto label%04x;'%(idxc - 3 + (op1 * 256 + op2)))
                            write_code(file, "\n")
                            write_code(file, spacing)
                            erpos = idxc - 3 + (op1 * 256 + op2)
                            if (erpos in label_types) and (label_types[erpos] == 'end repeat'):
                                write_code(file, 'if not %s then exit repeat'%(pop_s()))
                                label_indexes.remove(erpos)
                            else:
                                write_code(file, 'if %s then'%(pop_s()))
                                spacing = spacing + '    '

                        elif opcode == 0x96:
                            # Call a function defined in this script with the name at lfnames[XX].
                            params = pop_s()
                            cindex = op1 * 256 + op2
                            if params.startswith('<'):
                                # The function must return something
                                push('%s(%s)'%(lfnames[cindex], params[1:]))
                            else:
                                write_code(file, "\n")
                                write_code(file, spacing)
                                write_code(file, '%s(%s)'%(lfnames[cindex], params))

                        elif opcode == 0x97:
                            # Call the external function with name from namelist[XX].
                            params = pop_s()
                            cindex = op1 * 256 + op2
                            if params.startswith('<'):
                                # The function must return something
                                if name_list[cindex] in NO_PAREN_FUNCTIONS:
                                    push('%s %s'%(name_list[cindex], params[1:]))
                                else:
                                    push('%s(%s)'%(name_list[cindex], params[1:]))
                            else:
                                write_code(file, "\n")
                                write_code(file, spacing)
                                if name_list[cindex] in NO_PAREN_FUNCTIONS:
                                    write_code(file, '%s %s'%(name_list[cindex], params))
                                else:
                                    write_code(file, '%s(%s)'%(name_list[cindex], params))

                        elif opcode == 0x9F:
                            # Push the value of the contextual property with the name at namelist[XX].
                            push('the %s'%(name_list[op1 * 256 + op2]))

                        elif opcode == 0xa0:
                            # Pop one value and use it to set a property.
                            write_code(file, "\n")
                            write_code(file, spacing)
                            write_code(file, 'put %s into %s'%(pop_s(), name_list[(op1 * 256 + op2)]))

                        elif opcode == 0xa1:
                            # Pop one value and use it to set a parameter. 
                            write_code(file, "\n")
                            write_code(file, spacing)
                            pindex = (op1 * 256 + op2)
                            if (pindex % bytes_per_const) > 0:
                                bytes_per_const = (pindex % bytes_per_const)
                            write_code(file, '%s = %s;'%(paramns[int(pindex / bytes_per_const)], pop_s()))

                        elif opcode == 0xa2:
                            # Pop one value and use it to set a local variable.
                            write_code(file, "\n")
                            write_code(file, spacing)
                            if ((op1 * 256 + op2) % bytes_per_const) > 0:
                                bytes_per_const = ((op1 * 256 + op2) % bytes_per_const)
                            write_code(file, '%s = %s;'%(localvs[int((op1 * 256 + op2) / bytes_per_const)], pop_s()))

                        elif opcode == 0xa6:
                            # Pop an empty list and push the value of a read-only property named at namelist[XX]. 
                            pop()
                            push('%s'%(name_list[(op1 * 256 + op2)]))

                        elif opcode == 0xa7:
                            # Call a method of an object with name from namelist[XX].
                            params = pop_s()
                            cindex = op1 * 256 + op2
                            if params.startswith('<'):
                                params = params[1:]
                                obj = params[0:params.index(',')]
                                params = params[params.index(',')+2:]
                                # The function must return something
                                if name_list[cindex] in NO_PAREN_FUNCTIONS:
                                    push('%s.%s %s'%(obj, name_list[cindex], params))
                                else:
                                    push('%s.%s(%s)'%(obj, name_list[cindex], params))
                            else:
                                obj = params[0:params.index(',')]
                                params = params[params.index(',')+2:]
                                write_code(file, "\n")
                                write_code(file, spacing)
                                if name_list[cindex] in NO_PAREN_FUNCTIONS:
                                    write_code(file, '%s.%s %s'%(obj, name_list[cindex], params))
                                else:
                                    write_code(file, '%s.%s(%s)'%(obj, name_list[cindex], params))

                        else:
                            # Unknown operation
                            flush_stack(file, spacing)
                            write_code(file, "\n")
                            write_code(file, spacing)
                            write_code(file, 'unknown_op3(0x%02x, 0x%02x, 0x%02x);'%(opcode, op1, op2))

                    if WRITE_OPCODES:
                        write_code(file, "\n")

                if fname != 'noname':
                    write_code(file, "end %s\n\n"%(fname))

            file.close()
    return file_name

# ====================================================================================================================================
if __name__ == '__main__':
    if len(sys.argv) < 5:
        print("USAGE: lscr2lingo [pc|mac] <work directory> <lscr file name> <lnam file path>")

    else:
        if sys.argv[1] != 'pc' and sys.argv[1] != 'mac':
            logging.error(" First argument must be 'pc' or 'mac'")
            sys.exit(-1)

        if sys.argv[1] == 'pc':
            bit_order_type = 'pc'
            bit_order = "<"

        if not os.path.isdir(sys.argv[2]):
            logging.error(" '%s' is not a directory"%(sys.argv[2]))
            sys.exit(-1)

        if not os.path.isfile(os.path.join(sys.argv[2], sys.argv[3])):
            logging.error(" '%s' is not a file"%(os.path.join(sys.argv[2], sys.argv[3])))
            sys.exit(-1)

        if not sys.argv[3].endswith('.Lscr'):
            logging.error(" '%s' does not end in .Lscr"%(sys.argv[3]))
            sys.exit(-1)

        if not os.path.isfile(sys.argv[4]):
            logging.error(" '%s' is not a file"%(sys.argv[4]))
            sys.exit(-1)

        if not sys.argv[4].endswith('.Lnam'):
            logging.error(" '%s' does not end in .Lnam"%(sys.argv[4]))
            sys.exit(-1)

        # Get cast file data
        name_list = parse_lnam_file(sys.argv[4])
        file_name = lscr2lingo(os.path.join(sys.argv[2], sys.argv[3]), name_list)
        
        # Save include decompiled code into the JSON file
        script = ''
        with open(file_name, mode='rb') as file:
            script = file.read()
        