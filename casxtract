#!/usr/bin/python2

# Author: Abraham Macias Paredes
# E-mail: system252001@yahoo.es
# License: GNU GPL v2 (see LICENSE file for details).

#
# Script to extract Macromedia Director casting files from a "bin" directory
# into a "cas" directory.
# 

import sys
import os
import struct
import re
import logging
import json
import base64
from shutil import copyfile

logging.basicConfig(level=logging.DEBUG)


# Default bit order for MAC
bit_order_type = 'mac'
bit_order = ">"

BINDIR = 'bin'
CASDIR = 'cas'

# -- Casting data types --
# Director 5 types
DIR5_IMAGE_TYPE = 1
DIR5_CLUT_TYPE = 4
DIR5_SND_TYPE = 6
DIR5_LSCR_TYPE = 0xB
DIR5_PUSH_BUTTON_TYPE = 7

# Director 4 types
DIR4_IMAGE_TYPE = 0x1C0000
DIR4_SND_TYPE = 0x010000
DIR4_LSCR_TYPE = 0x00040000


# ====================================================================================================================================
def parse_key_file(key_file):
    key_data = {}

    with open(key_file, mode='rb') as file:
        fdata = file.read()

        indx = 0

        # Unknown header data
        unk = struct.unpack(bit_order+"i", fdata[(indx):(indx+4)])[0]
        indx = indx + 4
        logging.debug("Unknown: %08x"%(unk))

        unk = struct.unpack(bit_order+"i", fdata[(indx):(indx+4)])[0]
        indx = indx + 4
        logging.debug("Unknown: %08x"%(unk))

        unk = struct.unpack(bit_order+"i", fdata[(indx):(indx+4)])[0]
        indx = indx + 4
        logging.debug("Unknown: %08x"%(unk))


        while len(fdata) >= indx + 12:
            nfile = struct.unpack(bit_order+"i", fdata[(indx+0):(indx+4)])[0]
            cas_index = struct.unpack(bit_order+"i", fdata[(indx+4):(indx+8)])[0]

            file_ext = struct.unpack("cccc", fdata[indx+8:indx+12])
            file_ext = ('%c%c%c%c'%(file_ext[0], file_ext[1], file_ext[2], file_ext[3]))
            if sys.argv[1] == 'pc':
                file_ext = file_ext[3] + file_ext[2] + file_ext[1] + file_ext[0]

            indx = indx + 12
            
            cas_index = ('%08x'%cas_index)
            
            if not cas_index in key_data:
                key_data[cas_index] = []
            
            key_data[cas_index].append("%s.%s"%(nfile, file_ext))
            
            key_value = "KEY['%s'] = '%s.%s'"%(cas_index, nfile, file_ext)
            logging.debug(key_value)

    return key_data

# ====================================================================================================================================
def parse_cas_file(cas_file):
    cas_data = []

    with open(cas_file, mode='rb') as file:
        fdata = file.read()

        indx = 0
        i = 0
        while len(fdata) >= indx + 4:
            cas_index = struct.unpack(">i", fdata[(indx):(indx+4)])[0]
            indx = indx + 4
            cas_index = "%08x"%(cas_index)
            cas_data.append(cas_index)
            logging.debug('CAS[%i] = %s'%(i, cas_index))
            i = i + 1
            
    return cas_data

# ====================================================================================================================================
def parse_lctx_file(lctx_file):
    lctx_data = []

    with open(lctx_file, mode='rb') as file:
        fdata = file.read()

        indx = 0
        unk = struct.unpack(">i", fdata[(indx):(indx+4)])[0]
        indx = indx + 4
        logging.debug("Unknown: %08x"%(unk))
        
        unk = struct.unpack(">i", fdata[(indx):(indx+4)])[0]
        indx = indx + 4
        logging.debug("Unknown: %08x"%(unk))
        
        nscripts = struct.unpack(">i", fdata[(indx):(indx+4)])[0]
        indx = indx + 4
        logging.debug("N Scripts: %08x"%(nscripts))
        
        nscripts2 = struct.unpack(">i", fdata[(indx):(indx+4)])[0]
        indx = indx + 4
        logging.debug("N Scripts: %08x"%(nscripts2))
        
        scr_idx = struct.unpack(">h", fdata[(indx):(indx+2)])[0]
        indx = indx + 2
        logging.debug("Scripts Index: %08x"%(scr_idx))
        
        indx = scr_idx
        for i in range(0, nscripts):
            unk = struct.unpack(">i", fdata[(indx):(indx+4)])[0]
            indx = indx + 4
            logging.debug("Unknown: %08x"%(unk))
            
            scrfile = struct.unpack(">i", fdata[(indx):(indx+4)])[0]
            indx = indx + 4
            logging.debug("Script file: %08x"%(scrfile))
            lctx_data.append(scrfile)
            
            unk = struct.unpack(">i", fdata[(indx):(indx+4)])[0]
            indx = indx + 4
            logging.debug("Unknown: %08x"%(unk))
            
            
    return lctx_data

# ====================================================================================================================================
def parse_cast_file(cast_file, kelm, dest_dir, lctx_elements, lnam_file):

    with open(cast_file, mode='rb') as file:
        fdata = file.read()

        castData = {}
        
        idx = 0
        cast_bit_order = '>'
        data_type = struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
        idx += 4
        
        contentSize = struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
        idx += 4
        logging.debug("contentSize = %08x"%(contentSize))

        unknown_01 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
        idx += 4
        logging.debug("unknown_01 = %08x"%(unknown_01))

        # Look for content marker
        contentMarker =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
        idx += 4
        logging.debug("contentMarker? = %08x"%(contentMarker))
        
        while contentMarker != 0x00000014 and (len(fdata) - idx) > 4:
            contentMarker =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
            idx += 4
            logging.debug("contentMarker? = %08x"%(contentMarker))
        
        if contentMarker == 0x00000014:
            # Content found!
            castData['content'] = {}
            castData['content']['basic'] = []
            
            basic_data00 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
            idx += 4
            logging.debug("basic_data00 = %08x"%(basic_data00))

            basic_data01 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
            idx += 4
            logging.debug("basic_data01 = %08x"%(basic_data01))

            basic_data02 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
            idx += 4
            logging.debug("basic_data02 = %08x"%(basic_data02))

            basic_data03 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
            idx += 4
            logging.debug("basic_data03: %d"%(basic_data03))
            
            castData['content']['basic'].append('0x%08x'%(basic_data00))
            castData['content']['basic'].append('0x%08x'%(basic_data01))
            castData['content']['basic'].append('0x%08x'%(basic_data02))
            castData['content']['basic'].append('0x%08x'%(basic_data03))

            nstruct =  struct.unpack(cast_bit_order+"h", fdata[idx:idx+2])[0]
            idx += 2
            logging.debug("number of structures contained = %d"%(nstruct))

            if nstruct > 0:
                castData['content']['extra'] = []
            
                struct_indx = []
                for i in range(0, nstruct+1):
                    stindx =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
                    idx += 4
                    logging.debug("stindx[%d] = %08x"%(i, stindx))
                    struct_indx.append(stindx)

                base_dir = idx
                for i in range(0, nstruct):
                    stlen = struct_indx[i+1] - struct_indx[i]
                    logging.debug("The %d element of the structure is %d bytes long"%(i, stlen))
                    if stlen > 0:
                        stdata = fdata[idx:idx+stlen]
                        idx += stlen
                        
                        encodedBytes = base64.b64encode(stdata)
                        encodedStr = str(encodedBytes)
                        
                        castData['content']['extra'].append(encodedStr)
                    else:
                        castData['content']['extra'].append('')

                # Check if there is a CAST member script
                if len(castData['content']['extra']) > 0 and castData['content']['extra'][0] != '':
                    with open(os.path.join(dest_dir, 'member.lingo'), 'wb') as cfile:
                        cfile.write(base64.b64decode(castData['content']['extra'][0]))

                # Check if there is a CAST member name
                if len(castData['content']['extra']) > 1 and castData['content']['extra'][1] != '':
                    stdata = base64.b64decode(castData['content']['extra'][1])
                    nchars = struct.unpack("B", stdata[0])[0]
                    cast_elm_name = stdata[1:nchars+1]
                    castData['name'] = cast_elm_name
                else:
                    castData['name'] = ''
        
        copyfile(cast_file, os.path.join(dest_dir, os.path.basename(cast_file)))
        logging.debug("%s: data_type = %s"%(cast_file, data_type))
        

        if data_type == DIR5_IMAGE_TYPE or data_type == DIR4_IMAGE_TYPE:
            # Director image type
            logging.info("%s: is a image file"%(cast_file))
            castData['type'] = 'image'
            
            bmp_bpp_val =  struct.unpack(cast_bit_order+"B", fdata[idx])[0]
            idx += 1

            bmp_bpp = 8
            if bmp_bpp_val == 0x80:
                # 8 bit per pixel image
                bmp_bpp = 8
                
            elif bmp_bpp_val == 0x81:
                # 4 bit per pixel image
                bmp_bpp = 4

            elif bmp_bpp_val == 0x82:
                # 8 bit per pixel image
                bmp_bpp = 8

            elif bmp_bpp_val == 0x84:
                # 16 bit per pixel image
                bmp_bpp = 16

            elif bmp_bpp_val == 0x85:
                # 16 bit per pixel image (MAC format)
                bmp_bpp = 16

            elif bmp_bpp_val == 0x8A:
                # 24 bit per pixel image
                bmp_bpp = 24

            else:
                logging.warn("Unknown BPP value: %s"%(bmp_bpp_val))

            logging.debug("bmp_bpp = %s"%(bmp_bpp)) 


            unknown_11 =  struct.unpack(cast_bit_order+"B", fdata[idx])[0]
            idx += 1                
            logging.debug("unknown_11 = %s"%(unknown_11)) 

            h_padding =  struct.unpack(cast_bit_order+"h", fdata[idx:idx+2])[0]
            idx += 2
            logging.debug("h_padding = %s"%(h_padding)) 

            w_padding =  struct.unpack(cast_bit_order+"h", fdata[idx:idx+2])[0]
            idx += 2
            logging.debug("w_padding = %s"%(w_padding)) 

            bmp_height =  struct.unpack(cast_bit_order+"h", fdata[idx:idx+2])[0]
            idx += 2                
            logging.debug("bmp_height = %s"%(bmp_height)) 

            bmp_width =  struct.unpack(cast_bit_order+"h", fdata[idx:idx+2])[0]
            idx += 2                
            logging.debug("bmp_width = %s"%(bmp_width)) 

            unknown_12 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
            idx += 4
            logging.debug("unknown_12 = %s"%(unknown_12)) 

            unknown_13 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
            idx += 4
            logging.debug("unknown_13 = %s"%(unknown_13)) 

            unknown_14 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
            idx += 4
            logging.debug("unknown_14 = %s"%(unknown_14)) 

            unknown_15 =  struct.unpack(cast_bit_order+"h", fdata[idx:idx+2])[0]
            idx += 2
            logging.debug("unknown_15 = %s"%(unknown_15)) 

            unknown_16 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
            idx += 4
            logging.debug("unknown_16 = %s"%(unknown_16))

            castData['content']['bitmap'] = {}
            castData['content']['bitmap']['height'] = bmp_height
            castData['content']['bitmap']['width'] = bmp_width
            castData['content']['bitmap']['h_padding'] = h_padding
            castData['content']['bitmap']['w_padding'] = w_padding
            castData['content']['bitmap']['bpp'] = bmp_bpp
            
            
            
            

            
        elif data_type == DIR5_SND_TYPE or data_type == DIR4_SND_TYPE:
            # Director sound type
            logging.info("%s: is a sound file"%(cast_file))
            castData['type'] = 'sound'


        elif data_type == DIR5_LSCR_TYPE or data_type == DIR4_LSCR_TYPE:
            # Director Lingo Script reference
            logging.info("%s: is a script reference file"%(cast_file))
            castData['type'] = 'script'
            
            scridx = basic_data03
            logging.debug("Script index: %d"%(scridx))
            script_file = "%s.Lscr"%(lctx_elements[scridx - 1])
            logging.debug("Script file: %s"%(script_file))
            
            src = os.path.join(os.path.dirname(cast_file), script_file)
            dst = os.path.join(dest_dir, script_file)
            if os.path.isfile(src):
                copyfile(src, dst)
            else:
                logging.warn("There is no %s file (maybe empty file)"%(src))
            
            os.system('%s/lscr2lingo %s %s %s %s %s'%(
                os.path.dirname(sys.argv[0]), # Scripts path
                sys.argv[1], # pc or mac
                dest_dir, # work directory
                os.path.basename(cast_file), # cast file name
                script_file, # script file name
                lnam_file
            ))
        
        elif data_type == DIR5_PUSH_BUTTON_TYPE:
            logging.info("%s: is a push button"%(cast_file))
            castData['type'] = 'push_button'
            
        else:
            logging.warn("%s: data_type unknown (%s)!"%(cast_file, data_type))
            castData['type'] = 'unknown'
        
        # Write CAST data to JSON file
        with open(os.path.join(dest_dir, 'data.json'), 'wb') as jsfile:
            jsfile.write(json.dumps(castData))
        
        if kelm is None or len(kelm) <= 0:
            logging.info("%s: has no related image data!"%(cast_file))
        else:
            for f in kelm:
                logging.debug("Related file: %s"%(f))
                src = os.path.join(os.path.dirname(cast_file), f)
                dst = os.path.join(dest_dir, f)
                if os.path.isfile(src):
                    copyfile(src, dst)
                else:
                    logging.warn("There is no %s file (maybe empty file)"%(src))

                if f.endswith('.BITD'):
                    os.system('%s/bitd2bmp %s %s %s %s'%(
                        os.path.dirname(sys.argv[0]), # Scripts path
                        sys.argv[1], # pc or mac
                        dest_dir, # work directory
                        os.path.basename(cast_file), # cast file name
                        f # BITD file name
                    ))
                    
                if f.endswith('.snd '):
                    os.system('%s/snd2wav %s %s %s "%s"'%(
                        os.path.dirname(sys.argv[0]), # Scripts path
                        sys.argv[1], # pc or mac
                        dest_dir, # work directory
                        os.path.basename(cast_file), # cast file name
                        f # snd file name
                    ))
                    
                if f.endswith('.STXT'):
                    os.system('%s/stxt2txt %s %s "%s"'%(
                        os.path.dirname(sys.argv[0]), # Scripts path
                        sys.argv[1], # pc or mac
                        dest_dir, # work directory
                        f # stxt file name
                    ))



# ====================================================================================================================================
if __name__ == '__main__':
    if len(sys.argv) < 3:
        print("USAGE: casxtract [pc|mac] <base directory>")

    else:
        if sys.argv[1] != 'pc' and sys.argv[1] != 'mac':
            logging.error(" First argument must be 'pc' or 'mac'")
            sys.exit(-1)

        if sys.argv[1] == 'pc':
            bit_order_type = 'pc'
            bit_order = "<"

        if not os.path.isdir(sys.argv[2]):
            logging.error(" '%s' is not a directory"%(sys.argv[2]))
            sys.exit(-1)

        if not os.path.isdir(os.path.join(sys.argv[2], BINDIR)):
            logging.error(" '%s' is not a directory"%(os.path.join(sys.argv[2], BINDIR)))
            sys.exit(-1)

        if not os.path.isdir(os.path.join(sys.argv[2], CASDIR)):
            os.mkdir(os.path.join(sys.argv[2], CASDIR))
        
        # Look for KEY* and CAS* files (not ext_ ones)
        key_file = None
        cas_file = None
        lctx_file = None
        lnam_file = None
        for f in os.listdir(os.path.join(sys.argv[2], BINDIR)):
            if f.endswith('KEY*') and not f.startswith("ext_"):
                key_file = f
            
            if f.endswith('CAS*') and not f.startswith("ext_"):
                cas_file = f
                
            if (f.endswith('Lctx') or f.endswith('LctX')) and not f.startswith("ext_"):
                lctx_file = f
                
            if f.endswith('Lnam') and not f.startswith("ext_"):
                lnam_file = f
                
        if key_file is None:
            logging.error('Can not find a KEY* file!')
            sys.exit(-1)

        if cas_file is None:
            logging.error('Can not find a CAS* file!')
            sys.exit(-1) 

        if lctx_file is None:
            logging.error('Can not find a Lctx file!')
            sys.exit(-1)

        if lnam_file is None:
            logging.error('Can not find a Lnam file!')
            sys.exit(-1) 
            
        cas_elements = parse_cas_file(os.path.join(sys.argv[2], BINDIR, cas_file))
        key_elements = parse_key_file(os.path.join(sys.argv[2], BINDIR, key_file))
        lctx_elements = parse_lctx_file(os.path.join(sys.argv[2], BINDIR, lctx_file))
        
        logging.info('There is %i elements in the casting!'%(len(cas_elements)))
        
        # Extract casting elements
        for elm in range(0, len(cas_elements)):
            # Create directory
            if not os.path.isdir(os.path.join(sys.argv[2], CASDIR, str(elm))):
                os.mkdir(os.path.join(sys.argv[2], CASDIR, str(elm)))
            
            # Read CASt file
            kelm = []
            cas_index = (cas_elements[elm])
            if cas_index in key_elements:
                kelm = key_elements[cas_index]
            
            fname = '%i.CASt'%(int(cas_elements[elm], 16))
            if os.path.isfile(os.path.join(sys.argv[2], BINDIR, fname)):
                logging.info('Casting element number %i is %s file!'%(elm, fname))
                parse_cast_file(os.path.join(sys.argv[2], BINDIR, fname), kelm,
                                os.path.join(sys.argv[2], CASDIR, str(elm)),
                               lctx_elements, os.path.join(sys.argv[2], BINDIR, lnam_file))
            else:
                logging.warn('File %s for casting element %i does not exists!'%(fname, elm))

