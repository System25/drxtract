#!/usr/bin/python2

# Author: Abraham Macias Paredes
# E-mail: system252001@yahoo.es
# License: GNU GPL v2 (see LICENSE file for details).

#
# Script to extract Macromedia Director casting files from a "bin" directory
# into a "cas" directory.
# 

import sys
import os
import struct
import re
import logging
import json
import base64
from shutil import copyfile

logging.basicConfig(level=logging.DEBUG)


# Default bit order for MAC
bit_order_type = 'mac'
bit_order = ">"

BINDIR = 'bin'
CASDIR = 'cas'

# -- Casting data types --
DIR_IMAGE_TYPE = 1
DIR_TEXT_INPUT_TYPE = 3
DIR_CLUT_TYPE = 4
DIR_SND_TYPE = 6
DIR_PUSH_BUTTON_TYPE = 7
DIR_SHAPE_TYPE = 8
DIR_LSCR_TYPE = 11
DIR_TEXT_TYPE = 12

DEBUG_MAIN_CHANNEL_INFO = False
DEBUG_PALETTE_CHANNEL_INFO = False
DEBUG_SPRITE_INFO = False


# ====================================================================================================================================
def parse_key_file(key_file):
    key_data = {}

    with open(key_file, mode='rb') as file:
        fdata = file.read()

        indx = 0

        # Unknown header data
        unk = struct.unpack(bit_order+"i", fdata[(indx):(indx+4)])[0]
        indx = indx + 4
        logging.debug("Unknown: %08x"%(unk))

        unk = struct.unpack(bit_order+"i", fdata[(indx):(indx+4)])[0]
        indx = indx + 4
        logging.debug("Unknown: %08x"%(unk))

        unk = struct.unpack(bit_order+"i", fdata[(indx):(indx+4)])[0]
        indx = indx + 4
        logging.debug("Unknown: %08x"%(unk))


        while len(fdata) >= indx + 12:
            nfile = struct.unpack(bit_order+"i", fdata[(indx+0):(indx+4)])[0]
            cas_index = struct.unpack(bit_order+"i", fdata[(indx+4):(indx+8)])[0]

            file_ext = struct.unpack("cccc", fdata[indx+8:indx+12])
            file_ext = ('%c%c%c%c'%(file_ext[0], file_ext[1], file_ext[2], file_ext[3]))
            if sys.argv[1] == 'pc':
                file_ext = file_ext[3] + file_ext[2] + file_ext[1] + file_ext[0]

            indx = indx + 12
            
            if ((not ord(file_ext[0]) in range(65, 91)) or
                (not ord(file_ext[1]) in range(65, 91)) or
                (not ord(file_ext[2]) in range(65, 91)) or
                (not ord(file_ext[3]) in range(65, 91))):
                # Not an ASCII char
                continue
            
            if cas_index > 0 and nfile > 0:
                cas_index = ('%08x'%cas_index)

                if not cas_index in key_data:
                    key_data[cas_index] = []

                key_data[cas_index].append("%s.%s"%(nfile, file_ext))

                key_value = "KEY['%s'] = '%s.%s'"%(cas_index, nfile, file_ext)
                logging.debug(key_value)

    return key_data

# ====================================================================================================================================
def parse_cas_file(cas_file):
    cas_data = []

    with open(cas_file, mode='rb') as file:
        fdata = file.read()

        indx = 0
        i = 0
        while len(fdata) >= indx + 4:
            cas_index = struct.unpack(">i", fdata[(indx):(indx+4)])[0]
            indx = indx + 4
            cas_index = "%08x"%(cas_index)
            cas_data.append(cas_index)
            logging.debug('CAS[%i] = %s'%(i, cas_index))
            i = i + 1
            
    return cas_data

# ====================================================================================================================================
# Reads from VWLB file the markers channel of the score and its frame
def parse_vwlb_file(vwlb_file):
    vwlb_data = []
    
    with open(vwlb_file, mode='rb') as file:
        fdata = file.read()

        indx = 0
        nmarkers = struct.unpack(">h", fdata[(indx):(indx+2)])[0]
        indx = indx + 2
        logging.debug("N Markers: %d"%(nmarkers))
        
        mnidx = 2 + 4 * (nmarkers + 1)
        
        for i in range(0, nmarkers):
            marker = {}
            
            frame = struct.unpack(">h", fdata[(indx):(indx+2)])[0]
            indx = indx + 2
            logging.debug("Frame: %d"%(frame))
            marker['frame'] = frame
            
            name_start = mnidx + struct.unpack(">h", fdata[(indx):(indx+2)])[0]
            indx = indx + 2
            logging.debug("name_start: %d"%(name_start))
            
            name_end = mnidx + struct.unpack(">h", fdata[(indx+2):(indx+4)])[0]
            logging.debug("name_end: %d"%(name_end))
            
            name = fdata[name_start:name_end]
            logging.debug("Name: %s"%(name))
            marker['name'] = name
            
            vwlb_data.append(marker)
            
    return vwlb_data

# ====================================================================================================================================
# Main channel info (Director 4) 
def read_main_channel_info_v4(frameData):
    indx = 0
    # Main channel info
    flags = struct.unpack(">h", frameData[(indx):(indx+2)])[0]
    indx = indx + 2
    if DEBUG_MAIN_CHANNEL_INFO:
        logging.debug("flags: %04x"%(flags))

    transition = struct.unpack(">h", frameData[(indx):(indx+2)])[0]
    indx = indx + 2
    if DEBUG_MAIN_CHANNEL_INFO:
        logging.debug("transition: %04x"%(transition))

    fps = ord(frameData[indx])
    indx += 1
    if DEBUG_MAIN_CHANNEL_INFO:
        logging.debug("Frames per second: %d"%(fps))
    
    transition_id = ord(frameData[indx])
    indx += 1
    if DEBUG_MAIN_CHANNEL_INFO:
        logging.debug("transition_id: %d"%(transition_id))

    sound1_cast = struct.unpack(">h", frameData[(indx):(indx+2)])[0]
    indx = indx + 2
    if DEBUG_MAIN_CHANNEL_INFO:
        logging.debug("sound1_cast: %04x"%(sound1_cast))

    sound2_cast = struct.unpack(">h", frameData[(indx):(indx+2)])[0]
    indx = indx + 2
    if DEBUG_MAIN_CHANNEL_INFO:
        logging.debug("sound1_cast: %04x"%(sound2_cast))

    sound_flags = struct.unpack(">h", frameData[(indx):(indx+2)])[0]
    indx = indx + 2
    if DEBUG_MAIN_CHANNEL_INFO:
        logging.debug("sound_flags: %04x"%(sound_flags))
    
    unknown1 = struct.unpack(">h", frameData[(indx):(indx+2)])[0]
    indx = indx + 2
    if DEBUG_MAIN_CHANNEL_INFO:
        logging.debug("unknown1: %04x"%(unknown1))

    unknown2 = struct.unpack(">h", frameData[(indx):(indx+2)])[0]
    indx = indx + 2
    if DEBUG_MAIN_CHANNEL_INFO:
        logging.debug("unknown2: %04x"%(unknown2))

    script = struct.unpack(">h", frameData[(indx):(indx+2)])[0]
    indx = indx + 2
    if DEBUG_MAIN_CHANNEL_INFO:
        logging.debug("script: %04x"%(script))

    unknown3 = struct.unpack(">h", frameData[(indx):(indx+2)])[0]
    indx = indx + 2
    if DEBUG_MAIN_CHANNEL_INFO:
        logging.debug("unknown3: %04x"%(unknown3))


# ====================================================================================================================================
# Palette channel info (Director 4) 
def read_palette_channel_info_v4(frameData):
    indx = 0
    # Palette channel info
    palette_cast = struct.unpack(">h", frameData[(indx):(indx+2)])[0]
    indx = indx + 2
    if DEBUG_PALETTE_CHANNEL_INFO:
        logging.debug("palette_cast: %04x"%(palette_cast))

    unknown2 = struct.unpack(">h", frameData[(indx):(indx+2)])[0]
    indx = indx + 2
    if DEBUG_PALETTE_CHANNEL_INFO:
        logging.debug("unknown2: %04x"%(unknown2))

    transitio_fps = ord(frameData[indx])
    indx += 1
    if DEBUG_PALETTE_CHANNEL_INFO:
        logging.debug("transitio_fps: %d"%(transitio_fps))

    unknown3 = ord(frameData[indx])
    indx += 1
    if DEBUG_PALETTE_CHANNEL_INFO:
        logging.debug("unknown3: %d"%(unknown3))

    unknown4 = struct.unpack(">h", frameData[(indx):(indx+2)])[0]
    indx = indx + 2
    if DEBUG_PALETTE_CHANNEL_INFO:
        logging.debug("unknown4: %04x"%(unknown4))

    palette_id = struct.unpack(">h", frameData[(indx):(indx+2)])[0]
    indx = indx + 2
    if DEBUG_PALETTE_CHANNEL_INFO:
        logging.debug("palette_id: %04x"%(palette_id))

    unknown5 = struct.unpack(">h", frameData[(indx):(indx+2)])[0]
    indx = indx + 2
    if DEBUG_PALETTE_CHANNEL_INFO:
        logging.debug("unknown5: %04x"%(unknown5))

    unknown6 = struct.unpack(">h", frameData[(indx):(indx+2)])[0]
    indx = indx + 2
    if DEBUG_PALETTE_CHANNEL_INFO:
        logging.debug("unknown6: %04x"%(unknown6))

    unknown7 = struct.unpack(">h", frameData[(indx):(indx+2)])[0]
    indx = indx + 2
    if DEBUG_PALETTE_CHANNEL_INFO:
        logging.debug("unknown7: %04x"%(unknown7))

    unknown8 = struct.unpack(">h", frameData[(indx):(indx+2)])[0]
    indx = indx + 2
    if DEBUG_PALETTE_CHANNEL_INFO:
        logging.debug("unknown8: %04x"%(unknown8))

    unknown9 = struct.unpack(">h", frameData[(indx):(indx+2)])[0]
    indx = indx + 2
    if DEBUG_PALETTE_CHANNEL_INFO:
        logging.debug("unknown9: %04x"%(unknown9))
    
# ====================================================================================================================================
# Sprite channel info (Director 4) 
def read_sprite_channel_info_v4(frameData, i):
    indx = 0
    # Sprite info
    if DEBUG_SPRITE_INFO:
        logging.debug("Sprite[%d] ----------------------------"%(i))
    # Read sprite info
    spriteType = struct.unpack(">h", frameData[(indx):(indx+2)])[0]
    indx = indx + 2
    if DEBUG_SPRITE_INFO:
        logging.debug("Sprite[%d] spriteType: %d"%(i, spriteType))

    foregroundColor = ord(frameData[indx])
    indx += 1
    if DEBUG_SPRITE_INFO:
        logging.debug("Sprite[%d] foregroundColor: %d"%(i, foregroundColor))

    backgroundColor = ord(frameData[indx])
    indx += 1
    if DEBUG_SPRITE_INFO:
        logging.debug("Sprite[%d] backgroundColor: %d"%(i, backgroundColor))

    ink_type = struct.unpack(">h", frameData[(indx):(indx+2)])[0]
    indx = indx + 2
    if DEBUG_SPRITE_INFO:
        logging.debug("Sprite[%d] ink_type: %d"%(i, ink_type))

    castId = struct.unpack(">h", frameData[(indx):(indx+2)])[0]
    indx = indx + 2
    if DEBUG_SPRITE_INFO:
        logging.debug("Sprite[%d] castId: %d"%(i, castId))

    y = struct.unpack(">h", frameData[(indx):(indx+2)])[0]
    indx = indx + 2
    if DEBUG_SPRITE_INFO:
        logging.debug("Sprite[%d] y: %d"%(i, y))

    x = struct.unpack(">h", frameData[(indx):(indx+2)])[0]
    indx = indx + 2
    if DEBUG_SPRITE_INFO:
        logging.debug("Sprite[%d] x: %d"%(i, x))

    height = struct.unpack(">h", frameData[(indx):(indx+2)])[0]
    indx = indx + 2
    if DEBUG_SPRITE_INFO:
        logging.debug("Sprite[%d] height: %d"%(i, height))

    width = struct.unpack(">h", frameData[(indx):(indx+2)])[0]
    indx = indx + 2
    if DEBUG_SPRITE_INFO:
        logging.debug("Sprite[%d] width: %d"%(i, width))

    flag1 = struct.unpack(">h", frameData[(indx):(indx+2)])[0]
    indx = indx + 2
    if DEBUG_SPRITE_INFO:
        logging.debug("Sprite[%d] flag1: %04x"%(i, flag1))
    
    flag2 = struct.unpack(">h", frameData[(indx):(indx+2)])[0]
    indx = indx + 2
    if DEBUG_SPRITE_INFO:
        logging.debug("Sprite[%d] flag2: %04x"%(i, flag2))
    
    if castId > 0:
        sprite_data = {}
        sprite_data['spriteType'] = spriteType
        sprite_data['castId'] = castId
        sprite_data['foregroundColor'] = foregroundColor
        sprite_data['backgroundColor'] = backgroundColor
        sprite_data['ink_type'] = ink_type
        sprite_data['y'] = y
        sprite_data['x'] = x
        sprite_data['height'] = height
        sprite_data['width'] = width
        sprite_data['flag1'] = flag1
        sprite_data['flag2'] = flag2
        return sprite_data
    
    else:
        # Empty sprite
        if DEBUG_SPRITE_INFO:
            logging.debug("Empty castId (%d) in Sprite[%d]"%(castId, i))
        
        return {}

    

    
# ====================================================================================================================================
# Reads from VWSC channel data the score elements
def parse_vwsc_channels(channelData, frame_size, column):
    cdata = {}
    
    indx = 0
    
    cdata['main'] = {}
    cdata['score'] = []

    if frame_size == 20:
        # Director 4
        if DEBUG_MAIN_CHANNEL_INFO:
            logging.debug("Director 4?")
            logging.debug("[%d] Main channel info ----------------------------"%(column))
        frameData = channelData[indx:(indx+frame_size)]
        read_main_channel_info_v4(frameData)
        indx += frame_size
        
        if DEBUG_PALETTE_CHANNEL_INFO:
            logging.debug("[%d] Palette channel info ----------------------------"%(column))
        frameData = channelData[indx:(indx+frame_size)]
        read_palette_channel_info_v4(frameData)
        indx += frame_size
        
    else:
        logging.warn("Unknown director frame size: %d"%(frame_size))
        
    i = 1
    SPRITE_DATA_SIZE = 24
    while indx < len(channelData):
        if DEBUG_SPRITE_INFO:
            logging.debug("[%d] Sprite channel info ----------------------------"%(column))
        if frame_size == 20:
            # Director 4
            if DEBUG_SPRITE_INFO:
                logging.debug("Director 4?")
            frameData = channelData[indx:(indx+frame_size)]
            cdata['score'].append(read_sprite_channel_info_v4(frameData, i))
        else:
            logging.warn("Unknown director frame size: %d"%(frame_size))

        indx += frame_size
        
        i += 1
        
    
    return cdata

# ====================================================================================================================================
# Reads from VWSC data the score elements
def parse_vwsc_data(fdata):
    logging.debug("parse_vwsc_data ======================")
    vwsc_data = []
    
    idx = 0
    dataSize = struct.unpack(">i", fdata[(idx):(idx+4)])[0]
    idx = idx + 4
    logging.debug("dataSize = %08x"%(dataSize))

    dataMarker = struct.unpack(">i", fdata[(idx):(idx+4)])[0]
    idx = idx + 4
    logging.debug("dataMarker = %08x"%(dataMarker))

    if dataMarker != 0x14:
        logging.error('Can\'f find data marker in VWSC data!')
        sys.exit(-1)
    
    if len(fdata) != dataSize:
        logging.error('Bad VWSC data size: (%d != %d)'%(len(fdata), dataSize))
        sys.exit(-1)
        
    frame_count =  struct.unpack(">i", fdata[idx:idx+4])[0]
    idx += 4
    logging.debug("frame_count = %08x"%(frame_count))
    
    unknown01 =  struct.unpack(">h", fdata[idx:idx+2])[0]
    idx += 2
    logging.debug("unknown01 = %04x"%(unknown01))
    
    frame_size =  struct.unpack(">h", fdata[idx:idx+2])[0]
    idx += 2
    logging.debug("frame_size = %04x"%(frame_size))
    
    channel_count =  struct.unpack(">h", fdata[idx:idx+2])[0]
    idx += 2
    logging.debug("channel_count = %04x"%(channel_count))
    
    unknown02 =  struct.unpack(">h", fdata[idx:idx+2])[0]
    idx += 2
    logging.debug("unknown02 = %04x"%(unknown02))
    
    channelDataList = ["\0"] * (channel_count * frame_size)
    channelDataStr = "".join(channelDataList)
    
    column = 0
    while idx < dataSize:
        column += 1
        logging.debug("column: %d idx: %08x"%(column, idx))
        channelSize = struct.unpack(">h", fdata[(idx):(idx+2)])[0]
        idx = idx + 2
        logging.debug("channelSize: %d"%(channelSize))
        if channelSize == 2:
            logging.debug('This frame is equals to the previous one!')
            vwsc_data.append(vwsc_data[-1])
            continue
        
        # The offset indicates the position relative to other frames
        channelOffset = struct.unpack(">h", fdata[(idx):(idx+2)])[0]
        logging.debug("channelOffset: %d"%(channelOffset))
        
        idx = idx + channelOffset - 2
        
        # Channel data
        if channelSize > 0:
            channelSize -= channelOffset
            
            # Apply the differences from the previous channel
            while channelSize > 0:
                delta_size = struct.unpack(">h", fdata[(idx):(idx+2)])[0]
                if (delta_size > channelSize) or (delta_size <= 0):
                    logging.warn("Delta size out of limits: %d > %d"%(delta_size, channelSize))
                    break
                idx = idx + 2
                delta_offset = struct.unpack(">h", fdata[(idx):(idx+2)])[0]
                if delta_offset < 0:
                    delta_offset = (delta_offset & 0xFF)
                
                idx = idx + 2
                channelSize -= 4
            
                logging.debug("delta_size: %d"%(delta_size))
                logging.debug("delta_offset: %d"%(delta_offset))

                deltaData = fdata[(idx):(idx+delta_size)]
                idx = idx + delta_size
                channelSize -= delta_size
                
                for i in range(0, delta_size):
                    channelDataList[delta_offset + i] = deltaData[i]
            
            channelDataStr = "".join(channelDataList)
            vwsc_data.append(parse_vwsc_channels(channelDataStr, frame_size, column))
            
        else:
            logging.debug('Empty channel!')
            vwsc_data.append([])
        
        idx += channelSize
        
    
    return vwsc_data

# ====================================================================================================================================
# Reads from VWSC file the score elements
def parse_vwsc_file(vwsc_file):
    vwsc_data = []
    
    with open(vwsc_file, mode='rb') as file:
        fdata = file.read()

        # Check if the real VWSC data is wrapped into other data
        indx = 0
        dataSize = struct.unpack(">i", fdata[(indx):(indx+4)])[0]
        indx = indx + 4
        
        dataMarker = struct.unpack(">i", fdata[(indx):(indx+4)])[0]
        indx = indx + 4
        
        logging.debug("parse_vwsc_file ============================================")
        logging.debug("dataSize: %d"%(dataSize))
        logging.debug("dataMarker: %d"%(dataMarker))
        
        markersidx = 0
        if dataMarker != 0x14:
            # VWSC data is wrapped into other data (DIR file and not DRX file)
            if len(fdata) != dataSize:
                logging.error('Bad VWSC file size: (%d != %d)'%(len(fdata), dataSize))
                sys.exit(-1)
            
            unknown_01 =  struct.unpack(">i", fdata[indx:indx+4])[0]
            indx += 4
            logging.debug("unknown_01 = %08x"%(unknown_01))
            
            nmarkers =  struct.unpack(">i", fdata[indx:indx+4])[0]
            indx += 4
            logging.debug("nmarkers = %08x"%(nmarkers))
            
            nmarkers1 =  struct.unpack(">i", fdata[indx:indx+4])[0]
            indx += 4
            logging.debug("nmarkers1 = %08x"%(nmarkers1))
            
            lastMarker =  struct.unpack(">i", fdata[indx:indx+4])[0]
            indx += 4
            logging.debug("lastMarker = %08x"%(lastMarker))
            
            
            markersidx = indx
            
            # Skip the markers because at this moment I don't know what are they
            # useful for
            indx += nmarkers1 * 4
            
            dataSize = struct.unpack(">i", fdata[(indx):(indx+4)])[0]
            indx = indx + 4

            dataMarker = struct.unpack(">i", fdata[(indx):(indx+4)])[0]
            indx = indx + 4
        
        if dataMarker != 0x14:
            logging.error('Can\'f find data marker in VWSC file!')
            sys.exit(-1)
        
        indx -= 8
        data = fdata[indx:(indx+dataSize)]
        indx += dataSize
        
        # VWSC data structure depends on Director version
        vwsc_data = parse_vwsc_data(data)
        
        # Check of many data is left
        logging.debug('Data left: %d'%(len(fdata)-indx))
        
        
    return vwsc_data


# ====================================================================================================================================
def parse_vwcf_file(vwcf_file):
    config = {}
    with open(vwcf_file, mode='rb') as file:
        fdata = file.read()

        indx = 0
        dataSize = struct.unpack(">h", fdata[(indx):(indx+2)])[0]
        indx = indx + 2
        logging.debug("Data size: %d"%(dataSize))
        
        if (len(fdata) != dataSize):
            logging.error("Bad data size!")
            sys.exit(-1)
            
        version = struct.unpack(">h", fdata[(indx):(indx+2)])[0]
        indx = indx + 2
        logging.debug("Director version: 0x%04x"%(version))
        
        stageTop = struct.unpack(">h", fdata[(indx):(indx+2)])[0]
        indx = indx + 2
        logging.debug("Stage top: %d"%(stageTop))
        
        stageLeft = struct.unpack(">h", fdata[(indx):(indx+2)])[0]
        indx = indx + 2
        logging.debug("Stage left: %d"%(stageLeft))
        
        
        stageBottom = struct.unpack(">h", fdata[(indx):(indx+2)])[0]
        indx = indx + 2
        logging.debug("Stage bottom: %d"%(stageBottom))
        
        
        stageRight = struct.unpack(">h", fdata[(indx):(indx+2)])[0]
        indx = indx + 2
        logging.debug("Stage right: %d"%(stageRight))
        
        castArrayStart = struct.unpack(">h", fdata[(indx):(indx+2)])[0]
        indx = indx + 2
        logging.debug("Cast array start: %d"%(castArrayStart))
        
        castArrayEnd = struct.unpack(">h", fdata[(indx):(indx+2)])[0]
        indx = indx + 2
        logging.debug("Cast array end: %d"%(castArrayEnd))
        
        currentFrameRate = struct.unpack(">h", fdata[(indx):(indx+2)])[0]
        indx = indx + 2
        logging.debug("Current frame rate?: %d"%(currentFrameRate))
        
        indx += 9
        stageColor = ord(fdata[indx])
        indx += 1
        
        logging.debug("Stage color: %d"%(stageColor))

        indx += 34
        palette = struct.unpack(">h", fdata[(indx):(indx+2)])[0]
        indx = indx + 2
        logging.debug("palette?: %d"%(palette))
        
        version_major = ((version >> 8) & 0xFF)
        version_minor = ( version       & 0xFF)
        
        if version_major == 4:
            # Director 6 or lower version
            if version_minor < 0xC0:
                version = 'dir4'
                
            elif version_minor < 0xC6:
                version = 'dir5'
            
            else:
                version = 'dir6'
            
        elif version_major == 5:
            # Director 7
            version = 'dir7'
            
        elif version_major == 7:
            # Director 8 or MX
            if version_minor <= 0x3A:
                version = 'dir8'
                
            elif version_minor <= 0x42:
                version = 'dirMX'
            
            else:
                version = 'unknown'
        
        elif version_major == 0x16 and version_minor == 0x3C:
            # When the Director file is published the version
            # is always 0x163C
            version = 'published'
            
        else:
            version = 'unknown'
            
        logging.info("Director version: %s"%(version))
        
        config['version'] = version
        config['stageTop'] = stageTop
        config['stageLeft'] = stageLeft
        config['stageBottom'] = stageBottom
        config['stageRight'] = stageRight
        config['castArrayStart'] = castArrayStart
        config['castArrayEnd'] = castArrayEnd
        config['currentFrameRate'] = currentFrameRate
        config['stageColor'] = stageColor
        config['palette'] = palette
        
    
    
    return config

# ====================================================================================================================================
def parse_lctx_file(lctx_file):
    lctx_data = []

    with open(lctx_file, mode='rb') as file:
        fdata = file.read()

        indx = 0
        unk = struct.unpack(">i", fdata[(indx):(indx+4)])[0]
        indx = indx + 4
        logging.debug("Unknown: %08x"%(unk))
        
        unk = struct.unpack(">i", fdata[(indx):(indx+4)])[0]
        indx = indx + 4
        logging.debug("Unknown: %08x"%(unk))
        
        nscripts = struct.unpack(">i", fdata[(indx):(indx+4)])[0]
        indx = indx + 4
        logging.debug("N Scripts: %08x"%(nscripts))
        
        nscripts2 = struct.unpack(">i", fdata[(indx):(indx+4)])[0]
        indx = indx + 4
        logging.debug("N Scripts: %08x"%(nscripts2))
        
        scr_idx = struct.unpack(">h", fdata[(indx):(indx+2)])[0]
        indx = indx + 2
        logging.debug("Scripts Index: %08x"%(scr_idx))
        
        indx = scr_idx
        for i in range(0, nscripts):
            unk = struct.unpack(">i", fdata[(indx):(indx+4)])[0]
            indx = indx + 4
            logging.debug("Unknown: %08x"%(unk))
            
            scrfile = struct.unpack(">i", fdata[(indx):(indx+4)])[0]
            indx = indx + 4
            logging.debug("Script file: %08x"%(scrfile))
            lctx_data.append(scrfile)
            
            unk = struct.unpack(">i", fdata[(indx):(indx+4)])[0]
            indx = indx + 4
            logging.debug("Unknown: %08x"%(unk))
            
            
    return lctx_data

# ====================================================================================================================================
def parse_cast_file(cast_file, kelm, dest_dir, lctx_elements, lnam_file):

    with open(cast_file, mode='rb') as file:
        fdata = file.read()

        castData = {}
        
        idx = 0
        cast_bit_order = '>'
        data_type = struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
        idx += 4
        
        header_size = 0
        additional_size = 0
        
        if (data_type & 0xFFFFFF00) != 0:
            # Director 4 structure
            logging.debug("Director 4 CASt file!")
            idx -= 4
            
            header_size = struct.unpack(cast_bit_order+"h", fdata[idx:idx+2])[0]
            idx += 2
            logging.debug("header_size = %04x"%(header_size))
            
            additional_size = struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
            idx += 4
            logging.debug("additional_size = %08x"%(additional_size))
            
            if 6 + header_size + additional_size != len(fdata):
                logging.error("Bad data size! (%d != %d)"%(6 + header_size + additional_size, len(fdata)))
                sys.exit(-1)
                
            data_type = ord(fdata[idx])
            idx += 1
            logging.debug("data_type = %02x"%(data_type))
            
            header_data = fdata[idx:idx + header_size]
            idx += header_size
            
            basic_data = fdata[idx:idx + additional_size]
            idx += additional_size
            
        else:
            # Director 5 structure
            logging.debug("data_type = %08x"%(data_type))
        
            additional_size = struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
            idx += 4
            logging.debug("additional_size = %08x"%(additional_size))

            header_size =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
            idx += 4
            logging.debug("header_size = %08x"%(header_size))
            
            if 12 + header_size + additional_size != len(fdata):
                logging.error("Bad data size! (%d != %d)"%(12 + header_size + additional_size, len(fdata)))
                sys.exit(-1)
            
            basic_data = fdata[idx:idx + additional_size]
            idx += additional_size
            
            header_data = fdata[idx:idx + header_size]
            idx += header_size

        castData['content'] = {}
        if additional_size > 0:
            # Parse main data
            idx = 0
            contentMarker =  struct.unpack(cast_bit_order+"i", basic_data[idx:idx+4])[0]
            idx += 4
            logging.debug("contentMarker? = %08x"%(contentMarker))
            
            if contentMarker != 0x00000014:
                logging.error("Bad content marker %08x"%(contentMarker))
                sys.exit(-1)
            
            # Content found!
            castData['content']['basic'] = []
            
            basic_data00 =  struct.unpack(cast_bit_order+"i", basic_data[idx:idx+4])[0]
            idx += 4
            logging.debug("basic_data00 = %08x"%(basic_data00))

            basic_data01 =  struct.unpack(cast_bit_order+"i", basic_data[idx:idx+4])[0]
            idx += 4
            logging.debug("basic_data01 = %08x"%(basic_data01))

            basic_data02 =  struct.unpack(cast_bit_order+"i", basic_data[idx:idx+4])[0]
            idx += 4
            logging.debug("basic_data02 = %08x"%(basic_data02))

            basic_data03 =  struct.unpack(cast_bit_order+"i", basic_data[idx:idx+4])[0]
            idx += 4
            logging.debug("basic_data03: %d"%(basic_data03))
            
            castData['content']['basic'].append('0x%08x'%(basic_data00))
            castData['content']['basic'].append('0x%08x'%(basic_data01))
            castData['content']['basic'].append('0x%08x'%(basic_data02))
            castData['content']['basic'].append('0x%08x'%(basic_data03))

            nstruct =  struct.unpack(cast_bit_order+"h", basic_data[idx:idx+2])[0]
            idx += 2
            logging.debug("number of structures contained = %d"%(nstruct))

            if nstruct > 0:
                castData['content']['extra'] = []
            
                struct_indx = []
                for i in range(0, nstruct+1):
                    stindx =  struct.unpack(cast_bit_order+"i", basic_data[idx:idx+4])[0]
                    idx += 4
                    logging.debug("stindx[%d] = %08x"%(i, stindx))
                    struct_indx.append(stindx)

                base_dir = idx
                for i in range(0, nstruct):
                    stlen = struct_indx[i+1] - struct_indx[i]
                    logging.debug("The %d element of the structure is %d bytes long"%(i, stlen))
                    if stlen > 0:
                        stdata = basic_data[idx:idx+stlen]
                        idx += stlen
                        
                        encodedBytes = base64.b64encode(stdata)
                        encodedStr = str(encodedBytes)
                        
                        castData['content']['extra'].append(encodedStr)
                    else:
                        castData['content']['extra'].append('')

                # Check if there is a CAST member script
                if len(castData['content']['extra']) > 0 and castData['content']['extra'][0] != '':
                    with open(os.path.join(dest_dir, 'member.lingo'), 'wb') as cfile:
                        cfile.write(base64.b64decode(castData['content']['extra'][0]))

                # Check if there is a CAST member name
                if len(castData['content']['extra']) > 1 and castData['content']['extra'][1] != '':
                    stdata = base64.b64decode(castData['content']['extra'][1])
                    nchars = struct.unpack("B", stdata[0])[0]
                    cast_elm_name = stdata[1:nchars+1]
                    castData['name'] = cast_elm_name
                else:
                    castData['name'] = ''
        
        copyfile(cast_file, os.path.join(dest_dir, os.path.basename(cast_file)))
        logging.debug("%s: data_type = %s"%(cast_file, data_type))
        
        # Parse header data
        idx = 0
        if data_type == DIR_IMAGE_TYPE:
            # Director image type
            logging.info("%s: is a image file"%(cast_file))
            castData['type'] = 'image'
            
            bmp_bpp_val =  struct.unpack(cast_bit_order+"B", header_data[idx])[0]
            idx += 1

            bmp_bpp = 8
            if bmp_bpp_val == 0x80:
                # 8 bit per pixel image
                bmp_bpp = 8
                
            elif bmp_bpp_val == 0x81:
                # 4 bit per pixel image
                bmp_bpp = 4

            elif bmp_bpp_val == 0x82:
                # 8 bit per pixel image
                bmp_bpp = 8

            elif bmp_bpp_val == 0x84:
                # 16 bit per pixel image
                bmp_bpp = 16

            elif bmp_bpp_val == 0x85:
                # 16 bit per pixel image (MAC format)
                bmp_bpp = 16

            elif bmp_bpp_val == 0x8A:
                # 24 bit per pixel image
                bmp_bpp = 24

            else:
                logging.warn("Unknown BPP value: %s"%(bmp_bpp_val))

            logging.debug("bmp_bpp = %s"%(bmp_bpp)) 


            unknown_11 =  struct.unpack(cast_bit_order+"B", header_data[idx])[0]
            idx += 1                
            logging.debug("unknown_11 = %s"%(unknown_11)) 

            h_padding =  struct.unpack(cast_bit_order+"h", header_data[idx:idx+2])[0]
            idx += 2
            logging.debug("h_padding = %s"%(h_padding)) 

            w_padding =  struct.unpack(cast_bit_order+"h", header_data[idx:idx+2])[0]
            idx += 2
            logging.debug("w_padding = %s"%(w_padding)) 

            bmp_height =  struct.unpack(cast_bit_order+"h", header_data[idx:idx+2])[0]
            idx += 2                
            logging.debug("bmp_height = %s"%(bmp_height)) 

            bmp_width =  struct.unpack(cast_bit_order+"h", header_data[idx:idx+2])[0]
            idx += 2                
            logging.debug("bmp_width = %s"%(bmp_width)) 

            unknown_12 =  struct.unpack(cast_bit_order+"i", header_data[idx:idx+4])[0]
            idx += 4
            logging.debug("unknown_12 = %s"%(unknown_12)) 

            unknown_13 =  struct.unpack(cast_bit_order+"i", header_data[idx:idx+4])[0]
            idx += 4
            logging.debug("unknown_13 = %s"%(unknown_13)) 

            unknown_14 =  struct.unpack(cast_bit_order+"i", header_data[idx:idx+4])[0]
            idx += 4
            logging.debug("unknown_14 = %s"%(unknown_14)) 

            unknown_15 =  struct.unpack(cast_bit_order+"h", header_data[idx:idx+2])[0]
            idx += 2
            logging.debug("unknown_15 = %s"%(unknown_15)) 

            unknown_16 =  struct.unpack(cast_bit_order+"i", header_data[idx:idx+4])[0]
            idx += 4
            logging.debug("unknown_16 = %s"%(unknown_16))

            castData['content']['bitmap'] = {}
            castData['content']['bitmap']['height'] = bmp_height
            castData['content']['bitmap']['width'] = bmp_width
            castData['content']['bitmap']['h_padding'] = h_padding
            castData['content']['bitmap']['w_padding'] = w_padding
            castData['content']['bitmap']['bpp'] = bmp_bpp
            
            
            
            

            
        elif data_type == DIR_SND_TYPE:
            # Director sound type
            logging.info("%s: is a sound file"%(cast_file))
            castData['type'] = 'sound'


        elif data_type == DIR_LSCR_TYPE:
            # Director Lingo Script reference
            logging.info("%s: is a script reference file"%(cast_file))
            castData['type'] = 'script'
            
            scridx = basic_data03
            logging.debug("Script index: %d"%(scridx))
            script_file = "%s.Lscr"%(lctx_elements[scridx - 1])
            logging.debug("Script file: %s"%(script_file))
            
            src = os.path.join(os.path.dirname(cast_file), script_file)
            dst = os.path.join(dest_dir, script_file)
            if os.path.isfile(src):
                copyfile(src, dst)
            else:
                logging.warn("There is no %s file (maybe empty file)"%(src))
            
            os.system('%s/lscr2lingo %s %s %s %s %s'%(
                os.path.dirname(sys.argv[0]), # Scripts path
                sys.argv[1], # pc or mac
                dest_dir, # work directory
                os.path.basename(cast_file), # cast file name
                script_file, # script file name
                lnam_file
            ))
        
        elif data_type == DIR_PUSH_BUTTON_TYPE:
            logging.info("%s: is a push button"%(cast_file))
            castData['type'] = 'push_button'
            
        elif data_type == DIR_TEXT_INPUT_TYPE:
            logging.info("%s: is a text input field"%(cast_file))
            castData['type'] = 'text_input'
            
        elif data_type == DIR_TEXT_TYPE:
            logging.info("%s: is a text field"%(cast_file))
            castData['type'] = 'text'
            
        elif data_type == DIR_SHAPE_TYPE:
            logging.info("%s: is a shape"%(cast_file))
            castData['type'] = 'shape'
            
        else:
            logging.warn("%s: data_type unknown (%s)!"%(cast_file, data_type))
            castData['type'] = 'unknown'
        
        # Write CAST data to JSON file
        with open(os.path.join(dest_dir, 'data.json'), 'wb') as jsfile:
            jsfile.write(json.dumps(castData, indent=4, sort_keys=True))
        
        if kelm is None or len(kelm) <= 0:
            logging.info("%s: has no related data!"%(cast_file))
        else:
            for f in kelm:
                logging.debug("Related file: %s"%(f))
                src = os.path.join(os.path.dirname(cast_file), f)
                dst = os.path.join(dest_dir, f)
                if os.path.isfile(src):
                    copyfile(src, dst)
                else:
                    logging.warn("There is no %s file (maybe empty file)"%(src))

                if f.endswith('.BITD'):
                    os.system('%s/bitd2bmp %s %s %s %s'%(
                        os.path.dirname(sys.argv[0]), # Scripts path
                        sys.argv[1], # pc or mac
                        dest_dir, # work directory
                        os.path.basename(cast_file), # cast file name
                        f # BITD file name
                    ))
                    
                if f.endswith('.snd '):
                    os.system('%s/snd2wav %s %s %s "%s"'%(
                        os.path.dirname(sys.argv[0]), # Scripts path
                        sys.argv[1], # pc or mac
                        dest_dir, # work directory
                        os.path.basename(cast_file), # cast file name
                        f # snd file name
                    ))
                    
                if f.endswith('.STXT'):
                    os.system('%s/stxt2txt %s %s "%s"'%(
                        os.path.dirname(sys.argv[0]), # Scripts path
                        sys.argv[1], # pc or mac
                        dest_dir, # work directory
                        f # stxt file name
                    ))
                    
                if f.endswith('.RTE1'):
                    # RTE1 files are just plain text files
                    src = os.path.join(os.path.dirname(cast_file), f)
                    txt_file = "content.txt"
                    dst = os.path.join(dest_dir, txt_file)
                    if os.path.isfile(src):
                        copyfile(src, dst)




# ====================================================================================================================================
if __name__ == '__main__':
    if len(sys.argv) < 3:
        print("USAGE: casxtract [pc|mac] <base directory>")

    else:
        if sys.argv[1] != 'pc' and sys.argv[1] != 'mac':
            logging.error(" First argument must be 'pc' or 'mac'")
            sys.exit(-1)

        if sys.argv[1] == 'pc':
            bit_order_type = 'pc'
            bit_order = "<"

        if not os.path.isdir(sys.argv[2]):
            logging.error(" '%s' is not a directory"%(sys.argv[2]))
            sys.exit(-1)

        if not os.path.isdir(os.path.join(sys.argv[2], BINDIR)):
            logging.error(" '%s' is not a directory"%(os.path.join(sys.argv[2], BINDIR)))
            sys.exit(-1)

        if not os.path.isdir(os.path.join(sys.argv[2], CASDIR)):
            os.mkdir(os.path.join(sys.argv[2], CASDIR))
        
        # Look for KEY* and CAS* files (not ext_ ones)
        key_file = None
        cas_file = None
        lctx_file = None
        lnam_file = None
        
        sord_file = None
        vwlb_file = None
        vwsc_file = None
        vwcf_file = None
        
        for f in os.listdir(os.path.join(sys.argv[2], BINDIR)):
            if f.endswith('KEY*') and not f.startswith("ext_"):
                key_file = f
            
            if f.endswith('CAS*') and not f.startswith("ext_"):
                cas_file = f
                
            if (f.endswith('Lctx') or f.endswith('LctX')) and not f.startswith("ext_"):
                lctx_file = f
                
            if f.endswith('Lnam') and not f.startswith("ext_"):
                lnam_file = f

            if f.endswith('Sord') and not f.startswith("ext_"):
                sord_file = f

            if f.endswith('VWLB') and not f.startswith("ext_"):
                vwlb_file = f
                
            if f.endswith('VWSC') and not f.startswith("ext_"):
                vwsc_file = f
                
            if (f.endswith('VWCF') or f.endswith('DRCF')) and not f.startswith("ext_"):
                vwcf_file = f
                
        if key_file is None:
            logging.error('Can not find a KEY* file!')
            sys.exit(-1)

        if cas_file is None:
            logging.error('Can not find a CAS* file!')
            sys.exit(-1)

        if lctx_file is None:
            logging.error('Can not find a Lctx file!')
            sys.exit(-1)

        if lnam_file is None:
            logging.error('Can not find a Lnam file!')
            sys.exit(-1)
            
        if sord_file is None:
            logging.error('Can not find a Sord file!')
            sys.exit(-1)
            
        if vwcf_file is None:
            logging.error('Can not find a VWCF or DRCF file!')
            sys.exit(-1)
        
        config = parse_vwcf_file(os.path.join(sys.argv[2], BINDIR, vwcf_file))
        # Write config data to JSON file
        with open(os.path.join(sys.argv[2], CASDIR, 'config.json'), 'wb') as jsfile:
            jsfile.write(json.dumps(config, indent=4, sort_keys=True))        
        
        cas_elements = parse_cas_file(os.path.join(sys.argv[2], BINDIR, cas_file))
        key_elements = parse_key_file(os.path.join(sys.argv[2], BINDIR, key_file))
        lctx_elements = parse_lctx_file(os.path.join(sys.argv[2], BINDIR, lctx_file))
        
        if vwlb_file is not None:
            vwlb_elements = parse_vwlb_file(os.path.join(sys.argv[2], BINDIR, vwlb_file))
            # Write markers data to JSON file
            with open(os.path.join(sys.argv[2], CASDIR, 'markers.json'), 'wb') as jsfile:
                jsfile.write(json.dumps(vwlb_elements, indent=4, sort_keys=True))
        
        if vwsc_file is not None:
            vwsc_elements = parse_vwsc_file(os.path.join(sys.argv[2], BINDIR, vwsc_file))
            # Write score data to JSON file
            with open(os.path.join(sys.argv[2], CASDIR, 'score.json'), 'wb') as jsfile:
                jsfile.write(json.dumps(vwsc_elements, indent=4, sort_keys=True))
        
        logging.info('There is %i elements in the casting!'%(len(cas_elements)))
        
        # Extract casting elements
        for elm in range(1, len(cas_elements)+1):
            # Create directory
            if not os.path.isdir(os.path.join(sys.argv[2], CASDIR, str(elm))):
                os.mkdir(os.path.join(sys.argv[2], CASDIR, str(elm)))
            
            # Read CASt file
            kelm = []
            cas_index = (cas_elements[elm - 1])
            if cas_index in key_elements:
                kelm = key_elements[cas_index]
            
            fname = '%i.CASt'%(int(cas_elements[elm - 1], 16))
            if os.path.isfile(os.path.join(sys.argv[2], BINDIR, fname)):
                logging.info('Casting element number %i is %s file!'%(elm, fname))
                parse_cast_file(os.path.join(sys.argv[2], BINDIR, fname), kelm,
                                os.path.join(sys.argv[2], CASDIR, str(elm)),
                               lctx_elements, os.path.join(sys.argv[2], BINDIR, lnam_file))
            else:
                logging.warn('File %s for casting element %i does not exists!'%(fname, elm))

