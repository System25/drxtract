#!/usr/bin/python2

# Author: Abraham Macias Paredes
# E-mail: system252001@yahoo.es
# License: GNU GPL v2 (see LICENSE file for details).

#
# Script to decompile lingo scripts.
# LSCR file format details from: http://fileformats.archiveteam.org/wiki/Lingo_bytecode
# 

import sys
import os
import struct
import re
import logging
from shutil import copyfile

logging.basicConfig(level=logging.DEBUG)


# Default bit order for MAC
bit_order_type = 'mac'
bit_order = ">"

DIR5_LSCR_TYPE = 0xB
DIR4_LSCR_TYPE = 0x00040000

ONE_BYTE_OPCODES = [ 
    0x01, # exit            Leave the current function immediately and return to its caller. Automatically added as the final step of a function.
    0x02, # UNKNOWN
    0x03, # 0 or FALSE      Push zero onto the stack
    0x04, # (a * b)         Pop two values from the stack, multiply them together and push the result.
    0x05, # (a + b)         Pop two values from the stack, add them together and push the result.
    0x06, # (a - b)         Pop two values from the stack, subtract the second from the first and push the result.
    0x07, # (a / b)         Pop two values from the stack, divide the first by the second and push the result.
    0x08, # (a mod b)       Pop two values from the stack, perform a modulo operation and push the result.
    0x09, # (-a)            Pop one value from the stack, negate it and push the result.
    0x0A, # (a & b)         Pop two values from the stack, concatenate them and push the resulting string.
    0x0B, # (a && b)        Pop two values from the stack, concatenate them with one space character added in between, and push the resulting string.
    0x0C, # (a < b)         Pop two values from the stack, push 1 if the first is less than the second and 0 if not.
    0x0D, # (a <= b)        Pop two values from the stack, push 1 if the first is less than or equal to the second and 0 if not.
    0x0E, # (a <> b)        Pop two values from the stack, push 0 if the two values are the same and 1 if they are not.
    0x0F, # (a = b)         Pop two values from the stack, push 1 if the two values are the same and 0 if they are not.
    0x10, # (a > b)         Pop two values from the stack, push 1 if the first is greater than the second and 0 if not.
    0x11, # (a >= b)        Pop two values from the stack, push 1 if the first is greater than or equal to the sceond and 0 if not.
    0x12, # (a and b)       Pop two values from the stack, push 1 if both are logically true and 0 if not.
    0x13, # (a or b)        Pop two values from the stack, push 1 if either are logically true and 0 if not.
    0x14, # (not a)         Pop one value from the stack, push 0 if it is logically true and 1 if not.
    0x15, # (a contains b)  Pop two values from the stack, push 1 if the first is a string that contains the second and 0 if not.
          #                 The text comparison is case-insensitive and ignores diacritic marks.
    0x16, # (a starts b)    Pop two values from the stack, push 1 if the first is a string that begins with second string and 0 if not.
          #                 The text comparison is case-insensitive and ignores diacritic marks.
    0x17, # (split op)      String slice/split operation.
    0x18, # (hilite op)     Highlight (select) some text.
    0x19, # (sprite 1 intersects 2)  Pop two sprite IDs and push 1 if the bounding rectangles of the two sprites touch at all, or 0 if they do not.
    0x1A, # (sprite 1 within 2) Pop two sprite IDs and push 1 if the bounding rectangle of the first is entirely inside the bounding rectangle of the second, or 0 if not.
    0x1B, # (field 1)       Pop a cast ID (name or number), push the value of that cast member's text property.
    0x1C, # tell someObject to go to frame 1   Pop an object from the stack and begin running subsequent bytecodes in the context of that object, until code 1D is encountered.
    0x1D, # tell someObject to go to frame 1   Marker for the end of a sequence of bytecodes started by 1C. Similar to 01 except for nested bytecode chunks instead of the main one.
    0x1E, # UNKNOWN         Some kind of list transformation or check, seen used just before setting the actorList to []. More research is needed to know exactly what is happening there.
    0x1F  # [#key: value]   Pops a list that must be in the form [#symbol1, val1, #symbol2, val2 ...] to transform into [#symbol1: val1, #symbol2: val2 ...]

]

TWO_BYTE_OPCODES = [
    0x41, # push <int>      Push integer of value XX, which must be between 1 and 127, inclusive. To push zero, use 03. To push larger integers, use 81 XX YY.
    0x42, # push <nargs>    Pop the specified number of values off the top of the stack, create an unparenthesized argument list containing them (i.e. for a call statement like myFunction 1, 2, 3), and push that to the stack.
    0x43, # push <list>     op the specified number of values off the top of the stack, create a list for them (which can also be used for a parenthesized call expression like set result = myFunction(1, 2, 3)), 
          #                 and push that to the stack.
    0x44, # push <const>    Push a constant from local constant records onto the stack. These records seem to be six bytes long (regardless of the actual size of the constant value), 
          #                 so pushing the first one is 44 00, the second is 44 06, the third is 44 0C, etc. To push the 65th one and beyond use code 84 YY ZZ
    0x45, # push <sym>      Push a symbol with a name from namelist[XX]. Note that the name will be stored as "name", not "#name".
    0x46, # push <object>   Push a object with a name from namelist[XX]. See also code 86.
    0x47, # UNKNOWN
    0x48, # UNKNOWN
    0x49, # push <global>   Push the value of a global variable with a name from namelist[XX].
    0x4A, # push <prop>     Push the value of a property
    0x4B, # push <param>    Push the value of a function call parameter. The parameter records seem to be 6 bytes long, so the first is pushed with 4B 00, the second with 4B 06, etc.
    0x4C, # push <local>    Push the value of a local variable. The local variable records seem to be 6 bytes long, so the first is pushed with 4C 00, the second with 4C 06, etc.
    0x4D, # UNKNOWN
    0x4E, # UNKNOWN
    0x4F, # set <global>    Pop one value and use it to set the global variable with name from namelist[XX].
    0x50, # set <prop>      Pop one value and use it to set a property.
    0x51, # set <param>     Pop one value and use it to set a parameter.
    0x52, # set <local>     Pop one value and use it to set a local variable. See code 4C 00 for a note about local variable records.
    0x53, # UNKNOWN
    0x54, # end repeat      Unconditional backwards jump by XX bytes, relative to the first byte of this instruction.
    0x55, # UNKNOWN
    0x56, # call <localfn>  Call a function defined in this script with the name at namelist[XX]. 
          #                 The top value on the stack must be an argument list. If the argument list was created with code 43 XX, one return value will be pushed to the stack. 
          #                 If the argument list was created with code 42 XX, no return value will be pushed.
    0x57, # call <globfn>   Call the external function with name from namelist[XX].
    0x58, # call <obj, met> Pop [argument list, call target] to make a method call. If the call target is a literal number, this indicates a local variable is the target. 
          #                 It must be divided by six to get the actual local variable number. The first argument of the argument list will be a symbol with the name of the method. 
          #                 Note: It is still unclear what difference the value of XX makes. It has been seen as 0x01 and 0x05. More research is needed to know more. (Possibly local variables vs. call parameters?)

    0x59, # put value [into/after/before] textVar
    0x5A, # put value (chunkexpression)
    0x5B, # delete something 3 of textVar
    0x5C, # multi operation (depends on the parameters)
    0x5D, # multi operation (depends on the parameters)
    0x5E, # UNKNOWN
    0x5F, # (the someProperty)
    0x60, # set the someProperty to 0
    0x61, # (the someProperty of someVariable)
    0x62, # set the someProperty of someVariable to 1
    0x63, # tell someObject to go to frame 1
    0x64, # UNKNOWN
    0x65, # UNKNOWN
    0x66, # (the pathName)
    0x67  # UNKNOWN

]

# TODO! Fill the comments with explanations of the opcodes

THREE_BYTE_OPCODES = [
    0x81, # UNKNOWN
    0x82, # UNKNOWN
    0x83, # UNKNOWN
    0x84, # UNKNOWN
    0x85, # UNKNOWN
    0x89, # UNKNOWN
    0x8F, # UNKNOWN
    0x90, # UNKNOWN
    0x93, # UNKNOWN
    0x95, # UNKNOWN
    0x96, # UNKNOWN
    0x97, # UNKNOWN
    0x9F, # UNKNOWN
    0xa0, # UNKNOWN
    0xa1, # UNKNOWN
    0xa2, # UNKNOWN
    0xa6, # UNKNOWN
    0xa7  # UNKNOWN
]

NO_PAREN_FUNCTIONS = [
    'put',
    'window',
    'forget',
    'alert'
]

SPECIAL_CONSTANTS = {
    '""': 'empty',
    '"\\r"': 'return',
    '"\\""': 'quote'
}

operations_stack = []


# ====================================================================================================================================
def clear_stack():
    operations_stack = []

# ====================================================================================================================================
def push(value):
    operations_stack.append(value)

def pop():
    if len(operations_stack) <= 0:
        return None

    return operations_stack.pop()


def pop_s():
    val = pop()
    if val is None:
        val = 'ERROR_EMPTY_STACK'
    return val

def flush_stack(f, spacing):
    op = pop()
    while op is not None:
        f.write("\n")
        f.write(spacing)
        f.write("%s"%(op))
        op = pop()

    f.write("\n")

# ====================================================================================================================================
def to_string(strval):
    strval = strval.replace("\\", "\\\\")
    strval = strval.replace("\"", "\\\"")
    strval = strval.replace("\a", "\\a")
    strval = strval.replace("\b", "\\b")
    strval = strval.replace("\f", "\\f")
    strval = strval.replace("\n", "\\n")
    strval = strval.replace("\r", "\\r")
    strval = strval.replace("\t", "\\t")
    strval = strval.replace("\v", "\\v")
    return '"' + strval + '"'


# ====================================================================================================================================
def parse_lnam_file(lnam_file):
    name_list = []

    with open(lnam_file, mode='rb') as file:
        fdata = file.read()

        indx = 0
        lnam_bit_order = '>'


        # Unknown header data
        unk = struct.unpack(lnam_bit_order+"i", fdata[(indx):(indx+4)])[0]
        indx = indx + 4
        logging.debug("Unknown: %08x"%(unk))

        unk = struct.unpack(lnam_bit_order+"i", fdata[(indx):(indx+4)])[0]
        indx = indx + 4
        logging.debug("Unknown: %08x"%(unk))

        filesize = struct.unpack(lnam_bit_order+"i", fdata[(indx):(indx+4)])[0]
        indx = indx + 4
        logging.debug("filesize: %08x"%(filesize))

        filesize_cp = struct.unpack(lnam_bit_order+"i", fdata[(indx):(indx+4)])[0]
        indx = indx + 4
        logging.debug("filesize_cp: %08x"%(filesize_cp))

        unk = struct.unpack(lnam_bit_order+"h", fdata[(indx):(indx+2)])[0]
        indx = indx + 2
        logging.debug("Unknown: %08x"%(unk))

        nnames = struct.unpack(lnam_bit_order+"h", fdata[(indx):(indx+2)])[0]
        indx = indx + 2
        logging.debug("Number of names: %s"%(nnames))


        if filesize_cp != filesize:
            logging.error("Bad file size! (%s != %s)"%(filesize_cp, filesize))
            sys.exit(-1)



        for i in range(0, nnames):
            nbytes = ord(fdata[indx])
            indx = indx + 1

            name = fdata[indx:(indx + nbytes)]
            indx = indx + nbytes

            name_list.append(name)
            logging.debug("name_list[%s] = %s"%(i, name))
                
    return name_list

# ====================================================================================================================================
def parse_cast_file(cast_file):
    castData = None

    with open(cast_file, mode='rb') as file:
        fdata = file.read()

        idx = 0
        cast_bit_order = '>'
        data_type = struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
        idx += 4

        logging.debug("%s: data_type = %s"%(cast_file, data_type))
        

        if data_type == DIR5_LSCR_TYPE:
            # Director 5 script reference
            logging.info("Reading script reference data...")
            
            unknown_00 = struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
            idx += 4
            logging.debug("unknown_00 = %08x"%(unknown_00))
            
            unknown_01 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
            idx += 4
            logging.debug("unknown_01 = %08x"%(unknown_01))
            
            unknown_02 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
            idx += 4
            logging.debug("unknown_02 = %08x"%(unknown_02))
            
            scrsubtype =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
            idx += 4
            if scrsubtype == 0x0400C300:
                logging.debug("scrsubtype = Behavior")
            elif scrsubtype == 0x0E00C300:
                logging.debug("scrsubtype = Movie")
            else:
                logging.debug("scrsubtype = %08x"%(scrsubtype))
            
            unknown_04 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
            idx += 4
            logging.debug("unknown_04 = %08x"%(unknown_04))
            
            unknown_05 =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
            idx += 4
            logging.debug("unknown_05 = %08x"%(unknown_05))
            
            scridx =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
            idx += 4
            logging.debug("Script index: %d"%(scridx))
            
            nstruct =  struct.unpack(cast_bit_order+"h", fdata[idx:idx+2])[0]
            idx += 2
            logging.debug("number of structures contained = %d"%(nstruct))
            
            struct_indx = []
            for i in range(0, nstruct+1):
                stindx =  struct.unpack(cast_bit_order+"i", fdata[idx:idx+4])[0]
                idx += 4
                logging.debug("stindx[%d] = %08x"%(i, stindx))
                struct_indx.append(stindx)
            
            base_dir = idx
            for i in range(0, nstruct):
                stlen = struct_indx[i+1] - struct_indx[i]
                logging.debug("The %d element of the structure is %d bytes long"%(i, stlen))
                if stlen > 0:
                    stdata = fdata[idx:idx+stlen]
                    idx += stlen
                    
                    if i == 0:
                        # The first element is the Script content
                        file_ext = "lingo"
                        nfiles = cast_file[0:cast_file.find('.')]
                        file_name = "%s.%s"%(nfiles, file_ext)
                        
                        logging.debug(u"FILE: Saving script file to: %s"%(file_name))
                        
                        with open(file_name, 'wb') as file:
                            file.write(stdata)
                    elif i == 1:
                        # The second element is the Casting element name
                        nchars = struct.unpack("B", stdata[0])[0]
                        logging.debug("nchars = %s"%(nchars)) 
                        cast_elm_name = stdata[1:nchars+1]
                        logging.debug(u"Casting element name: %s"%(cast_elm_name))
                    else:
                        logging.info("Unknown element")

            

            castData = {}


        elif  data_type == DIR4_LSCR_TYPE: 
            logging.debug("Reading script reference data...")


            castData = {}

            
        else:
            logging.error("%s: data_type unknown (%s)!"%(cast_file, data_type))
            sys.exit(1)
        
    return castData




# ====================================================================================================================================
def lscr2lingo(castData, lscr_file, name_list):
    with open(lscr_file, mode='rb') as file:
        fdata = file.read()
        
        lsrc_bit_order = '>'

        idx = 0
        scr_type = struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
        idx += 4
        unknown_01 =  struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
        idx += 4
        filesize0 =  struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
        idx += 4
        filesize1 =  struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
        idx += 4
        unknown_04 =  struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
        idx += 4
        unknown_05 =  struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
        idx += 4
        unknown_06 =  struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
        idx += 4
        unknown_07 =  struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
        idx += 4
        unknown_08 =  struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
        idx += 4
        unknown_09 =  struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
        idx += 4
        unknown_10 =  struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
        idx += 4
        unknown_11 =  struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
        idx += 4
        unknown_12 =  struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
        idx += 4
        unknown_13 =  struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
        idx += 4
        unknown_14 =  struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
        idx += 4
        unknown_15 =  struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
        idx += 4

        logging.debug("scr_type = %08x"%(scr_type)) 
        logging.debug("unknown_01 = %08x"%(unknown_01)) 
        logging.debug("filesize0 = %s"%(filesize0)) 
        logging.debug("filesize1 = %s"%(filesize1)) 
        logging.debug("unknown_04 = %08x"%(unknown_04)) 
        logging.debug("unknown_05 = %08x"%(unknown_05)) 
        logging.debug("unknown_06 = %08x"%(unknown_06)) 
        logging.debug("unknown_07 = %08x"%(unknown_07)) 
        logging.debug("unknown_08 = %08x"%(unknown_08)) 
        logging.debug("unknown_09 = %08x"%(unknown_09)) 
        logging.debug("unknown_10 = %08x"%(unknown_10)) 
        logging.debug("unknown_11 = %08x"%(unknown_11)) 
        logging.debug("unknown_12 = %08x"%(unknown_12)) 
        logging.debug("unknown_13 = %08x"%(unknown_13)) 
        logging.debug("unknown_14 = %08x"%(unknown_14)) 
        logging.debug("unknown_15 = %08x"%(unknown_15)) 

        if filesize1 != filesize0 or filesize1 != len(fdata):
            logging.error("bad filesize (%s, %s, %s)"%(filesize1, filesize0, len(fdata))) 
            sys.exit(-1)

        # $0040-$0041 	uint16 	Offset to the function records block  
        frb_offset = struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
        idx += 2

        unknown_17 =  struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
        idx += 2
        unknown_18 =  struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
        idx += 2

        # Offset to the function records block repeated
        frb_offset_cp = struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
        idx += 2

        logging.debug("frb_offset = %s"%(frb_offset)) 
        logging.debug("unknown_17 = %s"%(unknown_17)) 
        logging.debug("unknown_18 = %s"%(unknown_18)) 
        logging.debug("frb_offset_cp = %s"%(frb_offset_cp)) 

        if frb_offset != frb_offset_cp:
            logging.error("bad offset to the function records block (%s, %s)"%(frb_offset, frb_offset_cp))
            sys.exit(-1)

        # $0048-$0049 	uint16 	Number of function records 
        frb_nrecords = struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
        idx += 2

        unknown_19 =  struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
        idx += 2

        # Offset to the function records block repeated
        frb_offset_cp = struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
        idx += 2

        logging.debug("frb_nrecords = %s"%(frb_nrecords)) 
        logging.debug("unknown_19 = %s"%(unknown_19)) 
        logging.debug("frb_offset_cp = %s"%(frb_offset_cp)) 

        if frb_offset != frb_offset_cp:
            logging.error("bad offset to the function records block (%s, %s)"%(frb_offset, frb_offset_cp)) 
            sys.exit(-1)

        # $004E-$004F    uint16 	Number of constants 
        con_nconstants = struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
        idx += 2

        unknown_20 =  struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
        idx += 2

        # $0052-$0053 	uint16 	Offset to the constant records block 
        crb_offset = struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
        idx += 2

        unknown_21 =  struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
        idx += 2

        # Size in bytes of the constants area???
        unknown_22 =  struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
        idx += 2

        unknown_23 =  struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
        idx += 2

        # $005A-$005B 	uint16 	Base address for constant data
        con_offset = struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
        idx += 2

        logging.debug("con_nconstants = %s"%(con_nconstants))
        logging.debug("unknown_20 = %s"%(unknown_20))
        logging.debug("crb_offset = %s"%(crb_offset))
        logging.debug("unknown_21 = %s"%(unknown_21))
        logging.debug("unknown_22 = %s"%(unknown_22))
        logging.debug("unknown_23 = %s"%(unknown_23))
        logging.debug("con_offset = %s"%(con_offset))

        # Read the constants record blocks
        constants = []

        bytes_per_const = 6
        idx = crb_offset

        # In some lingo 
        for i in range(0, con_nconstants):
            logging.debug("idx = %s"%(idx))
            if (unknown_22 & 0xF) == 4:
               # I don't really know if this is the reason
               # uint32: Value type ID 
               logging.debug("4 bytes")
               constant_type = struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
               idx += 4
               bytes_per_const = 8
            else:
                # uint16: Value type ID 
               constant_type = struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
               idx += 2

            # uint32: Data address, relative to the base address given in the header 
            constant_offset = struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
            idx += 4

            #logging.debug("constant_type = %s"%(constant_type)) 
            #logging.debug("constant_offset = %s"%(constant_offset))

            if constant_type == 1:
                # Text constant
                idxc = con_offset + constant_offset

                # uint32: String length
                strlength = struct.unpack(lsrc_bit_order+"i", fdata[idxc:idxc+4])[0] - 1
                idxc += 4
                #logging.debug("strlength = %s"%(strlength)) 

                strval = str(fdata[idxc:idxc+strlength])
                constants.append(to_string(strval))


            elif constant_type == 4:
                # 32 bits integer
                logging.error("TODO! integer treatment: %s"%(constant_type)) 
                sys.exit(-1)

            elif constant_type == 9:
                # Floating point 
                logging.error("TODO! floating point treatment: %s"%(constant_type))
                sys.exit(-1)


            else:
                # Unknown
                logging.error("Unknown constant type: %s"%(constant_type))
                sys.exit(-1)

            logging.debug("constants[%s] = %s"%(i, constants[i])) 


        file_ext = "lingo"
        nfiles = lscr_file[0:lscr_file.find('.')]
        file_name = "%s.%s"%(nfiles, file_ext)

        logging.debug(u"FILE: Saving script file to: %s"%(file_name))

        with open(file_name, 'wb') as file:

            # Read the functions record blocks
            idx = frb_offset
            for i in range(0, frb_nrecords):

                logging.debug("Function Record Block: %i (starts in: %x)"%(i, idx)) 
                # $0000-$0001 	uint16 	Namelist index for the function's name, or 0xFFFF if there is no name(?)
                namelist_index = struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
                idx += 2

                # $0002-$0003 	uint16 	Unknown
                unknown_rb0 = struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
                idx += 2

                # $0004-$0007 	uint32 	Length of the function bytecode in bytes
                bc_length = struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
                idx += 4

                # $0008-$000B 	uint32 	Offset to the function bytecode
                bc_off = struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
                idx += 4

                # $000C-$000D 	uint16 	Number of arguments
                bc_narg = struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
                idx += 2

                # $000E-$0011 	uint32 	Offset of arguments name
                argnames_off = struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
                idx += 4

                # $0012-$0013 	uint16 	Number of local variables
                bc_nlocal = struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
                idx += 2

                # $0014-$0017 	uint32 	Local variables offset
                localnames_off = struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
                idx += 4

                # $0018-$0019 	uint16 	Count (C)
                count_c = struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
                idx += 2

                # $001A-$001D 	uint32 	Unknown
                unknown_rb3 = struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
                idx += 4

                # $001E-$0021 	uint32 	Unknown
                unknown_rb4 = struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
                idx += 4

                # $0022-$0023 	uint16 	Unknown
                unknown_rb5 = struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
                idx += 2

                # $0024-$0025 	uint16 	Count (D)
                count_d = struct.unpack(lsrc_bit_order+"h", fdata[idx:idx+2])[0]
                idx += 2

                # $0026-$0029 	uint32 	Unknown
                unknown_rb6 = struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
                idx += 4

                # $0030-$0034 	uint32 	Unknown
                unknown_rb7 = struct.unpack(lsrc_bit_order+"i", fdata[idx:idx+4])[0]
                idx += 4                    

                logging.debug("namelist_index = %x"%(namelist_index)) 
                logging.debug("unknown_rb0 = %x"%(unknown_rb0)) 
                logging.debug("bc_length = %x"%(bc_length)) 
                logging.debug("bc_off = %x"%(bc_off)) 
                logging.debug("bc_narg = %x"%(bc_narg)) 
                logging.debug("argnames_off = %x"%(argnames_off)) 
                logging.debug("bc_nlocal = %x"%(bc_nlocal)) 
                logging.debug("localnames_off = %x"%(localnames_off)) 
                logging.debug("count_c = %x"%(count_c)) 
                logging.debug("unknown_rb3 = %x"%(unknown_rb3)) 
                logging.debug("unknown_rb4 = %x"%(unknown_rb4)) 
                logging.debug("unknown_rb5 = %x"%(unknown_rb5)) 
                logging.debug("count_d = %x"%(count_d)) 
                logging.debug("unknown_rb6 = %x"%(unknown_rb6)) 
                logging.debug("unknown_rb7 = %x"%(unknown_rb7)) 


                logging.debug("Function Record Block: %i (ends in: %x)"%(i, idx)) 

                fname = 'noname'
                if namelist_index >= 0 and namelist_index < len(name_list):
                    fname = name_list[namelist_index]

                # Read the local variable names record block
                localvs = []
                for nl in range(0, bc_nlocal):
                    idxl = 2*nl + localnames_off
                    n = struct.unpack(lsrc_bit_order+"h", fdata[idxl:idxl+2])[0]
                    logging.debug("idxl = %x n=%s"%(idxl, n))
                    logging.debug('localvs[%s] = "%s"'%(nl, name_list[n]))
                    localvs.append(name_list[n])


                args = ''
                for c in range(0, bc_narg):
                     if args == '':
                          args = ('param%s'%(c))
                     else:
                          args = args + ', ' + ('param%s'%(c))

                file.write("on %s %s\n"%(fname, args))

                spacing = '    '

                label_indexes = []
                label_types = {}
                global_vars = []
                # Search for loops and globals
                idxc = bc_off
                while (idxc - bc_off) < bc_length:
                    opcode = ord(fdata[idxc])
                    idxc = idxc + 1

                    if ((opcode not in ONE_BYTE_OPCODES) and
                        (opcode not in TWO_BYTE_OPCODES) and
                        (opcode not in THREE_BYTE_OPCODES)):
                        logging.error("Unknown opcode: %02x"%(opcode))
                        sys.exit(-1)

                    if opcode in ONE_BYTE_OPCODES:
                        pass

                    elif opcode in TWO_BYTE_OPCODES:
                        # Two bytes operation
                        op1 = ord(fdata[idxc])
                        idxc = idxc + 1

                        if opcode == 0x54:
                            # Unconditional backwards jump by XX bytes, relative to the first byte of this instruction. 
                            label_indexes.append(idxc - 2 - op1)
                            label_types[idxc - 2 - op1] = 'repeat while TRUE'
                            label_types[idxc] = 'end repeat'
                        elif opcode == 0x49:
                            # Push the value of a global variable with a name from namelist[XX].  
                            if not name_list[op1] in global_vars:
                                global_vars.append(name_list[op1])
                        elif opcode == 0x4F:
                            # Pop one value and use it to set the global variable with name from namelist[XX].    
                            if not name_list[op1] in global_vars:
                                global_vars.append(name_list[op1])

                    else:
                        # Three bytes operation 
                        op1 = ord(fdata[idxc])
                        idxc = idxc + 1

                        op2 = ord(fdata[idxc])
                        idxc = idxc + 1

                        if opcode == 0x93:
                            # Unconditional jump: Advance by ((XX * 0x100) + YY) bytes, relative to the first byte of this instruction.
                            label_indexes.append(idxc - 3 + (op1 * 256 + op2))
                            label_types[idxc - 3 + (op1 * 256 + op2)] = 'end if'

                            label_indexes.append(idxc)
                            label_types[idxc] = 'else'

                        elif opcode == 0x95:
                            # Conditional jump: Pop a value, and if it is logically FALSE, advance by ((XX * 0x100) + YY) bytes, relative to the first byte of this instruction. 
                            label_indexes.append(idxc - 3 + (op1 * 256 + op2))
                            label_types[idxc - 3 + (op1 * 256 + op2)] = 'end if'

                        elif opcode == 0x89:
                            # Push the value of a global variable with a name from namelist[XX].  
                            if not name_list[op1] in global_vars:
                                global_vars.append(name_list[op1 * 256 + op2])
                        elif opcode == 0x8F:
                            # Pop one value and use it to set the global variable with name from namelist[XX].    
                            if not name_list[op1] in global_vars:
                                global_vars.append(name_list[op1 * 256 + op2])


                # Generate code
                clear_stack()
                window_to_tell = None

                for gv in global_vars:
                    file.write(spacing)
                    file.write("global %s\n"%(gv))

                idxc = bc_off
                while (idxc - bc_off) < bc_length:
                    if idxc in label_indexes:
                        flush_stack(file, spacing)
                        if idxc in label_types:
                            if label_types[idxc].startswith('end') or label_types[idxc] == 'else':
                                spacing = spacing[0:(len(spacing) - 4)]

                            file.write(spacing)
                            file.write("%s\n"%(label_types[idxc]))
                            if not label_types[idxc].startswith('end'):
                                spacing = spacing + '    '

                        else:
                            file.write("label%08x\n"%(idxc))

                    file.write(spacing)

                    opcode = ord(fdata[idxc])
                    idxc = idxc + 1

                    if ((opcode not in ONE_BYTE_OPCODES) and
                        (opcode not in TWO_BYTE_OPCODES) and
                        (opcode not in THREE_BYTE_OPCODES)):
                        logging.error("Unknown opcode: %02x"%(opcode))
                        sys.exit(-1)

                    if opcode in ONE_BYTE_OPCODES:
                        # One byte operation
                        file.write("-- [0x%04x]: 0x%02x"%(idxc - 1, opcode))

                        if opcode == 0x01:
                            flush_stack(file, spacing)
                            file.write('\n')
                            file.write(spacing)
                            file.write('exit')

                        elif opcode == 0x03:
                            push('0')

                        elif opcode == 0x04:
                            op2 = pop_s()
                            op1 = pop_s()
                            push('(' + op1 + ' * ' + op2 + ')')

                        elif opcode == 0x04:
                            op2 = pop_s()
                            op1 = pop_s()
                            push('(' + op1 + ' * ' + op2 + ')')

                        elif opcode == 0x05:
                            op2 = pop_s()
                            op1 = pop_s()
                            push('(' + op1 + ' + ' + op2 + ')')

                        elif opcode == 0x06:
                            op2 = pop_s()
                            op1 = pop_s()
                            push('(' + op1 + ' - ' + op2 + ')')

                        elif opcode == 0x07:
                            op2 = pop_s()
                            op1 = pop_s()
                            push('(' + op1 + ' / ' + op2 + ')')

                        elif opcode == 0x08:
                            op2 = pop_s()
                            op1 = pop_s()
                            push('(' + op1 + ' mod ' + op2 + ')')

                        elif opcode == 0x09:
                            push('-' + pop_s())

                        elif opcode == 0x0A:
                            op2 = pop_s()
                            op1 = pop_s()
                            push('('+ op1 + ' & ' + op2 + ')')

                        elif opcode == 0x0B:
                            op2 = pop_s()
                            op1 = pop_s()
                            push('(' + op1 + ' && ' + op2 + ')')

                        elif opcode == 0x0C:
                            op2 = pop_s()
                            op1 = pop_s()
                            push('(' + op1 + ' < ' + op2 + ')')

                        elif opcode == 0x0D:
                            op2 = pop_s()
                            op1 = pop_s()
                            push('(' + op1 + ' <= ' + op2 + ')')

                        elif opcode == 0x0E:
                            op2 = pop_s()
                            op1 = pop_s()
                            push('(' + op1 + ' <> ' + op2 + ')')

                        elif opcode == 0x0F:
                            op2 = pop_s()
                            op1 = pop_s()
                            push('(' + op1 + ' = ' + op2 + ')')

                        elif opcode == 0x10:
                            op2 = pop_s()
                            op1 = pop_s()
                            push('(' + op1 + ' > ' + op2 + ')')

                        elif opcode == 0x11:
                            op2 = pop_s()
                            op1 = pop_s()
                            push('(' + op1 + ' >= ' + op2 + ')')

                        elif opcode == 0x12:
                            op2 = pop_s()
                            op1 = pop_s()
                            push('(' + op1 + ' and ' + op2 + ')')

                        elif opcode == 0x13:
                            op2 = pop_s()
                            op1 = pop_s()
                            push('(' + op1 + ' or ' + op2 + ')')

                        elif opcode == 0x14:
                            push('(not ' + pop_s() + ')')

                        elif opcode == 0x15:
                            op2 = pop_s()
                            op1 = pop_s()
                            push('(' + op1 + ' contains ' + op2 + ')')

                        elif opcode == 0x16:
                            op2 = pop_s()
                            op1 = pop_s()
                            push('(' + op1 + ' starts ' + op2 + ')')


                        elif opcode == 0x17:
                            op_str = pop_s()       # The string to slice
                            op_ll_pos = pop_s()    # Last line position
                            op_fl_pos = pop_s()    # First line position
                            op_li_pos = pop_s()    # Last item position
                            op_fi_pos = pop_s()    # First item position (items separated by the itemDelimiter, which is a comma by default)
                            op_lw_pos = pop_s()    # Last word position
                            op_fw_pos = pop_s()    # First word position
                            op_lc_pos = pop_s()    # Last char position
                            op_fc_pos = pop_s()    # First char position

                            operation = ''

                            if op_fc_pos != '0':
                                operation = operation + ('char %s '%(op_fc_pos))
                                if op_lc_pos != '0':
                                    operation = operation + ('to %s '%(op_lc_pos))
                                operation = operation + 'of '

                            if op_fw_pos != '0':
                                operation = operation + ('word %s '%(op_fw_pos))
                                if op_lw_pos != '0':
                                    operation = operation + ('to %s '%(op_lw_pos))
                                operation = operation + 'of '

                            if op_fi_pos != '0':
                                operation = operation + ('item %s '%(op_fi_pos))
                                if op_li_pos != '0':
                                    operation = operation + ('to %s '%(op_li_pos))
                                operation = operation + 'of '

                            if op_fl_pos != '0':
                                operation = operation + ('line %s '%(op_fl_pos))
                                if op_ll_pos != '0':
                                    operation = operation + ('to %s '%(op_ll_pos))
                                operation = operation + 'of '

                            operation = operation + op_str

                            push(operation)


                        elif opcode == 0x18:
                            op_cid = pop_s()       # Field number (cast ID
                            op_ll_pos = pop_s()    # Last line position
                            op_fl_pos = pop_s()    # First line position
                            op_li_pos = pop_s()    # Last item position
                            op_fi_pos = pop_s()    # First item position (items separated by the itemDelimiter, which is a comma by default)
                            op_lw_pos = pop_s()    # Last word position
                            op_fw_pos = pop_s()    # First word position
                            op_lc_pos = pop_s()    # Last char position
                            op_fc_pos = pop_s()    # First char position

                            operation = ''

                            if op_fc_pos != '0':
                                operation = operation + ('char %s '%(op_fc_pos))
                                if op_lc_pos != '0':
                                    operation = operation + ('to %s '%(op_lc_pos))
                                operation = operation + 'of '

                            if op_fw_pos != '0':
                                operation = operation + ('word %s '%(op_fw_pos))
                                if op_lw_pos != '0':
                                    operation = operation + ('to %s '%(op_lw_pos))
                                operation = operation + 'of '

                            if op_fi_pos != '0':
                                operation = operation + ('item %s '%(op_fi_pos))
                                if op_li_pos != '0':
                                    operation = operation + ('to %s '%(op_li_pos))
                                operation = operation + 'of '

                            if op_fl_pos != '0':
                                operation = operation + ('line %s '%(op_fl_pos))
                                if op_ll_pos != '0':
                                    operation = operation + ('to %s '%(op_ll_pos))
                                operation = operation + 'of '

                            operation = 'hilite ' + operation + 'field ' + op_cid

                            push(operation)

                        elif opcode == 0x19:
                            op2 = pop_s()
                            op1 = pop_s()

                            push('sprite_intersects(' + op1 + ', ' + op2 + ')')

                        elif opcode == 0x1A:
                            op2 = pop_s()
                            op1 = pop_s()

                            push('sprite_within(' + op1 + ', ' + op2 + ')')

                        elif opcode == 0x1B:
                            pop_s()
                            push('field ' + pop_s())

                        elif opcode == 0x1C:
                            # Start of "tell" operation
                            window_to_tell = pop_s()

                        elif opcode == 0x1D:
                            # End of "tell" operation
                            params = ''
                            p = pop()
                            while p is not None:
                                if params == '':
                                    params = p
                                else:
                                    params = params + ' ' + p
                                p = pop()

                            file.write("\n")
                            file.write(spacing)
                            file.write('tell ' + window_to_tell + ' to ' + params)

                        elif opcode == 0x1F:
                            push('transpose(' + pop_s() + ')')


                    elif opcode in TWO_BYTE_OPCODES:
                        # Two bytes operation
                        op1 = ord(fdata[idxc])
                        idxc = idxc + 1

                        file.write("-- [0x%04x]: 0x%02x 0x%02x"%(idxc - 2, opcode, op1))


                        if opcode == 0x41:
                            # Push integer of value XX, which must be between 1 and 127, inclusive.
                            push('%s'%(op1))

                        elif opcode == 0x42:
                            # Pop the specified number of values off the top of the stack, create an unparenthesized argument list containing them 
                            # (i.e. for a call statement like myFunction 1, 2, 3), and push that to the stack.
                            params = ''
                            for c in range(0, op1):
                                p = pop_s()
                                if params == '':
                                    params = p
                                else:
                                    params = p + ', ' + params

                            push(params)

                        elif opcode == 0x43:
                            # Pop the specified number of values off the top of the stack, create a list for them (which can also be used for a parenthesized call expression like set result = myFunction(1, 2, 3)), 
                            # and push that to the stack.
                            params = ''
                            for c in range(0, op1):
                                p = pop_s()
                                if params == '':
                                    params = p
                                else:
                                    params = p + ', ' + params

                            push('<%s'%(params))

                        elif opcode == 0x44:
                            # Push a constant from local constant records onto the stack. These records seem to be six bytes long (regardless of the actual size of the constant value), 
                            # so pushing the first one is 44 00, the second is 44 06, the third is 44 0C, etc. 
                            if (op1 % bytes_per_const) > 0:
                                bytes_per_const = (op1 % bytes_per_const)

                            constant_value = constants[op1 / bytes_per_const]
                            if constant_value in SPECIAL_CONSTANTS:
                                constant_value = SPECIAL_CONSTANTS[constant_value]
                            push('%s'%(constant_value))

                        elif opcode == 0x45:
                            # Push a symbol with a name from namelist[XX]. Note that the name will be stored as "name", not "#name". 
                            push('%s'%(name_list[op1]))

                        elif opcode == 0x46:
                            # Push a object with a name from namelist[XX]. 
                            push('%s'%(name_list[op1]))

                        elif opcode == 0x49:
                            # Push the value of a global variable with a name from namelist[XX].  
                            push('%s'%(name_list[op1]))

                        elif opcode == 0x4A:
                            # Push the value of a property.  
                            push('the %s'%(name_list[op1]))

                        elif opcode == 0x4B:
                            # Push the value of a function call parameter. The parameter records seem to be 6 bytes long, so the first is pushed with 4B 00, the second with 4B 06, etc.
                            if (op1 % bytes_per_const) > 0:
                                bytes_per_const = (op1 % bytes_per_const)

                            push('param%s'%(op1 / bytes_per_const))

                        elif opcode == 0x4C:
                            # Push the value of a function call parameter. The parameter records seem to be 6 bytes long, so the first is pushed with 4B 00, the second with 4B 06, etc.   
                            if (op1 % bytes_per_const) > 0:
                                bytes_per_const = (op1 % bytes_per_const)

                            push('%s'%(localvs[op1 / bytes_per_const]))

                        elif opcode == 0x4F:
                            # Pop one value and use it to set the global variable with name from namelist[XX].    
                            file.write("\n")
                            file.write(spacing)
                            file.write('put %s into %s'%(pop_s(), name_list[op1]))

                        elif opcode == 0x50:
                            # Pop one value and use it to set a property.
                            file.write("\n")
                            file.write(spacing)
                            file.write('set_property("%s", %s);'%(name_list[op1], pop_s()))

                        elif opcode == 0x51:
                            # Pop one value and use it to set a parameter. 
                            file.write("\n")
                            file.write(spacing)
                            if (op1 % bytes_per_const) > 0:
                                bytes_per_const = (op1 % bytes_per_const)

                            file.write('put %s into param%s'%(pop_s(), op1 / bytes_per_const))

                        elif opcode == 0x52:
                            # Pop one value and use it to set a local variable.
                            file.write("\n")
                            file.write(spacing)
                            if (op1 % bytes_per_const) > 0:
                                bytes_per_const = (op1 % bytes_per_const)

                            file.write('put %s into %s'%(pop_s(), localvs[op1 / bytes_per_const]))

                        elif opcode == 0x54:
                            # Unconditional backwards jump by XX bytes, relative to the first byte of this instruction. 
                            file.write("\n")
                            file.write(spacing)
                            file.write('-- goto label%04x;'%(idxc - 2 - op1))
                            flush_stack(file, spacing)


                        elif opcode == 0x56:
                            # Call a function defined in this script with the name at namelist[XX].
                            params = pop_s()
                            if params.startswith('<'):
                                # The function must return something
                                if name_list[op1] in NO_PAREN_FUNCTIONS:
                                    push('%s %s'%(name_list[op1], params[1:]))
                                else:
                                    push('%s(%s)'%(name_list[op1], params[1:]))
                            else:
                                file.write("\n")
                                file.write(spacing)
                                if name_list[op1] in NO_PAREN_FUNCTIONS:
                                    file.write('%s %s'%(name_list[op1], params))
                                else:
                                    file.write('%s(%s)'%(name_list[op1], params))

                        elif opcode == 0x57:
                            # Call the external function with name from namelist[XX].
                            params = pop_s()
                            if params.startswith('<'):
                                # The function must return something
                                if name_list[op1] in NO_PAREN_FUNCTIONS:
                                    push('%s %s'%(name_list[op1], params[1:]))
                                else:
                                    push('%s(%s)'%(name_list[op1], params[1:]))
                            else:
                                file.write("\n")
                                file.write(spacing)
                                if name_list[op1] in NO_PAREN_FUNCTIONS:
                                    file.write('%s %s'%(name_list[op1], params))
                                else:
                                    file.write('%s(%s)'%(name_list[op1], params))

                        elif opcode == 0x58:
                            # Call an object method
                            obj = pop_s()
                            if obj.isdigit():
                                obj = ('%s'%(localvs[obj]))

                            params = pop_s()
                            if params.startswith('<'):
                                # The function must return something
                                push('%s(%s)'%(obj, params[1:]))
                            else:
                                file.write("\n")
                                file.write(spacing)
                                file.write('%s(%s)'%(obj, params))

                        elif opcode == 0x59:
                            if op1 == 0x16:
                                op_type = int(pop())
                                op_var = pop_s()
                                op_value = pop_s()
                                op_types = ['field']

                                if op_type < len(op_types):
                                    op_type = op_types[op_type]
                                else:
                                    op_type = ' UNKNOWN '

                                file.write("\n")
                                file.write(spacing)
                                file.write('put %s into %s %s'%(op_value, op_type, op_var))

                            elif op1 == 0x25:
                                op_var = int(pop())
                                op_value = pop_s()

                                file.write("\n")
                                file.write(spacing)
                                if (op_var % bytes_per_const) > 0:
                                    bytes_per_const = (op_var % bytes_per_const)

                                file.write('put %s after %s'%(localvs[op_value, op_var / bytes_per_const]))

                            elif op1 == 0x35:
                                op_var = int(pop())
                                op_value = pop_s()

                                file.write("\n")
                                file.write(spacing)
                                if (op_var % bytes_per_const) > 0:
                                    bytes_per_const = (op_var % bytes_per_const)

                                file.write('put %s before %s'%(localvs[op_value, op_var / bytes_per_const]))

                            else:
                                file.write("\n")
                                file.write(spacing)
                                file.write("ERROR: Missing subcommand! (0x%02x) :("%(op1))

                        # TODO! Complete this

                        elif opcode == 0x5B:
                            op_type = 'UNKNOWN'

                            op_vind = pop_s()      # The local variable
                            op_ll_pos = pop_s()    # Last line position
                            op_fl_pos = pop_s()    # First line position
                            op_li_pos = pop_s()    # Last item position
                            op_fi_pos = pop_s()    # First item position (items separated by the itemDelimiter, which is a comma by default)
                            op_lw_pos = pop_s()    # Last word position
                            op_fw_pos = pop_s()    # First word position
                            op_lc_pos = pop_s()    # Last char position
                            op_fc_pos = pop_s()    # First char position

                            if op_fl_pos != '0':
                                op_type = 'line ' + op_fl_pos
                                if op_ll_pos != '0':
                                    op_type = op_type + ' to ' + op_ll_pos

                            if op_fi_pos != '0':
                                op_type = 'item ' + op_fi_pos
                                if op_li_pos != '0':
                                    op_type = op_type + ' to ' + op_li_pos

                            if op_fw_pos != '0':
                                op_type = 'word ' + op_fw_pos
                                if op_lw_pos != '0':
                                    op_type = op_type + ' to ' + op_lw_pos

                            if op_fc_pos != '0':
                                op_type = 'char ' + op_fc_pos
                                if op_lc_pos != '0':
                                    op_type = op_type + ' to ' + op_lc_pos

                            op_vind = int(op_vind)
                            if (op_vind % bytes_per_const) > 0:
                                bytes_per_const = (op_vind % bytes_per_const)

                            op_vname = '%s'%(localvs[op_vind / bytes_per_const])

                            file.write("\n")
                            file.write(spacing)
                            file.write('delete ' + op_type + ' of ' + op_vname)

                        elif opcode == 0x5C:
                            if op1 == 0x01:
                                # the number of chars in someText
                                op_type = int(pop())
                                op_var = pop_s()
                                op_types = ['chars', 'words', 'items', 'lines']
                                push('the number of %s of %s'%(op_types[op_type - 1], op_var))

                            else:
                                file.write("\n")
                                file.write(spacing)
                                file.write("ERROR: Missing subcommand! (0x%02x) :("%(op1))

                        elif opcode == 0x5D:
                            if op1 == 0x07:
                                # set the exitLock to TRUE
                                file.write("\n")
                                file.write(spacing)
                                unkown_v0 = pop_s()
                                if unkown_v0 != '8':
                                    logging.warn("Unknown value: %s"%(unkown_v0))
                                file.write("put %s into the exitLock"%(pop_s()))

                            else:
                                file.write("\n")
                                file.write(spacing)
                                file.write("ERROR: Missing subcommand! (0x%02x) :("%(op1))


                        elif opcode == 0x5F:
                            # Push the value of the contextual property with the name at namelist[XX].
                            push('the %s'%(name_list[op1]))

                        # TODO! Complete this
                        elif opcode == 0x61:
                            # (the someProperty of someVariable)
                            # Pop a property-owning object from the stack, and push the value of this object's property with the name at namelist[XX].  
                            push('the %s.%s '%(pop_s(), name_list[op1]))

                        elif opcode == 0x62:
                            # set the someProperty of someVariable to 1
                            # Pop [property-owning object, new value] from the stack and set the property of the object with the name at namelist[XX].
                            file.write("\n")
                            file.write(spacing)
                            file.write('put %s into %s.%s '%(pop_s(), pop_s(), name_list[op1]))

                        elif opcode == 0x63:
                            # property to tell  
                            push('%s'%(name_list[op1]))

                        elif opcode == 0x64:
                            # Push a copy of a value already on the stack, relative to the top where 00 is the top slot, 01 is one slot beneath the top, etc. 
                            file.write("\n")
                            file.write(spacing)
                            file.write("ERROR: I don't know to implement the copy command! :(")

                        elif opcode == 0x65:
                            # Pop and discard XX values from the top of the stack.
                            file.write("\n")
                            file.write(spacing)
                            file.write("ERROR: I don't know to implement the discard command! :(")

                        elif opcode == 0x66:
                            # Pop an empty list and push the value of a read-only property named at namelist[XX]. 
                            pop()
                            push('the %s'%(name_list[op1]))

                        elif opcode == 0x67:
                            # Call a method of an object with name from namelist[XX].
                            params = pop_s()
                            cindex = op1
                            if params.startswith('<'):
                                # The function must return something
                                params = params[1:]
                                obj = params[0:params.index(',')]
                                params = params[params.index(',')+2:]
                                if name_list[cindex] in NO_PAREN_FUNCTIONS:
                                    push('%s.%s %s'%(obj, name_list[cindex], params))
                                else:
                                    push('%s.%s(%s)'%(obj, name_list[cindex], params))
                            else:
                                obj = params[0:params.index(',')]
                                params = params[params.index(',')+2:]
                                file.write("\n")
                                file.write(spacing)
                                if name_list[cindex] in NO_PAREN_FUNCTIONS:
                                    file.write('%s.%s %s'%(obj, name_list[cindex], params))
                                else:
                                    file.write('%s.%s(%s)'%(obj, name_list[cindex], params))

                        else:
                            # Unknown operation
                            flush_stack(file, spacing)
                            file.write("\n")
                            file.write(spacing)
                            file.write('unknown_op2(0x%02x, 0x%02x);'%(opcode, op1))

                    else:
                        # Three bytes operation 
                        op1 = ord(fdata[idxc])
                        idxc = idxc + 1

                        op2 = ord(fdata[idxc])
                        idxc = idxc + 1

                        file.write("-- [0x%04x]: 0x%02x 0x%02x 0x%02x"%(idxc - 3, opcode, op1, op2))

                        if opcode == 0x81:
                            # Push the integer ((XX * 0x100) + YY).
                            push('%s'%(op1 * 256 + op2))

                        elif opcode == 0x82:
                            # Pop the specified number of values off the top of the stack, create an unparenthesized argument list containing them 
                            # (i.e. for a call statement like myFunction 1, 2, 3), and push that to the stack.
                            push('arglist(%s)'%(op1 * 256 + op2))

                        elif opcode == 0x83:
                            # Pop the specified number of values off the top of the stack, create a list for them (which can also be used for a parenthesized call expression like set result = myFunction(1, 2, 3)), 
                            # and push that to the stack.
                            push('list(%s)'%(op1 * 256 + op2))

                        elif opcode == 0x84:
                            # Push a constant from local constant records onto the stack.
                            if ((op1 * 256 + op2) % bytes_per_const) > 0:
                                bytes_per_const = ((op1 * 256 + op2) % bytes_per_const)
                            constant_value = constants[(op1 * 256 + op2) / bytes_per_const]
                            if constant_value in SPECIAL_CONSTANTS:
                                constant_value = SPECIAL_CONSTANTS[constant_value]
                            push('%s'%(constant_value))

                        elif opcode == 0x85:
                            # Push a symbol with a name from namelist[XX]. Note that the name will be stored as "name", not "#name". 
                            push('%s'%(name_list[(op1 * 256 + op2)]))

                        elif opcode == 0x89:
                            # Push the value of a global variable with a name from namelist[XX].  
                            push('%s'%(name_list[(op1 * 256 + op2)]))

                        elif opcode == 0x8F:
                            # Pop one value and use it to set the global variable with name from namelist[XX].    
                            file.write("\n")
                            file.write(spacing)
                            file.write('put %s into %s'%(pop_s(), name_list[(op1 * 256 + op2)]))

                        elif opcode == 0x90:
                            # Pop one value and use it to set a property.
                            file.write("\n")
                            file.write(spacing)
                            file.write('put %s into %s'%(pop_s(), name_list[(op1 * 256 + op2)]))

                        elif opcode == 0x93:
                            # Unconditional jump: Advance by ((XX * 0x100) + YY) bytes, relative to the first byte of this instruction.
                            flush_stack(file, spacing)
                            file.write("\n")
                            file.write(spacing)
                            file.write('-- goto label%04x;'%(idxc - 3 + (op1 * 256 + op2)))
                            if label_types[idxc - 3 + (op1 * 256 + op2)] == 'end repeat':
                                file.write('\n')
                                file.write(spacing)
                                file.write('exit repeat')
                                if label_types[idxc] == 'else':
                                    label_types[idxc] = 'end if'


                        elif opcode == 0x95:
                            # Conditional jump: Pop a value, and if it is logically FALSE, advance by ((XX * 0x100) + YY) bytes, relative to the first byte of this instruction. 
                            file.write("\n")
                            file.write(spacing)
                            file.write('-- if (!pop()) goto label%04x;\n'%(idxc - 3 + (op1 * 256 + op2)))
                            file.write(spacing)
                            erpos = idxc - 3 + (op1 * 256 + op2)
                            if (erpos in label_types) and (label_types[erpos] == 'end repeat'):
                                file.write('if not %s then exit repeat'%(pop_s()))
                            else:
                                file.write('if %s then'%(pop_s()))
                                spacing = spacing + '    '

                        elif opcode == 0x96:
                            # Call a function defined in this script with the name at namelist[XX].
                            params = pop_s()
                            cindex = op1 * 256 + op2
                            if params.startswith('<'):
                                # The function must return something
                                if name_list[cindex] in NO_PAREN_FUNCTIONS:
                                    push('%s %s'%(name_list[cindex], params[1:]))
                                else:
                                    push('%s(%s)'%(name_list[cindex], params[1:]))
                            else:
                                file.write("\n")
                                file.write(spacing)
                                if name_list[cindex] in NO_PAREN_FUNCTIONS:
                                    file.write('%s %s'%(name_list[cindex], params))
                                else:
                                    file.write('%s(%s)'%(name_list[cindex], params))

                        elif opcode == 0x97:
                            # Call the external function with name from namelist[XX].
                            params = pop_s()
                            cindex = op1 * 256 + op2
                            if params.startswith('<'):
                                # The function must return something
                                if name_list[cindex] in NO_PAREN_FUNCTIONS:
                                    push('%s %s'%(name_list[cindex], params[1:]))
                                else:
                                    push('%s(%s)'%(name_list[cindex], params[1:]))
                            else:
                                file.write("\n")
                                file.write(spacing)
                                if name_list[cindex] in NO_PAREN_FUNCTIONS:
                                    file.write('%s %s'%(name_list[cindex], params))
                                else:
                                    file.write('%s(%s)'%(name_list[cindex], params))

                        elif opcode == 0x9F:
                            # Push the value of the contextual property with the name at namelist[XX].
                            push('the %s'%(name_list[op1 * 256 + op2]))

                        elif opcode == 0xa0:
                            # Pop one value and use it to set a property.
                            file.write("\n")
                            file.write(spacing)
                            file.write('put %s into %s'%(pop_s(), name_list[(op1 * 256 + op2)]))

                        elif opcode == 0xa1:
                            # Pop one value and use it to set a parameter. 
                            file.write("\n")
                            file.write(spacing)
                            if ((op1 * 256 + op2) % bytes_per_const) > 0:
                                bytes_per_const = ((op1 * 256 + op2) % bytes_per_const)
                            file.write('param%s = %s;'%((op1 * 256 + op2) / bytes_per_const, pop_s()))

                        elif opcode == 0xa2:
                            # Pop one value and use it to set a local variable.
                            file.write("\n")
                            file.write(spacing)
                            if ((op1 * 256 + op2) % bytes_per_const) > 0:
                                bytes_per_const = ((op1 * 256 + op2) % bytes_per_const)
                            file.write('%s = %s;'%(localvs[(op1 * 256 + op2) / bytes_per_const], pop_s()))

                        elif opcode == 0xa6:
                            # Pop an empty list and push the value of a read-only property named at namelist[XX]. 
                            pop()
                            push('%s'%(name_list[(op1 * 256 + op2)]))

                        elif opcode == 0xa7:
                            # Call a method of an object with name from namelist[XX].
                            params = pop_s()
                            cindex = op1 * 256 + op2
                            if params.startswith('<'):
                                params = params[1:]
                                obj = params[0:params.index(',')]
                                params = params[params.index(',')+2:]
                                # The function must return something
                                if name_list[cindex] in NO_PAREN_FUNCTIONS:
                                    push('%s.%s %s'%(obj, name_list[cindex], params))
                                else:
                                    push('%s.%s(%s)'%(obj, name_list[cindex], params))
                            else:
                                obj = params[0:params.index(',')]
                                params = params[params.index(',')+2:]
                                file.write("\n")
                                file.write(spacing)
                                if name_list[cindex] in NO_PAREN_FUNCTIONS:
                                    file.write('%s.%s %s'%(obj, name_list[cindex], params))
                                else:
                                    file.write('%s.%s(%s)'%(obj, name_list[cindex], params))

                        else:
                            # Unknown operation
                            flush_stack(file, spacing)
                            file.write("\n")
                            file.write(spacing)
                            file.write('unknown_op3(0x%02x, 0x%02x, 0x%02x);'%(opcode, op1, op2))

                    file.write("\n")

                file.write("end %s\n\n"%(fname))

            file.close()
 

# ====================================================================================================================================
if __name__ == '__main__':
    if len(sys.argv) < 6:
        print("USAGE: lscr2lingo [pc|mac] <work directory> <cast file name> <lscr file name> <lnam file path>")

    else:
        if sys.argv[1] != 'pc' and sys.argv[1] != 'mac':
            logging.error(" First argument must be 'pc' or 'mac'")
            sys.exit(-1)

        if sys.argv[1] == 'pc':
            bit_order_type = 'pc'
            bit_order = "<"

        if not os.path.isdir(sys.argv[2]):
            logging.error(" '%s' is not a directory"%(sys.argv[2]))
            sys.exit(-1)

        if not os.path.isfile(os.path.join(sys.argv[2], sys.argv[3])):
            logging.error(" '%s' is not a file"%(os.path.join(sys.argv[2], sys.argv[3])))
            sys.exit(-1)
        
        if not sys.argv[3].endswith('.CASt'):
            logging.error(" '%s' does not end in .CASt"%(sys.argv[3]))
            sys.exit(-1)

        if not os.path.isfile(os.path.join(sys.argv[2], sys.argv[4])):
            logging.error(" '%s' is not a file"%(os.path.join(sys.argv[2], sys.argv[4])))
            sys.exit(-1)
        
        if not sys.argv[4].endswith('.Lscr'):
            logging.error(" '%s' does not end in .Lscr"%(sys.argv[4]))
            sys.exit(-1)
            
        if not os.path.isfile(sys.argv[5]):
            logging.error(" '%s' is not a file"%(sys.argv[5]))
            sys.exit(-1)
        
        if not sys.argv[5].endswith('.Lnam'):
            logging.error(" '%s' does not end in .Lnam"%(sys.argv[5]))
            sys.exit(-1)
            
        # Get cast file data
        lscr_data = parse_cast_file(os.path.join(sys.argv[2], sys.argv[3]))
        name_list = parse_lnam_file(sys.argv[5])
        lscr2lingo(lscr_data, os.path.join(sys.argv[2], sys.argv[4]), name_list)
        